--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file binary_counter_virtex5_10_0_01e34ae12479a5e1.vhd when simulating
-- the core, binary_counter_virtex5_10_0_01e34ae12479a5e1. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY binary_counter_virtex5_10_0_01e34ae12479a5e1 IS
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(7 downto 0));
END binary_counter_virtex5_10_0_01e34ae12479a5e1;

ARCHITECTURE binary_counter_virtex5_10_0_01e34ae12479a5e1_a OF binary_counter_virtex5_10_0_01e34ae12479a5e1 IS
-- synthesis translate_off
component wrapped_binary_counter_virtex5_10_0_01e34ae12479a5e1
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(7 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_binary_counter_virtex5_10_0_01e34ae12479a5e1 use entity XilinxCoreLib.c_counter_binary_v10_0(behavioral)
		generic map(
			c_count_mode => 0,
			c_load_low => 0,
			c_count_to => "1",
			c_implementation => 0,
			c_has_sclr => 0,
			c_ce_overrides_sync => 0,
			c_restrict_count => 0,
			c_width => 8,
			c_verbosity => 0,
			c_has_load => 0,
			c_latency => 1,
			c_has_thresh0 => 0,
			c_ainit_val => "0",
			c_has_ce => 1,
			c_sclr_overrides_sset => 1,
			c_fb_latency => 0,
			c_sinit_val => "0",
			c_has_sset => 0,
			c_has_sinit => 1,
			c_count_by => "1",
			c_xdevicefamily => "virtex5",
			c_thresh0_value => "1");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_binary_counter_virtex5_10_0_01e34ae12479a5e1
		port map (
			clk => clk,
			ce => ce,
			sinit => sinit,
			q => q);
-- synthesis translate_on

END binary_counter_virtex5_10_0_01e34ae12479a5e1_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file binary_counter_virtex5_10_0_092422ed79c7db12.vhd when simulating
-- the core, binary_counter_virtex5_10_0_092422ed79c7db12. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY binary_counter_virtex5_10_0_092422ed79c7db12 IS
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(24 downto 0));
END binary_counter_virtex5_10_0_092422ed79c7db12;

ARCHITECTURE binary_counter_virtex5_10_0_092422ed79c7db12_a OF binary_counter_virtex5_10_0_092422ed79c7db12 IS
-- synthesis translate_off
component wrapped_binary_counter_virtex5_10_0_092422ed79c7db12
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(24 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_binary_counter_virtex5_10_0_092422ed79c7db12 use entity XilinxCoreLib.c_counter_binary_v10_0(behavioral)
		generic map(
			c_count_mode => 0,
			c_load_low => 0,
			c_count_to => "1",
			c_implementation => 0,
			c_has_sclr => 0,
			c_ce_overrides_sync => 0,
			c_restrict_count => 0,
			c_width => 25,
			c_verbosity => 0,
			c_has_load => 0,
			c_latency => 1,
			c_has_thresh0 => 0,
			c_ainit_val => "0",
			c_has_ce => 1,
			c_sclr_overrides_sset => 1,
			c_fb_latency => 0,
			c_sinit_val => "0",
			c_has_sset => 0,
			c_has_sinit => 1,
			c_count_by => "1",
			c_xdevicefamily => "virtex5",
			c_thresh0_value => "1");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_binary_counter_virtex5_10_0_092422ed79c7db12
		port map (
			clk => clk,
			ce => ce,
			sinit => sinit,
			q => q);
-- synthesis translate_on

END binary_counter_virtex5_10_0_092422ed79c7db12_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file binary_counter_virtex5_10_0_1c25d2b550c5fffc.vhd when simulating
-- the core, binary_counter_virtex5_10_0_1c25d2b550c5fffc. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY binary_counter_virtex5_10_0_1c25d2b550c5fffc IS
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(8 downto 0));
END binary_counter_virtex5_10_0_1c25d2b550c5fffc;

ARCHITECTURE binary_counter_virtex5_10_0_1c25d2b550c5fffc_a OF binary_counter_virtex5_10_0_1c25d2b550c5fffc IS
-- synthesis translate_off
component wrapped_binary_counter_virtex5_10_0_1c25d2b550c5fffc
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(8 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_binary_counter_virtex5_10_0_1c25d2b550c5fffc use entity XilinxCoreLib.c_counter_binary_v10_0(behavioral)
		generic map(
			c_count_mode => 0,
			c_load_low => 0,
			c_count_to => "1",
			c_implementation => 0,
			c_has_sclr => 0,
			c_ce_overrides_sync => 0,
			c_restrict_count => 0,
			c_width => 9,
			c_verbosity => 0,
			c_has_load => 0,
			c_latency => 1,
			c_has_thresh0 => 0,
			c_ainit_val => "0",
			c_has_ce => 1,
			c_sclr_overrides_sset => 1,
			c_fb_latency => 0,
			c_sinit_val => "0",
			c_has_sset => 0,
			c_has_sinit => 1,
			c_count_by => "1",
			c_xdevicefamily => "virtex5",
			c_thresh0_value => "1");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_binary_counter_virtex5_10_0_1c25d2b550c5fffc
		port map (
			clk => clk,
			ce => ce,
			sinit => sinit,
			q => q);
-- synthesis translate_on

END binary_counter_virtex5_10_0_1c25d2b550c5fffc_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file binary_counter_virtex5_10_0_1ee993c8ed57b9ce.vhd when simulating
-- the core, binary_counter_virtex5_10_0_1ee993c8ed57b9ce. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY binary_counter_virtex5_10_0_1ee993c8ed57b9ce IS
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(9 downto 0));
END binary_counter_virtex5_10_0_1ee993c8ed57b9ce;

ARCHITECTURE binary_counter_virtex5_10_0_1ee993c8ed57b9ce_a OF binary_counter_virtex5_10_0_1ee993c8ed57b9ce IS
-- synthesis translate_off
component wrapped_binary_counter_virtex5_10_0_1ee993c8ed57b9ce
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(9 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_binary_counter_virtex5_10_0_1ee993c8ed57b9ce use entity XilinxCoreLib.c_counter_binary_v10_0(behavioral)
		generic map(
			c_count_mode => 0,
			c_load_low => 0,
			c_count_to => "1",
			c_implementation => 0,
			c_has_sclr => 0,
			c_ce_overrides_sync => 0,
			c_restrict_count => 0,
			c_width => 10,
			c_verbosity => 0,
			c_has_load => 0,
			c_latency => 1,
			c_has_thresh0 => 0,
			c_ainit_val => "0",
			c_has_ce => 1,
			c_sclr_overrides_sset => 1,
			c_fb_latency => 0,
			c_sinit_val => "0",
			c_has_sset => 0,
			c_has_sinit => 1,
			c_count_by => "1",
			c_xdevicefamily => "virtex5",
			c_thresh0_value => "1");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_binary_counter_virtex5_10_0_1ee993c8ed57b9ce
		port map (
			clk => clk,
			ce => ce,
			sinit => sinit,
			q => q);
-- synthesis translate_on

END binary_counter_virtex5_10_0_1ee993c8ed57b9ce_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file binary_counter_virtex5_10_0_487c95d8131ef26d.vhd when simulating
-- the core, binary_counter_virtex5_10_0_487c95d8131ef26d. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY binary_counter_virtex5_10_0_487c95d8131ef26d IS
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(31 downto 0));
END binary_counter_virtex5_10_0_487c95d8131ef26d;

ARCHITECTURE binary_counter_virtex5_10_0_487c95d8131ef26d_a OF binary_counter_virtex5_10_0_487c95d8131ef26d IS
-- synthesis translate_off
component wrapped_binary_counter_virtex5_10_0_487c95d8131ef26d
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(31 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_binary_counter_virtex5_10_0_487c95d8131ef26d use entity XilinxCoreLib.c_counter_binary_v10_0(behavioral)
		generic map(
			c_count_mode => 0,
			c_load_low => 0,
			c_count_to => "1",
			c_implementation => 0,
			c_has_sclr => 0,
			c_ce_overrides_sync => 0,
			c_restrict_count => 0,
			c_width => 32,
			c_verbosity => 0,
			c_has_load => 0,
			c_latency => 1,
			c_has_thresh0 => 0,
			c_ainit_val => "0",
			c_has_ce => 1,
			c_sclr_overrides_sset => 1,
			c_fb_latency => 0,
			c_sinit_val => "0",
			c_has_sset => 0,
			c_has_sinit => 1,
			c_count_by => "1",
			c_xdevicefamily => "virtex5",
			c_thresh0_value => "1");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_binary_counter_virtex5_10_0_487c95d8131ef26d
		port map (
			clk => clk,
			ce => ce,
			sinit => sinit,
			q => q);
-- synthesis translate_on

END binary_counter_virtex5_10_0_487c95d8131ef26d_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file binary_counter_virtex5_10_0_6ddb97ef480a3f10.vhd when simulating
-- the core, binary_counter_virtex5_10_0_6ddb97ef480a3f10. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY binary_counter_virtex5_10_0_6ddb97ef480a3f10 IS
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(13 downto 0));
END binary_counter_virtex5_10_0_6ddb97ef480a3f10;

ARCHITECTURE binary_counter_virtex5_10_0_6ddb97ef480a3f10_a OF binary_counter_virtex5_10_0_6ddb97ef480a3f10 IS
-- synthesis translate_off
component wrapped_binary_counter_virtex5_10_0_6ddb97ef480a3f10
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(13 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_binary_counter_virtex5_10_0_6ddb97ef480a3f10 use entity XilinxCoreLib.c_counter_binary_v10_0(behavioral)
		generic map(
			c_count_mode => 0,
			c_load_low => 0,
			c_count_to => "1",
			c_implementation => 0,
			c_has_sclr => 0,
			c_ce_overrides_sync => 0,
			c_restrict_count => 0,
			c_width => 14,
			c_verbosity => 0,
			c_has_load => 0,
			c_latency => 1,
			c_has_thresh0 => 0,
			c_ainit_val => "0",
			c_has_ce => 1,
			c_sclr_overrides_sset => 1,
			c_fb_latency => 0,
			c_sinit_val => "0",
			c_has_sset => 0,
			c_has_sinit => 1,
			c_count_by => "1",
			c_xdevicefamily => "virtex5",
			c_thresh0_value => "1");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_binary_counter_virtex5_10_0_6ddb97ef480a3f10
		port map (
			clk => clk,
			ce => ce,
			sinit => sinit,
			q => q);
-- synthesis translate_on

END binary_counter_virtex5_10_0_6ddb97ef480a3f10_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file binary_counter_virtex5_10_0_722dc5ef3883365e.vhd when simulating
-- the core, binary_counter_virtex5_10_0_722dc5ef3883365e. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY binary_counter_virtex5_10_0_722dc5ef3883365e IS
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(6 downto 0));
END binary_counter_virtex5_10_0_722dc5ef3883365e;

ARCHITECTURE binary_counter_virtex5_10_0_722dc5ef3883365e_a OF binary_counter_virtex5_10_0_722dc5ef3883365e IS
-- synthesis translate_off
component wrapped_binary_counter_virtex5_10_0_722dc5ef3883365e
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(6 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_binary_counter_virtex5_10_0_722dc5ef3883365e use entity XilinxCoreLib.c_counter_binary_v10_0(behavioral)
		generic map(
			c_count_mode => 0,
			c_load_low => 0,
			c_count_to => "1",
			c_implementation => 0,
			c_has_sclr => 0,
			c_ce_overrides_sync => 0,
			c_restrict_count => 0,
			c_width => 7,
			c_verbosity => 0,
			c_has_load => 0,
			c_latency => 1,
			c_has_thresh0 => 0,
			c_ainit_val => "0",
			c_has_ce => 1,
			c_sclr_overrides_sset => 1,
			c_fb_latency => 0,
			c_sinit_val => "0",
			c_has_sset => 0,
			c_has_sinit => 1,
			c_count_by => "1",
			c_xdevicefamily => "virtex5",
			c_thresh0_value => "1");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_binary_counter_virtex5_10_0_722dc5ef3883365e
		port map (
			clk => clk,
			ce => ce,
			sinit => sinit,
			q => q);
-- synthesis translate_on

END binary_counter_virtex5_10_0_722dc5ef3883365e_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file binary_counter_virtex5_10_0_76ea00975735b561.vhd when simulating
-- the core, binary_counter_virtex5_10_0_76ea00975735b561. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY binary_counter_virtex5_10_0_76ea00975735b561 IS
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(1 downto 0));
END binary_counter_virtex5_10_0_76ea00975735b561;

ARCHITECTURE binary_counter_virtex5_10_0_76ea00975735b561_a OF binary_counter_virtex5_10_0_76ea00975735b561 IS
-- synthesis translate_off
component wrapped_binary_counter_virtex5_10_0_76ea00975735b561
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(1 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_binary_counter_virtex5_10_0_76ea00975735b561 use entity XilinxCoreLib.c_counter_binary_v10_0(behavioral)
		generic map(
			c_count_mode => 0,
			c_load_low => 0,
			c_count_to => "1",
			c_implementation => 0,
			c_has_sclr => 0,
			c_ce_overrides_sync => 0,
			c_restrict_count => 0,
			c_width => 2,
			c_verbosity => 0,
			c_has_load => 0,
			c_latency => 1,
			c_has_thresh0 => 0,
			c_ainit_val => "0",
			c_has_ce => 1,
			c_sclr_overrides_sset => 1,
			c_fb_latency => 0,
			c_sinit_val => "0",
			c_has_sset => 0,
			c_has_sinit => 1,
			c_count_by => "1",
			c_xdevicefamily => "virtex5",
			c_thresh0_value => "1");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_binary_counter_virtex5_10_0_76ea00975735b561
		port map (
			clk => clk,
			ce => ce,
			sinit => sinit,
			q => q);
-- synthesis translate_on

END binary_counter_virtex5_10_0_76ea00975735b561_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file binary_counter_virtex5_10_0_833a35886d0c544c.vhd when simulating
-- the core, binary_counter_virtex5_10_0_833a35886d0c544c. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY binary_counter_virtex5_10_0_833a35886d0c544c IS
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(3 downto 0));
END binary_counter_virtex5_10_0_833a35886d0c544c;

ARCHITECTURE binary_counter_virtex5_10_0_833a35886d0c544c_a OF binary_counter_virtex5_10_0_833a35886d0c544c IS
-- synthesis translate_off
component wrapped_binary_counter_virtex5_10_0_833a35886d0c544c
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(3 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_binary_counter_virtex5_10_0_833a35886d0c544c use entity XilinxCoreLib.c_counter_binary_v10_0(behavioral)
		generic map(
			c_count_mode => 0,
			c_load_low => 0,
			c_count_to => "1",
			c_implementation => 0,
			c_has_sclr => 0,
			c_ce_overrides_sync => 0,
			c_restrict_count => 0,
			c_width => 4,
			c_verbosity => 0,
			c_has_load => 0,
			c_latency => 1,
			c_has_thresh0 => 0,
			c_ainit_val => "0",
			c_has_ce => 1,
			c_sclr_overrides_sset => 1,
			c_fb_latency => 0,
			c_sinit_val => "0",
			c_has_sset => 0,
			c_has_sinit => 1,
			c_count_by => "1",
			c_xdevicefamily => "virtex5",
			c_thresh0_value => "1");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_binary_counter_virtex5_10_0_833a35886d0c544c
		port map (
			clk => clk,
			ce => ce,
			sinit => sinit,
			q => q);
-- synthesis translate_on

END binary_counter_virtex5_10_0_833a35886d0c544c_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file binary_counter_virtex5_10_0_924a7f7132ea4004.vhd when simulating
-- the core, binary_counter_virtex5_10_0_924a7f7132ea4004. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY binary_counter_virtex5_10_0_924a7f7132ea4004 IS
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(2 downto 0));
END binary_counter_virtex5_10_0_924a7f7132ea4004;

ARCHITECTURE binary_counter_virtex5_10_0_924a7f7132ea4004_a OF binary_counter_virtex5_10_0_924a7f7132ea4004 IS
-- synthesis translate_off
component wrapped_binary_counter_virtex5_10_0_924a7f7132ea4004
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(2 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_binary_counter_virtex5_10_0_924a7f7132ea4004 use entity XilinxCoreLib.c_counter_binary_v10_0(behavioral)
		generic map(
			c_count_mode => 0,
			c_load_low => 0,
			c_count_to => "1",
			c_implementation => 0,
			c_has_sclr => 0,
			c_ce_overrides_sync => 0,
			c_restrict_count => 0,
			c_width => 3,
			c_verbosity => 0,
			c_has_load => 0,
			c_latency => 1,
			c_has_thresh0 => 0,
			c_ainit_val => "0",
			c_has_ce => 1,
			c_sclr_overrides_sset => 1,
			c_fb_latency => 0,
			c_sinit_val => "0",
			c_has_sset => 0,
			c_has_sinit => 1,
			c_count_by => "1",
			c_xdevicefamily => "virtex5",
			c_thresh0_value => "1");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_binary_counter_virtex5_10_0_924a7f7132ea4004
		port map (
			clk => clk,
			ce => ce,
			sinit => sinit,
			q => q);
-- synthesis translate_on

END binary_counter_virtex5_10_0_924a7f7132ea4004_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file binary_counter_virtex5_10_0_ad5bcb1136ed8cf6.vhd when simulating
-- the core, binary_counter_virtex5_10_0_ad5bcb1136ed8cf6. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY binary_counter_virtex5_10_0_ad5bcb1136ed8cf6 IS
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(4 downto 0));
END binary_counter_virtex5_10_0_ad5bcb1136ed8cf6;

ARCHITECTURE binary_counter_virtex5_10_0_ad5bcb1136ed8cf6_a OF binary_counter_virtex5_10_0_ad5bcb1136ed8cf6 IS
-- synthesis translate_off
component wrapped_binary_counter_virtex5_10_0_ad5bcb1136ed8cf6
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(4 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_binary_counter_virtex5_10_0_ad5bcb1136ed8cf6 use entity XilinxCoreLib.c_counter_binary_v10_0(behavioral)
		generic map(
			c_count_mode => 0,
			c_load_low => 0,
			c_count_to => "1",
			c_implementation => 0,
			c_has_sclr => 0,
			c_ce_overrides_sync => 0,
			c_restrict_count => 0,
			c_width => 5,
			c_verbosity => 0,
			c_has_load => 0,
			c_latency => 1,
			c_has_thresh0 => 0,
			c_ainit_val => "0",
			c_has_ce => 1,
			c_sclr_overrides_sset => 1,
			c_fb_latency => 0,
			c_sinit_val => "0",
			c_has_sset => 0,
			c_has_sinit => 1,
			c_count_by => "1",
			c_xdevicefamily => "virtex5",
			c_thresh0_value => "1");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_binary_counter_virtex5_10_0_ad5bcb1136ed8cf6
		port map (
			clk => clk,
			ce => ce,
			sinit => sinit,
			q => q);
-- synthesis translate_on

END binary_counter_virtex5_10_0_ad5bcb1136ed8cf6_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file binary_counter_virtex5_10_0_ed17144209261f47.vhd when simulating
-- the core, binary_counter_virtex5_10_0_ed17144209261f47. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY binary_counter_virtex5_10_0_ed17144209261f47 IS
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(10 downto 0));
END binary_counter_virtex5_10_0_ed17144209261f47;

ARCHITECTURE binary_counter_virtex5_10_0_ed17144209261f47_a OF binary_counter_virtex5_10_0_ed17144209261f47 IS
-- synthesis translate_off
component wrapped_binary_counter_virtex5_10_0_ed17144209261f47
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(10 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_binary_counter_virtex5_10_0_ed17144209261f47 use entity XilinxCoreLib.c_counter_binary_v10_0(behavioral)
		generic map(
			c_count_mode => 0,
			c_load_low => 0,
			c_count_to => "1",
			c_implementation => 0,
			c_has_sclr => 0,
			c_ce_overrides_sync => 0,
			c_restrict_count => 0,
			c_width => 11,
			c_verbosity => 0,
			c_has_load => 0,
			c_latency => 1,
			c_has_thresh0 => 0,
			c_ainit_val => "0",
			c_has_ce => 1,
			c_sclr_overrides_sset => 1,
			c_fb_latency => 0,
			c_sinit_val => "0",
			c_has_sset => 0,
			c_has_sinit => 1,
			c_count_by => "1",
			c_xdevicefamily => "virtex5",
			c_thresh0_value => "1");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_binary_counter_virtex5_10_0_ed17144209261f47
		port map (
			clk => clk,
			ce => ce,
			sinit => sinit,
			q => q);
-- synthesis translate_on

END binary_counter_virtex5_10_0_ed17144209261f47_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file binary_counter_virtex5_10_0_f8c7b661c01eeb1d.vhd when simulating
-- the core, binary_counter_virtex5_10_0_f8c7b661c01eeb1d. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY binary_counter_virtex5_10_0_f8c7b661c01eeb1d IS
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(26 downto 0));
END binary_counter_virtex5_10_0_f8c7b661c01eeb1d;

ARCHITECTURE binary_counter_virtex5_10_0_f8c7b661c01eeb1d_a OF binary_counter_virtex5_10_0_f8c7b661c01eeb1d IS
-- synthesis translate_off
component wrapped_binary_counter_virtex5_10_0_f8c7b661c01eeb1d
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(26 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_binary_counter_virtex5_10_0_f8c7b661c01eeb1d use entity XilinxCoreLib.c_counter_binary_v10_0(behavioral)
		generic map(
			c_count_mode => 0,
			c_load_low => 0,
			c_count_to => "1",
			c_implementation => 0,
			c_has_sclr => 0,
			c_ce_overrides_sync => 0,
			c_restrict_count => 0,
			c_width => 27,
			c_verbosity => 0,
			c_has_load => 0,
			c_latency => 1,
			c_has_thresh0 => 0,
			c_ainit_val => "0",
			c_has_ce => 1,
			c_sclr_overrides_sset => 1,
			c_fb_latency => 0,
			c_sinit_val => "0",
			c_has_sset => 0,
			c_has_sinit => 1,
			c_count_by => "1",
			c_xdevicefamily => "virtex5",
			c_thresh0_value => "1");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_binary_counter_virtex5_10_0_f8c7b661c01eeb1d
		port map (
			clk => clk,
			ce => ce,
			sinit => sinit,
			q => q);
-- synthesis translate_on

END binary_counter_virtex5_10_0_f8c7b661c01eeb1d_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file binary_counter_virtex5_10_0_fe346e03af2452eb.vhd when simulating
-- the core, binary_counter_virtex5_10_0_fe346e03af2452eb. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY binary_counter_virtex5_10_0_fe346e03af2452eb IS
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(5 downto 0));
END binary_counter_virtex5_10_0_fe346e03af2452eb;

ARCHITECTURE binary_counter_virtex5_10_0_fe346e03af2452eb_a OF binary_counter_virtex5_10_0_fe346e03af2452eb IS
-- synthesis translate_off
component wrapped_binary_counter_virtex5_10_0_fe346e03af2452eb
	port (
	clk: IN std_logic;
	ce: IN std_logic;
	sinit: IN std_logic;
	q: OUT std_logic_VECTOR(5 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_binary_counter_virtex5_10_0_fe346e03af2452eb use entity XilinxCoreLib.c_counter_binary_v10_0(behavioral)
		generic map(
			c_count_mode => 0,
			c_load_low => 0,
			c_count_to => "1",
			c_implementation => 0,
			c_has_sclr => 0,
			c_ce_overrides_sync => 0,
			c_restrict_count => 0,
			c_width => 6,
			c_verbosity => 0,
			c_has_load => 0,
			c_latency => 1,
			c_has_thresh0 => 0,
			c_ainit_val => "0",
			c_has_ce => 1,
			c_sclr_overrides_sset => 1,
			c_fb_latency => 0,
			c_sinit_val => "0",
			c_has_sset => 0,
			c_has_sinit => 1,
			c_count_by => "1",
			c_xdevicefamily => "virtex5",
			c_thresh0_value => "1");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_binary_counter_virtex5_10_0_fe346e03af2452eb
		port map (
			clk => clk,
			ce => ce,
			sinit => sinit,
			q => q);
-- synthesis translate_on

END binary_counter_virtex5_10_0_fe346e03af2452eb_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_0206823b131149d8.vhd when simulating
-- the core, bmg_24_vx5_0206823b131149d8. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_0206823b131149d8 IS
	port (
	clka: IN std_logic;
	dina: IN std_logic_VECTOR(17 downto 0);
	addra: IN std_logic_VECTOR(8 downto 0);
	ena: IN std_logic;
	wea: IN std_logic_VECTOR(0 downto 0);
	douta: OUT std_logic_VECTOR(17 downto 0));
END bmg_24_vx5_0206823b131149d8;

ARCHITECTURE bmg_24_vx5_0206823b131149d8_a OF bmg_24_vx5_0206823b131149d8 IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_0206823b131149d8
	port (
	clka: IN std_logic;
	dina: IN std_logic_VECTOR(17 downto 0);
	addra: IN std_logic_VECTOR(8 downto 0);
	ena: IN std_logic;
	wea: IN std_logic_VECTOR(0 downto 0);
	douta: OUT std_logic_VECTOR(17 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_0206823b131149d8 use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 0,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 18,
			c_family => "virtex5",
			c_read_width_a => 18,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_0206823b131149d8.mif",
			c_write_mode_a => "READ_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 512,
			c_write_depth_a => 512,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 9,
			c_addrb_width => 9,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 18,
			c_write_width_a => 18,
			c_read_depth_b => 512,
			c_read_depth_a => 512,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_0206823b131149d8
		port map (
			clka => clka,
			dina => dina,
			addra => addra,
			ena => ena,
			wea => wea,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_0206823b131149d8_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_17f5cef47a567d97.vhd when simulating
-- the core, bmg_24_vx5_17f5cef47a567d97. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_17f5cef47a567d97 IS
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(9 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(8 downto 0));
END bmg_24_vx5_17f5cef47a567d97;

ARCHITECTURE bmg_24_vx5_17f5cef47a567d97_a OF bmg_24_vx5_17f5cef47a567d97 IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_17f5cef47a567d97
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(9 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(8 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_17f5cef47a567d97 use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 3,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 9,
			c_family => "virtex5",
			c_read_width_a => 9,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_17f5cef47a567d97.mif",
			c_write_mode_a => "WRITE_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 1024,
			c_write_depth_a => 1024,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 10,
			c_addrb_width => 10,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 9,
			c_write_width_a => 9,
			c_read_depth_b => 1024,
			c_read_depth_a => 1024,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_17f5cef47a567d97
		port map (
			clka => clka,
			addra => addra,
			ena => ena,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_17f5cef47a567d97_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_22468d6827fd0e85.vhd when simulating
-- the core, bmg_24_vx5_22468d6827fd0e85. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_22468d6827fd0e85 IS
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(9 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(8 downto 0));
END bmg_24_vx5_22468d6827fd0e85;

ARCHITECTURE bmg_24_vx5_22468d6827fd0e85_a OF bmg_24_vx5_22468d6827fd0e85 IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_22468d6827fd0e85
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(9 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(8 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_22468d6827fd0e85 use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 3,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 9,
			c_family => "virtex5",
			c_read_width_a => 9,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_22468d6827fd0e85.mif",
			c_write_mode_a => "WRITE_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 1024,
			c_write_depth_a => 1024,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 10,
			c_addrb_width => 10,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 9,
			c_write_width_a => 9,
			c_read_depth_b => 1024,
			c_read_depth_a => 1024,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_22468d6827fd0e85
		port map (
			clka => clka,
			addra => addra,
			ena => ena,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_22468d6827fd0e85_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_2c49e6ef11a51d10.vhd when simulating
-- the core, bmg_24_vx5_2c49e6ef11a51d10. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_2c49e6ef11a51d10 IS
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(7 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(17 downto 0));
END bmg_24_vx5_2c49e6ef11a51d10;

ARCHITECTURE bmg_24_vx5_2c49e6ef11a51d10_a OF bmg_24_vx5_2c49e6ef11a51d10 IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_2c49e6ef11a51d10
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(7 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(17 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_2c49e6ef11a51d10 use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 3,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 18,
			c_family => "virtex5",
			c_read_width_a => 18,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_2c49e6ef11a51d10.mif",
			c_write_mode_a => "WRITE_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 256,
			c_write_depth_a => 256,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 8,
			c_addrb_width => 8,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 18,
			c_write_width_a => 18,
			c_read_depth_b => 256,
			c_read_depth_a => 256,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_2c49e6ef11a51d10
		port map (
			clka => clka,
			addra => addra,
			ena => ena,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_2c49e6ef11a51d10_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_2c89c45c28fef7b6.vhd when simulating
-- the core, bmg_24_vx5_2c89c45c28fef7b6. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_2c89c45c28fef7b6 IS
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(9 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(8 downto 0));
END bmg_24_vx5_2c89c45c28fef7b6;

ARCHITECTURE bmg_24_vx5_2c89c45c28fef7b6_a OF bmg_24_vx5_2c89c45c28fef7b6 IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_2c89c45c28fef7b6
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(9 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(8 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_2c89c45c28fef7b6 use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 3,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 9,
			c_family => "virtex5",
			c_read_width_a => 9,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_2c89c45c28fef7b6.mif",
			c_write_mode_a => "WRITE_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 1024,
			c_write_depth_a => 1024,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 10,
			c_addrb_width => 10,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 9,
			c_write_width_a => 9,
			c_read_depth_b => 1024,
			c_read_depth_a => 1024,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_2c89c45c28fef7b6
		port map (
			clka => clka,
			addra => addra,
			ena => ena,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_2c89c45c28fef7b6_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_462f2ec6a7a3f012.vhd when simulating
-- the core, bmg_24_vx5_462f2ec6a7a3f012. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_462f2ec6a7a3f012 IS
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(7 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(17 downto 0));
END bmg_24_vx5_462f2ec6a7a3f012;

ARCHITECTURE bmg_24_vx5_462f2ec6a7a3f012_a OF bmg_24_vx5_462f2ec6a7a3f012 IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_462f2ec6a7a3f012
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(7 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(17 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_462f2ec6a7a3f012 use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 3,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 18,
			c_family => "virtex5",
			c_read_width_a => 18,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_462f2ec6a7a3f012.mif",
			c_write_mode_a => "WRITE_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 256,
			c_write_depth_a => 256,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 8,
			c_addrb_width => 8,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 18,
			c_write_width_a => 18,
			c_read_depth_b => 256,
			c_read_depth_a => 256,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_462f2ec6a7a3f012
		port map (
			clka => clka,
			addra => addra,
			ena => ena,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_462f2ec6a7a3f012_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_491b66ad487fb1cf.vhd when simulating
-- the core, bmg_24_vx5_491b66ad487fb1cf. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_491b66ad487fb1cf IS
	port (
	clka: IN std_logic;
	dina: IN std_logic_VECTOR(10 downto 0);
	addra: IN std_logic_VECTOR(6 downto 0);
	ena: IN std_logic;
	wea: IN std_logic_VECTOR(0 downto 0);
	douta: OUT std_logic_VECTOR(10 downto 0));
END bmg_24_vx5_491b66ad487fb1cf;

ARCHITECTURE bmg_24_vx5_491b66ad487fb1cf_a OF bmg_24_vx5_491b66ad487fb1cf IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_491b66ad487fb1cf
	port (
	clka: IN std_logic;
	dina: IN std_logic_VECTOR(10 downto 0);
	addra: IN std_logic_VECTOR(6 downto 0);
	ena: IN std_logic;
	wea: IN std_logic_VECTOR(0 downto 0);
	douta: OUT std_logic_VECTOR(10 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_491b66ad487fb1cf use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 0,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 11,
			c_family => "virtex5",
			c_read_width_a => 11,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_491b66ad487fb1cf.mif",
			c_write_mode_a => "READ_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 128,
			c_write_depth_a => 128,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 7,
			c_addrb_width => 7,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 11,
			c_write_width_a => 11,
			c_read_depth_b => 128,
			c_read_depth_a => 128,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_491b66ad487fb1cf
		port map (
			clka => clka,
			dina => dina,
			addra => addra,
			ena => ena,
			wea => wea,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_491b66ad487fb1cf_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_6f3d016421754f60.vhd when simulating
-- the core, bmg_24_vx5_6f3d016421754f60. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_6f3d016421754f60 IS
	port (
	clka: IN std_logic;
	dina: IN std_logic_VECTOR(31 downto 0);
	addra: IN std_logic_VECTOR(9 downto 0);
	ena: IN std_logic;
	wea: IN std_logic_VECTOR(0 downto 0);
	douta: OUT std_logic_VECTOR(31 downto 0));
END bmg_24_vx5_6f3d016421754f60;

ARCHITECTURE bmg_24_vx5_6f3d016421754f60_a OF bmg_24_vx5_6f3d016421754f60 IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_6f3d016421754f60
	port (
	clka: IN std_logic;
	dina: IN std_logic_VECTOR(31 downto 0);
	addra: IN std_logic_VECTOR(9 downto 0);
	ena: IN std_logic;
	wea: IN std_logic_VECTOR(0 downto 0);
	douta: OUT std_logic_VECTOR(31 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_6f3d016421754f60 use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 0,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 32,
			c_family => "virtex5",
			c_read_width_a => 32,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_6f3d016421754f60.mif",
			c_write_mode_a => "READ_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 1024,
			c_write_depth_a => 1024,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 10,
			c_addrb_width => 10,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 1,
			c_write_width_b => 32,
			c_write_width_a => 32,
			c_read_depth_b => 1024,
			c_read_depth_a => 1024,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_6f3d016421754f60
		port map (
			clka => clka,
			dina => dina,
			addra => addra,
			ena => ena,
			wea => wea,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_6f3d016421754f60_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_7bc1e03f2e4955ca.vhd when simulating
-- the core, bmg_24_vx5_7bc1e03f2e4955ca. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_7bc1e03f2e4955ca IS
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(9 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(8 downto 0));
END bmg_24_vx5_7bc1e03f2e4955ca;

ARCHITECTURE bmg_24_vx5_7bc1e03f2e4955ca_a OF bmg_24_vx5_7bc1e03f2e4955ca IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_7bc1e03f2e4955ca
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(9 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(8 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_7bc1e03f2e4955ca use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 3,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 9,
			c_family => "virtex5",
			c_read_width_a => 9,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_7bc1e03f2e4955ca.mif",
			c_write_mode_a => "WRITE_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 1024,
			c_write_depth_a => 1024,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 10,
			c_addrb_width => 10,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 9,
			c_write_width_a => 9,
			c_read_depth_b => 1024,
			c_read_depth_a => 1024,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_7bc1e03f2e4955ca
		port map (
			clka => clka,
			addra => addra,
			ena => ena,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_7bc1e03f2e4955ca_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_8259598782c619da.vhd when simulating
-- the core, bmg_24_vx5_8259598782c619da. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_8259598782c619da IS
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(9 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(8 downto 0));
END bmg_24_vx5_8259598782c619da;

ARCHITECTURE bmg_24_vx5_8259598782c619da_a OF bmg_24_vx5_8259598782c619da IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_8259598782c619da
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(9 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(8 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_8259598782c619da use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 3,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 9,
			c_family => "virtex5",
			c_read_width_a => 9,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_8259598782c619da.mif",
			c_write_mode_a => "WRITE_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 1024,
			c_write_depth_a => 1024,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 10,
			c_addrb_width => 10,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 9,
			c_write_width_a => 9,
			c_read_depth_b => 1024,
			c_read_depth_a => 1024,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_8259598782c619da
		port map (
			clka => clka,
			addra => addra,
			ena => ena,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_8259598782c619da_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_916edb207080a9d0.vhd when simulating
-- the core, bmg_24_vx5_916edb207080a9d0. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_916edb207080a9d0 IS
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(9 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(8 downto 0));
END bmg_24_vx5_916edb207080a9d0;

ARCHITECTURE bmg_24_vx5_916edb207080a9d0_a OF bmg_24_vx5_916edb207080a9d0 IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_916edb207080a9d0
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(9 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(8 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_916edb207080a9d0 use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 3,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 9,
			c_family => "virtex5",
			c_read_width_a => 9,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_916edb207080a9d0.mif",
			c_write_mode_a => "WRITE_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 1024,
			c_write_depth_a => 1024,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 10,
			c_addrb_width => 10,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 9,
			c_write_width_a => 9,
			c_read_depth_b => 1024,
			c_read_depth_a => 1024,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_916edb207080a9d0
		port map (
			clka => clka,
			addra => addra,
			ena => ena,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_916edb207080a9d0_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_941504d2ced01311.vhd when simulating
-- the core, bmg_24_vx5_941504d2ced01311. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_941504d2ced01311 IS
	port (
	clka: IN std_logic;
	dina: IN std_logic_VECTOR(18 downto 0);
	addra: IN std_logic_VECTOR(8 downto 0);
	ena: IN std_logic;
	wea: IN std_logic_VECTOR(0 downto 0);
	douta: OUT std_logic_VECTOR(18 downto 0));
END bmg_24_vx5_941504d2ced01311;

ARCHITECTURE bmg_24_vx5_941504d2ced01311_a OF bmg_24_vx5_941504d2ced01311 IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_941504d2ced01311
	port (
	clka: IN std_logic;
	dina: IN std_logic_VECTOR(18 downto 0);
	addra: IN std_logic_VECTOR(8 downto 0);
	ena: IN std_logic;
	wea: IN std_logic_VECTOR(0 downto 0);
	douta: OUT std_logic_VECTOR(18 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_941504d2ced01311 use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 0,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 19,
			c_family => "virtex5",
			c_read_width_a => 19,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_941504d2ced01311.mif",
			c_write_mode_a => "READ_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 512,
			c_write_depth_a => 512,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 9,
			c_addrb_width => 9,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 19,
			c_write_width_a => 19,
			c_read_depth_b => 512,
			c_read_depth_a => 512,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_941504d2ced01311
		port map (
			clka => clka,
			dina => dina,
			addra => addra,
			ena => ena,
			wea => wea,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_941504d2ced01311_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_94232660d90f6688.vhd when simulating
-- the core, bmg_24_vx5_94232660d90f6688. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_94232660d90f6688 IS
	port (
	clka: IN std_logic;
	dina: IN std_logic_VECTOR(10 downto 0);
	addra: IN std_logic_VECTOR(5 downto 0);
	ena: IN std_logic;
	wea: IN std_logic_VECTOR(0 downto 0);
	douta: OUT std_logic_VECTOR(10 downto 0));
END bmg_24_vx5_94232660d90f6688;

ARCHITECTURE bmg_24_vx5_94232660d90f6688_a OF bmg_24_vx5_94232660d90f6688 IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_94232660d90f6688
	port (
	clka: IN std_logic;
	dina: IN std_logic_VECTOR(10 downto 0);
	addra: IN std_logic_VECTOR(5 downto 0);
	ena: IN std_logic;
	wea: IN std_logic_VECTOR(0 downto 0);
	douta: OUT std_logic_VECTOR(10 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_94232660d90f6688 use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 0,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 11,
			c_family => "virtex5",
			c_read_width_a => 11,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_94232660d90f6688.mif",
			c_write_mode_a => "READ_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 64,
			c_write_depth_a => 64,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 6,
			c_addrb_width => 6,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 11,
			c_write_width_a => 11,
			c_read_depth_b => 64,
			c_read_depth_a => 64,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_94232660d90f6688
		port map (
			clka => clka,
			dina => dina,
			addra => addra,
			ena => ena,
			wea => wea,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_94232660d90f6688_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_9d8577c93c4baa0d.vhd when simulating
-- the core, bmg_24_vx5_9d8577c93c4baa0d. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_9d8577c93c4baa0d IS
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(5 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(17 downto 0));
END bmg_24_vx5_9d8577c93c4baa0d;

ARCHITECTURE bmg_24_vx5_9d8577c93c4baa0d_a OF bmg_24_vx5_9d8577c93c4baa0d IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_9d8577c93c4baa0d
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(5 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(17 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_9d8577c93c4baa0d use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 3,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 18,
			c_family => "virtex5",
			c_read_width_a => 18,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_9d8577c93c4baa0d.mif",
			c_write_mode_a => "WRITE_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 64,
			c_write_depth_a => 64,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 6,
			c_addrb_width => 6,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 18,
			c_write_width_a => 18,
			c_read_depth_b => 64,
			c_read_depth_a => 64,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_9d8577c93c4baa0d
		port map (
			clka => clka,
			addra => addra,
			ena => ena,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_9d8577c93c4baa0d_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_b3a285035a3712ee.vhd when simulating
-- the core, bmg_24_vx5_b3a285035a3712ee. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_b3a285035a3712ee IS
	port (
	clka: IN std_logic;
	dina: IN std_logic_VECTOR(7 downto 0);
	addra: IN std_logic_VECTOR(9 downto 0);
	ena: IN std_logic;
	wea: IN std_logic_VECTOR(0 downto 0);
	douta: OUT std_logic_VECTOR(7 downto 0));
END bmg_24_vx5_b3a285035a3712ee;

ARCHITECTURE bmg_24_vx5_b3a285035a3712ee_a OF bmg_24_vx5_b3a285035a3712ee IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_b3a285035a3712ee
	port (
	clka: IN std_logic;
	dina: IN std_logic_VECTOR(7 downto 0);
	addra: IN std_logic_VECTOR(9 downto 0);
	ena: IN std_logic;
	wea: IN std_logic_VECTOR(0 downto 0);
	douta: OUT std_logic_VECTOR(7 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_b3a285035a3712ee use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 0,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 8,
			c_family => "virtex5",
			c_read_width_a => 8,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_b3a285035a3712ee.mif",
			c_write_mode_a => "READ_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 1024,
			c_write_depth_a => 1024,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 10,
			c_addrb_width => 10,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 8,
			c_write_width_a => 8,
			c_read_depth_b => 1024,
			c_read_depth_a => 1024,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_b3a285035a3712ee
		port map (
			clka => clka,
			dina => dina,
			addra => addra,
			ena => ena,
			wea => wea,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_b3a285035a3712ee_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_b56a7cdaabc490ac.vhd when simulating
-- the core, bmg_24_vx5_b56a7cdaabc490ac. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_b56a7cdaabc490ac IS
	port (
	clka: IN std_logic;
	dina: IN std_logic_VECTOR(17 downto 0);
	addra: IN std_logic_VECTOR(7 downto 0);
	ena: IN std_logic;
	wea: IN std_logic_VECTOR(0 downto 0);
	douta: OUT std_logic_VECTOR(17 downto 0));
END bmg_24_vx5_b56a7cdaabc490ac;

ARCHITECTURE bmg_24_vx5_b56a7cdaabc490ac_a OF bmg_24_vx5_b56a7cdaabc490ac IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_b56a7cdaabc490ac
	port (
	clka: IN std_logic;
	dina: IN std_logic_VECTOR(17 downto 0);
	addra: IN std_logic_VECTOR(7 downto 0);
	ena: IN std_logic;
	wea: IN std_logic_VECTOR(0 downto 0);
	douta: OUT std_logic_VECTOR(17 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_b56a7cdaabc490ac use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 0,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 18,
			c_family => "virtex5",
			c_read_width_a => 18,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_b56a7cdaabc490ac.mif",
			c_write_mode_a => "READ_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 256,
			c_write_depth_a => 256,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 8,
			c_addrb_width => 8,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 18,
			c_write_width_a => 18,
			c_read_depth_b => 256,
			c_read_depth_a => 256,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_b56a7cdaabc490ac
		port map (
			clka => clka,
			dina => dina,
			addra => addra,
			ena => ena,
			wea => wea,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_b56a7cdaabc490ac_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_c5c136a08dd56dbc.vhd when simulating
-- the core, bmg_24_vx5_c5c136a08dd56dbc. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_c5c136a08dd56dbc IS
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(5 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(17 downto 0));
END bmg_24_vx5_c5c136a08dd56dbc;

ARCHITECTURE bmg_24_vx5_c5c136a08dd56dbc_a OF bmg_24_vx5_c5c136a08dd56dbc IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_c5c136a08dd56dbc
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(5 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(17 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_c5c136a08dd56dbc use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 3,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 18,
			c_family => "virtex5",
			c_read_width_a => 18,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_c5c136a08dd56dbc.mif",
			c_write_mode_a => "WRITE_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 64,
			c_write_depth_a => 64,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 6,
			c_addrb_width => 6,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 18,
			c_write_width_a => 18,
			c_read_depth_b => 64,
			c_read_depth_a => 64,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_c5c136a08dd56dbc
		port map (
			clka => clka,
			addra => addra,
			ena => ena,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_c5c136a08dd56dbc_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_cd3584ee10cade7e.vhd when simulating
-- the core, bmg_24_vx5_cd3584ee10cade7e. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_cd3584ee10cade7e IS
	port (
	clka: IN std_logic;
	dina: IN std_logic_VECTOR(18 downto 0);
	addra: IN std_logic_VECTOR(7 downto 0);
	ena: IN std_logic;
	wea: IN std_logic_VECTOR(0 downto 0);
	douta: OUT std_logic_VECTOR(18 downto 0));
END bmg_24_vx5_cd3584ee10cade7e;

ARCHITECTURE bmg_24_vx5_cd3584ee10cade7e_a OF bmg_24_vx5_cd3584ee10cade7e IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_cd3584ee10cade7e
	port (
	clka: IN std_logic;
	dina: IN std_logic_VECTOR(18 downto 0);
	addra: IN std_logic_VECTOR(7 downto 0);
	ena: IN std_logic;
	wea: IN std_logic_VECTOR(0 downto 0);
	douta: OUT std_logic_VECTOR(18 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_cd3584ee10cade7e use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 0,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 19,
			c_family => "virtex5",
			c_read_width_a => 19,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_cd3584ee10cade7e.mif",
			c_write_mode_a => "READ_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 256,
			c_write_depth_a => 256,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 8,
			c_addrb_width => 8,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 19,
			c_write_width_a => 19,
			c_read_depth_b => 256,
			c_read_depth_a => 256,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_cd3584ee10cade7e
		port map (
			clka => clka,
			dina => dina,
			addra => addra,
			ena => ena,
			wea => wea,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_cd3584ee10cade7e_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_cee1e5321fc14302.vhd when simulating
-- the core, bmg_24_vx5_cee1e5321fc14302. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_cee1e5321fc14302 IS
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(7 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(17 downto 0));
END bmg_24_vx5_cee1e5321fc14302;

ARCHITECTURE bmg_24_vx5_cee1e5321fc14302_a OF bmg_24_vx5_cee1e5321fc14302 IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_cee1e5321fc14302
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(7 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(17 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_cee1e5321fc14302 use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 3,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 18,
			c_family => "virtex5",
			c_read_width_a => 18,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_cee1e5321fc14302.mif",
			c_write_mode_a => "WRITE_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 256,
			c_write_depth_a => 256,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 8,
			c_addrb_width => 8,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 18,
			c_write_width_a => 18,
			c_read_depth_b => 256,
			c_read_depth_a => 256,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_cee1e5321fc14302
		port map (
			clka => clka,
			addra => addra,
			ena => ena,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_cee1e5321fc14302_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_24_vx5_e356d8b9149f54d5.vhd when simulating
-- the core, bmg_24_vx5_e356d8b9149f54d5. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_24_vx5_e356d8b9149f54d5 IS
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(5 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(17 downto 0));
END bmg_24_vx5_e356d8b9149f54d5;

ARCHITECTURE bmg_24_vx5_e356d8b9149f54d5_a OF bmg_24_vx5_e356d8b9149f54d5 IS
-- synthesis translate_off
component wrapped_bmg_24_vx5_e356d8b9149f54d5
	port (
	clka: IN std_logic;
	addra: IN std_logic_VECTOR(5 downto 0);
	ena: IN std_logic;
	douta: OUT std_logic_VECTOR(17 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_bmg_24_vx5_e356d8b9149f54d5 use entity XilinxCoreLib.blk_mem_gen_v2_4(behavioral)
		generic map(
			c_has_regceb => 0,
			c_has_regcea => 0,
			c_mem_type => 3,
			c_has_mux_output_regs => 0,
			c_prim_type => 1,
			c_sinita_val => "0",
			c_read_width_b => 18,
			c_family => "virtex5",
			c_read_width_a => 18,
			c_disable_warn_bhv_coll => 0,
			c_write_mode_b => "WRITE_FIRST",
			c_init_file_name => "bmg_24_vx5_e356d8b9149f54d5.mif",
			c_write_mode_a => "WRITE_FIRST",
			c_load_init_file => 1,
			c_xdevicefamily => "virtex5",
			c_write_depth_b => 64,
			c_write_depth_a => 64,
			c_has_ssrb => 0,
			c_has_ssra => 0,
			c_addra_width => 6,
			c_addrb_width => 6,
			c_default_data => "0",
			c_use_ecc => 0,
			c_algorithm => 1,
			c_disable_warn_bhv_range => 0,
			c_has_mem_output_regs => 0,
			c_write_width_b => 18,
			c_write_width_a => 18,
			c_read_depth_b => 64,
			c_read_depth_a => 64,
			c_byte_size => 9,
			c_sim_collision_check => "ALL",
			c_use_ramb16bwer_rst_bhv => 0,
			c_common_clk => 0,
			c_wea_width => 1,
			c_has_enb => 0,
			c_web_width => 1,
			c_has_ena => 1,
			c_sinitb_val => "0",
			c_use_byte_web => 0,
			c_use_byte_wea => 0,
			c_use_default_data => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_24_vx5_e356d8b9149f54d5
		port map (
			clka => clka,
			addra => addra,
			ena => ena,
			douta => douta);
-- synthesis translate_on

END bmg_24_vx5_e356d8b9149f54d5_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file dmg_33_vx5_27954da46fb8f5d8.vhd when simulating
-- the core, dmg_33_vx5_27954da46fb8f5d8. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY dmg_33_vx5_27954da46fb8f5d8 IS
	port (
	a: IN std_logic_VECTOR(3 downto 0);
	clk: IN std_logic;
	qspo_ce: IN std_logic;
	qspo: OUT std_logic_VECTOR(17 downto 0));
END dmg_33_vx5_27954da46fb8f5d8;

ARCHITECTURE dmg_33_vx5_27954da46fb8f5d8_a OF dmg_33_vx5_27954da46fb8f5d8 IS
-- synthesis translate_off
component wrapped_dmg_33_vx5_27954da46fb8f5d8
	port (
	a: IN std_logic_VECTOR(3 downto 0);
	clk: IN std_logic;
	qspo_ce: IN std_logic;
	qspo: OUT std_logic_VECTOR(17 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_dmg_33_vx5_27954da46fb8f5d8 use entity XilinxCoreLib.dist_mem_gen_v3_3(behavioral)
		generic map(
			c_has_clk => 1,
			c_has_qdpo_clk => 0,
			c_has_qdpo_ce => 0,
			c_has_d => 0,
			c_has_spo => 0,
			c_read_mif => 1,
			c_has_qspo => 1,
			c_width => 18,
			c_reg_a_d_inputs => 0,
			c_has_we => 0,
			c_pipeline_stages => 0,
			c_has_qdpo_rst => 0,
			c_reg_dpra_input => 0,
			c_qualify_we => 0,
			c_sync_enable => 1,
			c_depth => 16,
			c_has_qspo_srst => 0,
			c_has_qdpo_srst => 0,
			c_has_dpra => 0,
			c_qce_joined => 0,
			c_mem_type => 0,
			c_has_i_ce => 0,
			c_has_dpo => 0,
			c_mem_init_file => "dmg_33_vx5_27954da46fb8f5d8.mif",
			c_default_data => "0",
			c_has_spra => 0,
			c_has_qspo_ce => 1,
			c_addr_width => 4,
			c_has_qdpo => 0,
			c_has_qspo_rst => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_dmg_33_vx5_27954da46fb8f5d8
		port map (
			a => a,
			clk => clk,
			qspo_ce => qspo_ce,
			qspo => qspo);
-- synthesis translate_on

END dmg_33_vx5_27954da46fb8f5d8_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file dmg_33_vx5_3b5827b9b9c34c2c.vhd when simulating
-- the core, dmg_33_vx5_3b5827b9b9c34c2c. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY dmg_33_vx5_3b5827b9b9c34c2c IS
	port (
	a: IN std_logic_VECTOR(3 downto 0);
	clk: IN std_logic;
	qspo_ce: IN std_logic;
	qspo: OUT std_logic_VECTOR(17 downto 0));
END dmg_33_vx5_3b5827b9b9c34c2c;

ARCHITECTURE dmg_33_vx5_3b5827b9b9c34c2c_a OF dmg_33_vx5_3b5827b9b9c34c2c IS
-- synthesis translate_off
component wrapped_dmg_33_vx5_3b5827b9b9c34c2c
	port (
	a: IN std_logic_VECTOR(3 downto 0);
	clk: IN std_logic;
	qspo_ce: IN std_logic;
	qspo: OUT std_logic_VECTOR(17 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_dmg_33_vx5_3b5827b9b9c34c2c use entity XilinxCoreLib.dist_mem_gen_v3_3(behavioral)
		generic map(
			c_has_clk => 1,
			c_has_qdpo_clk => 0,
			c_has_qdpo_ce => 0,
			c_has_d => 0,
			c_has_spo => 0,
			c_read_mif => 1,
			c_has_qspo => 1,
			c_width => 18,
			c_reg_a_d_inputs => 0,
			c_has_we => 0,
			c_pipeline_stages => 0,
			c_has_qdpo_rst => 0,
			c_reg_dpra_input => 0,
			c_qualify_we => 0,
			c_sync_enable => 1,
			c_depth => 16,
			c_has_qspo_srst => 0,
			c_has_qdpo_srst => 0,
			c_has_dpra => 0,
			c_qce_joined => 0,
			c_mem_type => 0,
			c_has_i_ce => 0,
			c_has_dpo => 0,
			c_mem_init_file => "dmg_33_vx5_3b5827b9b9c34c2c.mif",
			c_default_data => "0",
			c_has_spra => 0,
			c_has_qspo_ce => 1,
			c_addr_width => 4,
			c_has_qdpo => 0,
			c_has_qspo_rst => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_dmg_33_vx5_3b5827b9b9c34c2c
		port map (
			a => a,
			clk => clk,
			qspo_ce => qspo_ce,
			qspo => qspo);
-- synthesis translate_on

END dmg_33_vx5_3b5827b9b9c34c2c_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file dmg_33_vx5_47bf930170fd8e60.vhd when simulating
-- the core, dmg_33_vx5_47bf930170fd8e60. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY dmg_33_vx5_47bf930170fd8e60 IS
	port (
	a: IN std_logic_VECTOR(3 downto 0);
	clk: IN std_logic;
	qspo_ce: IN std_logic;
	qspo: OUT std_logic_VECTOR(17 downto 0));
END dmg_33_vx5_47bf930170fd8e60;

ARCHITECTURE dmg_33_vx5_47bf930170fd8e60_a OF dmg_33_vx5_47bf930170fd8e60 IS
-- synthesis translate_off
component wrapped_dmg_33_vx5_47bf930170fd8e60
	port (
	a: IN std_logic_VECTOR(3 downto 0);
	clk: IN std_logic;
	qspo_ce: IN std_logic;
	qspo: OUT std_logic_VECTOR(17 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_dmg_33_vx5_47bf930170fd8e60 use entity XilinxCoreLib.dist_mem_gen_v3_3(behavioral)
		generic map(
			c_has_clk => 1,
			c_has_qdpo_clk => 0,
			c_has_qdpo_ce => 0,
			c_has_d => 0,
			c_has_spo => 0,
			c_read_mif => 1,
			c_has_qspo => 1,
			c_width => 18,
			c_reg_a_d_inputs => 0,
			c_has_we => 0,
			c_pipeline_stages => 0,
			c_has_qdpo_rst => 0,
			c_reg_dpra_input => 0,
			c_qualify_we => 0,
			c_sync_enable => 1,
			c_depth => 16,
			c_has_qspo_srst => 0,
			c_has_qdpo_srst => 0,
			c_has_dpra => 0,
			c_qce_joined => 0,
			c_mem_type => 0,
			c_has_i_ce => 0,
			c_has_dpo => 0,
			c_mem_init_file => "dmg_33_vx5_47bf930170fd8e60.mif",
			c_default_data => "0",
			c_has_spra => 0,
			c_has_qspo_ce => 1,
			c_addr_width => 4,
			c_has_qdpo => 0,
			c_has_qspo_rst => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_dmg_33_vx5_47bf930170fd8e60
		port map (
			a => a,
			clk => clk,
			qspo_ce => qspo_ce,
			qspo => qspo);
-- synthesis translate_on

END dmg_33_vx5_47bf930170fd8e60_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file dmg_33_vx5_6ab87bec3a8932d3.vhd when simulating
-- the core, dmg_33_vx5_6ab87bec3a8932d3. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY dmg_33_vx5_6ab87bec3a8932d3 IS
	port (
	a: IN std_logic_VECTOR(3 downto 0);
	clk: IN std_logic;
	qspo_ce: IN std_logic;
	qspo: OUT std_logic_VECTOR(17 downto 0));
END dmg_33_vx5_6ab87bec3a8932d3;

ARCHITECTURE dmg_33_vx5_6ab87bec3a8932d3_a OF dmg_33_vx5_6ab87bec3a8932d3 IS
-- synthesis translate_off
component wrapped_dmg_33_vx5_6ab87bec3a8932d3
	port (
	a: IN std_logic_VECTOR(3 downto 0);
	clk: IN std_logic;
	qspo_ce: IN std_logic;
	qspo: OUT std_logic_VECTOR(17 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_dmg_33_vx5_6ab87bec3a8932d3 use entity XilinxCoreLib.dist_mem_gen_v3_3(behavioral)
		generic map(
			c_has_clk => 1,
			c_has_qdpo_clk => 0,
			c_has_qdpo_ce => 0,
			c_has_d => 0,
			c_has_spo => 0,
			c_read_mif => 1,
			c_has_qspo => 1,
			c_width => 18,
			c_reg_a_d_inputs => 0,
			c_has_we => 0,
			c_pipeline_stages => 0,
			c_has_qdpo_rst => 0,
			c_reg_dpra_input => 0,
			c_qualify_we => 0,
			c_sync_enable => 1,
			c_depth => 16,
			c_has_qspo_srst => 0,
			c_has_qdpo_srst => 0,
			c_has_dpra => 0,
			c_qce_joined => 0,
			c_mem_type => 0,
			c_has_i_ce => 0,
			c_has_dpo => 0,
			c_mem_init_file => "dmg_33_vx5_6ab87bec3a8932d3.mif",
			c_default_data => "0",
			c_has_spra => 0,
			c_has_qspo_ce => 1,
			c_addr_width => 4,
			c_has_qdpo => 0,
			c_has_qspo_rst => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_dmg_33_vx5_6ab87bec3a8932d3
		port map (
			a => a,
			clk => clk,
			qspo_ce => qspo_ce,
			qspo => qspo);
-- synthesis translate_on

END dmg_33_vx5_6ab87bec3a8932d3_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file dmg_33_vx5_af86f8a7a0de7d76.vhd when simulating
-- the core, dmg_33_vx5_af86f8a7a0de7d76. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY dmg_33_vx5_af86f8a7a0de7d76 IS
	port (
	a: IN std_logic_VECTOR(3 downto 0);
	clk: IN std_logic;
	qspo_ce: IN std_logic;
	qspo: OUT std_logic_VECTOR(17 downto 0));
END dmg_33_vx5_af86f8a7a0de7d76;

ARCHITECTURE dmg_33_vx5_af86f8a7a0de7d76_a OF dmg_33_vx5_af86f8a7a0de7d76 IS
-- synthesis translate_off
component wrapped_dmg_33_vx5_af86f8a7a0de7d76
	port (
	a: IN std_logic_VECTOR(3 downto 0);
	clk: IN std_logic;
	qspo_ce: IN std_logic;
	qspo: OUT std_logic_VECTOR(17 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_dmg_33_vx5_af86f8a7a0de7d76 use entity XilinxCoreLib.dist_mem_gen_v3_3(behavioral)
		generic map(
			c_has_clk => 1,
			c_has_qdpo_clk => 0,
			c_has_qdpo_ce => 0,
			c_has_d => 0,
			c_has_spo => 0,
			c_read_mif => 1,
			c_has_qspo => 1,
			c_width => 18,
			c_reg_a_d_inputs => 0,
			c_has_we => 0,
			c_pipeline_stages => 0,
			c_has_qdpo_rst => 0,
			c_reg_dpra_input => 0,
			c_qualify_we => 0,
			c_sync_enable => 1,
			c_depth => 16,
			c_has_qspo_srst => 0,
			c_has_qdpo_srst => 0,
			c_has_dpra => 0,
			c_qce_joined => 0,
			c_mem_type => 0,
			c_has_i_ce => 0,
			c_has_dpo => 0,
			c_mem_init_file => "dmg_33_vx5_af86f8a7a0de7d76.mif",
			c_default_data => "0",
			c_has_spra => 0,
			c_has_qspo_ce => 1,
			c_addr_width => 4,
			c_has_qdpo => 0,
			c_has_qspo_rst => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_dmg_33_vx5_af86f8a7a0de7d76
		port map (
			a => a,
			clk => clk,
			qspo_ce => qspo_ce,
			qspo => qspo);
-- synthesis translate_on

END dmg_33_vx5_af86f8a7a0de7d76_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file dmg_33_vx5_efe4f2e28a6a56b5.vhd when simulating
-- the core, dmg_33_vx5_efe4f2e28a6a56b5. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY dmg_33_vx5_efe4f2e28a6a56b5 IS
	port (
	a: IN std_logic_VECTOR(3 downto 0);
	clk: IN std_logic;
	qspo_ce: IN std_logic;
	qspo: OUT std_logic_VECTOR(17 downto 0));
END dmg_33_vx5_efe4f2e28a6a56b5;

ARCHITECTURE dmg_33_vx5_efe4f2e28a6a56b5_a OF dmg_33_vx5_efe4f2e28a6a56b5 IS
-- synthesis translate_off
component wrapped_dmg_33_vx5_efe4f2e28a6a56b5
	port (
	a: IN std_logic_VECTOR(3 downto 0);
	clk: IN std_logic;
	qspo_ce: IN std_logic;
	qspo: OUT std_logic_VECTOR(17 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_dmg_33_vx5_efe4f2e28a6a56b5 use entity XilinxCoreLib.dist_mem_gen_v3_3(behavioral)
		generic map(
			c_has_clk => 1,
			c_has_qdpo_clk => 0,
			c_has_qdpo_ce => 0,
			c_has_d => 0,
			c_has_spo => 0,
			c_read_mif => 1,
			c_has_qspo => 1,
			c_width => 18,
			c_reg_a_d_inputs => 0,
			c_has_we => 0,
			c_pipeline_stages => 0,
			c_has_qdpo_rst => 0,
			c_reg_dpra_input => 0,
			c_qualify_we => 0,
			c_sync_enable => 1,
			c_depth => 16,
			c_has_qspo_srst => 0,
			c_has_qdpo_srst => 0,
			c_has_dpra => 0,
			c_qce_joined => 0,
			c_mem_type => 0,
			c_has_i_ce => 0,
			c_has_dpo => 0,
			c_mem_init_file => "dmg_33_vx5_efe4f2e28a6a56b5.mif",
			c_default_data => "0",
			c_has_spra => 0,
			c_has_qspo_ce => 1,
			c_addr_width => 4,
			c_has_qdpo => 0,
			c_has_qspo_rst => 0);
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_dmg_33_vx5_efe4f2e28a6a56b5
		port map (
			a => a,
			clk => clk,
			qspo_ce => qspo_ce,
			qspo => qspo);
-- synthesis translate_on

END dmg_33_vx5_efe4f2e28a6a56b5_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file multiplier_virtex5_10_1_2f77ace24e40581e.vhd when simulating
-- the core, multiplier_virtex5_10_1_2f77ace24e40581e. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY multiplier_virtex5_10_1_2f77ace24e40581e IS
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(7 downto 0);
	b: IN std_logic_VECTOR(8 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(16 downto 0));
END multiplier_virtex5_10_1_2f77ace24e40581e;

ARCHITECTURE multiplier_virtex5_10_1_2f77ace24e40581e_a OF multiplier_virtex5_10_1_2f77ace24e40581e IS
-- synthesis translate_off
component wrapped_multiplier_virtex5_10_1_2f77ace24e40581e
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(7 downto 0);
	b: IN std_logic_VECTOR(8 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(16 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_multiplier_virtex5_10_1_2f77ace24e40581e use entity XilinxCoreLib.mult_gen_v10_1(behavioral)
		generic map(
			c_a_width => 8,
			c_b_type => 0,
			c_ce_overrides_sclr => 1,
			c_has_sclr => 1,
			c_round_pt => 0,
			c_model_type => 0,
			c_out_high => 16,
			c_verbosity => 0,
			c_mult_type => 1,
			c_ccm_imp => 0,
			c_latency => 3,
			c_has_ce => 1,
			c_has_zero_detect => 0,
			c_round_output => 0,
			c_optimize_goal => 1,
			c_xdevicefamily => "virtex5",
			c_a_type => 0,
			c_out_low => 0,
			c_b_width => 9,
			c_b_value => "10000001");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_multiplier_virtex5_10_1_2f77ace24e40581e
		port map (
			clk => clk,
			a => a,
			b => b,
			ce => ce,
			sclr => sclr,
			p => p);
-- synthesis translate_on

END multiplier_virtex5_10_1_2f77ace24e40581e_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file multiplier_virtex5_10_1_34b4d3fe22ca9845.vhd when simulating
-- the core, multiplier_virtex5_10_1_34b4d3fe22ca9845. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY multiplier_virtex5_10_1_34b4d3fe22ca9845 IS
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(17 downto 0);
	b: IN std_logic_VECTOR(9 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(27 downto 0));
END multiplier_virtex5_10_1_34b4d3fe22ca9845;

ARCHITECTURE multiplier_virtex5_10_1_34b4d3fe22ca9845_a OF multiplier_virtex5_10_1_34b4d3fe22ca9845 IS
-- synthesis translate_off
component wrapped_multiplier_virtex5_10_1_34b4d3fe22ca9845
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(17 downto 0);
	b: IN std_logic_VECTOR(9 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(27 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_multiplier_virtex5_10_1_34b4d3fe22ca9845 use entity XilinxCoreLib.mult_gen_v10_1(behavioral)
		generic map(
			c_a_width => 18,
			c_b_type => 0,
			c_ce_overrides_sclr => 1,
			c_has_sclr => 1,
			c_round_pt => 0,
			c_model_type => 0,
			c_out_high => 27,
			c_verbosity => 0,
			c_mult_type => 1,
			c_ccm_imp => 0,
			c_latency => 3,
			c_has_ce => 1,
			c_has_zero_detect => 0,
			c_round_output => 0,
			c_optimize_goal => 1,
			c_xdevicefamily => "virtex5",
			c_a_type => 0,
			c_out_low => 0,
			c_b_width => 10,
			c_b_value => "10000001");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_multiplier_virtex5_10_1_34b4d3fe22ca9845
		port map (
			clk => clk,
			a => a,
			b => b,
			ce => ce,
			sclr => sclr,
			p => p);
-- synthesis translate_on

END multiplier_virtex5_10_1_34b4d3fe22ca9845_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file multiplier_virtex5_10_1_35568d5aa6a70475.vhd when simulating
-- the core, multiplier_virtex5_10_1_35568d5aa6a70475. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY multiplier_virtex5_10_1_35568d5aa6a70475 IS
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(13 downto 0);
	b: IN std_logic_VECTOR(9 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(23 downto 0));
END multiplier_virtex5_10_1_35568d5aa6a70475;

ARCHITECTURE multiplier_virtex5_10_1_35568d5aa6a70475_a OF multiplier_virtex5_10_1_35568d5aa6a70475 IS
-- synthesis translate_off
component wrapped_multiplier_virtex5_10_1_35568d5aa6a70475
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(13 downto 0);
	b: IN std_logic_VECTOR(9 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(23 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_multiplier_virtex5_10_1_35568d5aa6a70475 use entity XilinxCoreLib.mult_gen_v10_1(behavioral)
		generic map(
			c_a_width => 14,
			c_b_type => 0,
			c_ce_overrides_sclr => 1,
			c_has_sclr => 1,
			c_round_pt => 0,
			c_model_type => 0,
			c_out_high => 23,
			c_verbosity => 0,
			c_mult_type => 1,
			c_ccm_imp => 0,
			c_latency => 3,
			c_has_ce => 1,
			c_has_zero_detect => 0,
			c_round_output => 0,
			c_optimize_goal => 1,
			c_xdevicefamily => "virtex5",
			c_a_type => 0,
			c_out_low => 0,
			c_b_width => 10,
			c_b_value => "10000001");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_multiplier_virtex5_10_1_35568d5aa6a70475
		port map (
			clk => clk,
			a => a,
			b => b,
			ce => ce,
			sclr => sclr,
			p => p);
-- synthesis translate_on

END multiplier_virtex5_10_1_35568d5aa6a70475_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file multiplier_virtex5_10_1_36b8f4cb731cc5b3.vhd when simulating
-- the core, multiplier_virtex5_10_1_36b8f4cb731cc5b3. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY multiplier_virtex5_10_1_36b8f4cb731cc5b3 IS
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(18 downto 0);
	b: IN std_logic_VECTOR(18 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(37 downto 0));
END multiplier_virtex5_10_1_36b8f4cb731cc5b3;

ARCHITECTURE multiplier_virtex5_10_1_36b8f4cb731cc5b3_a OF multiplier_virtex5_10_1_36b8f4cb731cc5b3 IS
-- synthesis translate_off
component wrapped_multiplier_virtex5_10_1_36b8f4cb731cc5b3
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(18 downto 0);
	b: IN std_logic_VECTOR(18 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(37 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_multiplier_virtex5_10_1_36b8f4cb731cc5b3 use entity XilinxCoreLib.mult_gen_v10_1(behavioral)
		generic map(
			c_a_width => 19,
			c_b_type => 0,
			c_ce_overrides_sclr => 1,
			c_has_sclr => 1,
			c_round_pt => 0,
			c_model_type => 0,
			c_out_high => 37,
			c_verbosity => 0,
			c_mult_type => 1,
			c_ccm_imp => 0,
			c_latency => 4,
			c_has_ce => 1,
			c_has_zero_detect => 0,
			c_round_output => 0,
			c_optimize_goal => 1,
			c_xdevicefamily => "virtex5",
			c_a_type => 0,
			c_out_low => 0,
			c_b_width => 19,
			c_b_value => "10000001");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_multiplier_virtex5_10_1_36b8f4cb731cc5b3
		port map (
			clk => clk,
			a => a,
			b => b,
			ce => ce,
			sclr => sclr,
			p => p);
-- synthesis translate_on

END multiplier_virtex5_10_1_36b8f4cb731cc5b3_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file multiplier_virtex5_10_1_845caa9bc89072e0.vhd when simulating
-- the core, multiplier_virtex5_10_1_845caa9bc89072e0. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY multiplier_virtex5_10_1_845caa9bc89072e0 IS
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(12 downto 0);
	b: IN std_logic_VECTOR(8 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(21 downto 0));
END multiplier_virtex5_10_1_845caa9bc89072e0;

ARCHITECTURE multiplier_virtex5_10_1_845caa9bc89072e0_a OF multiplier_virtex5_10_1_845caa9bc89072e0 IS
-- synthesis translate_off
component wrapped_multiplier_virtex5_10_1_845caa9bc89072e0
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(12 downto 0);
	b: IN std_logic_VECTOR(8 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(21 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_multiplier_virtex5_10_1_845caa9bc89072e0 use entity XilinxCoreLib.mult_gen_v10_1(behavioral)
		generic map(
			c_a_width => 13,
			c_b_type => 0,
			c_ce_overrides_sclr => 1,
			c_has_sclr => 1,
			c_round_pt => 0,
			c_model_type => 0,
			c_out_high => 21,
			c_verbosity => 0,
			c_mult_type => 1,
			c_ccm_imp => 0,
			c_latency => 3,
			c_has_ce => 1,
			c_has_zero_detect => 0,
			c_round_output => 0,
			c_optimize_goal => 1,
			c_xdevicefamily => "virtex5",
			c_a_type => 0,
			c_out_low => 0,
			c_b_width => 9,
			c_b_value => "10000001");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_multiplier_virtex5_10_1_845caa9bc89072e0
		port map (
			clk => clk,
			a => a,
			b => b,
			ce => ce,
			sclr => sclr,
			p => p);
-- synthesis translate_on

END multiplier_virtex5_10_1_845caa9bc89072e0_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file multiplier_virtex5_10_1_9a2572cfdd818f42.vhd when simulating
-- the core, multiplier_virtex5_10_1_9a2572cfdd818f42. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY multiplier_virtex5_10_1_9a2572cfdd818f42 IS
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(14 downto 0);
	b: IN std_logic_VECTOR(8 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(23 downto 0));
END multiplier_virtex5_10_1_9a2572cfdd818f42;

ARCHITECTURE multiplier_virtex5_10_1_9a2572cfdd818f42_a OF multiplier_virtex5_10_1_9a2572cfdd818f42 IS
-- synthesis translate_off
component wrapped_multiplier_virtex5_10_1_9a2572cfdd818f42
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(14 downto 0);
	b: IN std_logic_VECTOR(8 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(23 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_multiplier_virtex5_10_1_9a2572cfdd818f42 use entity XilinxCoreLib.mult_gen_v10_1(behavioral)
		generic map(
			c_a_width => 15,
			c_b_type => 0,
			c_ce_overrides_sclr => 1,
			c_has_sclr => 1,
			c_round_pt => 0,
			c_model_type => 0,
			c_out_high => 23,
			c_verbosity => 0,
			c_mult_type => 1,
			c_ccm_imp => 0,
			c_latency => 3,
			c_has_ce => 1,
			c_has_zero_detect => 0,
			c_round_output => 0,
			c_optimize_goal => 1,
			c_xdevicefamily => "virtex5",
			c_a_type => 0,
			c_out_low => 0,
			c_b_width => 9,
			c_b_value => "10000001");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_multiplier_virtex5_10_1_9a2572cfdd818f42
		port map (
			clk => clk,
			a => a,
			b => b,
			ce => ce,
			sclr => sclr,
			p => p);
-- synthesis translate_on

END multiplier_virtex5_10_1_9a2572cfdd818f42_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file multiplier_virtex5_10_1_b0c844385805a270.vhd when simulating
-- the core, multiplier_virtex5_10_1_b0c844385805a270. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY multiplier_virtex5_10_1_b0c844385805a270 IS
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(10 downto 0);
	b: IN std_logic_VECTOR(8 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(19 downto 0));
END multiplier_virtex5_10_1_b0c844385805a270;

ARCHITECTURE multiplier_virtex5_10_1_b0c844385805a270_a OF multiplier_virtex5_10_1_b0c844385805a270 IS
-- synthesis translate_off
component wrapped_multiplier_virtex5_10_1_b0c844385805a270
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(10 downto 0);
	b: IN std_logic_VECTOR(8 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(19 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_multiplier_virtex5_10_1_b0c844385805a270 use entity XilinxCoreLib.mult_gen_v10_1(behavioral)
		generic map(
			c_a_width => 11,
			c_b_type => 0,
			c_ce_overrides_sclr => 1,
			c_has_sclr => 1,
			c_round_pt => 0,
			c_model_type => 0,
			c_out_high => 19,
			c_verbosity => 0,
			c_mult_type => 1,
			c_ccm_imp => 0,
			c_latency => 3,
			c_has_ce => 1,
			c_has_zero_detect => 0,
			c_round_output => 0,
			c_optimize_goal => 1,
			c_xdevicefamily => "virtex5",
			c_a_type => 0,
			c_out_low => 0,
			c_b_width => 9,
			c_b_value => "10000001");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_multiplier_virtex5_10_1_b0c844385805a270
		port map (
			clk => clk,
			a => a,
			b => b,
			ce => ce,
			sclr => sclr,
			p => p);
-- synthesis translate_on

END multiplier_virtex5_10_1_b0c844385805a270_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file multiplier_virtex5_10_1_c90585d1a7e9d3a6.vhd when simulating
-- the core, multiplier_virtex5_10_1_c90585d1a7e9d3a6. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY multiplier_virtex5_10_1_c90585d1a7e9d3a6 IS
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(11 downto 0);
	b: IN std_logic_VECTOR(9 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(21 downto 0));
END multiplier_virtex5_10_1_c90585d1a7e9d3a6;

ARCHITECTURE multiplier_virtex5_10_1_c90585d1a7e9d3a6_a OF multiplier_virtex5_10_1_c90585d1a7e9d3a6 IS
-- synthesis translate_off
component wrapped_multiplier_virtex5_10_1_c90585d1a7e9d3a6
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(11 downto 0);
	b: IN std_logic_VECTOR(9 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(21 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_multiplier_virtex5_10_1_c90585d1a7e9d3a6 use entity XilinxCoreLib.mult_gen_v10_1(behavioral)
		generic map(
			c_a_width => 12,
			c_b_type => 0,
			c_ce_overrides_sclr => 1,
			c_has_sclr => 1,
			c_round_pt => 0,
			c_model_type => 0,
			c_out_high => 21,
			c_verbosity => 0,
			c_mult_type => 1,
			c_ccm_imp => 0,
			c_latency => 3,
			c_has_ce => 1,
			c_has_zero_detect => 0,
			c_round_output => 0,
			c_optimize_goal => 1,
			c_xdevicefamily => "virtex5",
			c_a_type => 0,
			c_out_low => 0,
			c_b_width => 10,
			c_b_value => "10000001");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_multiplier_virtex5_10_1_c90585d1a7e9d3a6
		port map (
			clk => clk,
			a => a,
			b => b,
			ce => ce,
			sclr => sclr,
			p => p);
-- synthesis translate_on

END multiplier_virtex5_10_1_c90585d1a7e9d3a6_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file multiplier_virtex5_10_1_db7246963acedc92.vhd when simulating
-- the core, multiplier_virtex5_10_1_db7246963acedc92. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY multiplier_virtex5_10_1_db7246963acedc92 IS
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(16 downto 0);
	b: IN std_logic_VECTOR(8 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(25 downto 0));
END multiplier_virtex5_10_1_db7246963acedc92;

ARCHITECTURE multiplier_virtex5_10_1_db7246963acedc92_a OF multiplier_virtex5_10_1_db7246963acedc92 IS
-- synthesis translate_off
component wrapped_multiplier_virtex5_10_1_db7246963acedc92
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(16 downto 0);
	b: IN std_logic_VECTOR(8 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(25 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_multiplier_virtex5_10_1_db7246963acedc92 use entity XilinxCoreLib.mult_gen_v10_1(behavioral)
		generic map(
			c_a_width => 17,
			c_b_type => 0,
			c_ce_overrides_sclr => 1,
			c_has_sclr => 1,
			c_round_pt => 0,
			c_model_type => 0,
			c_out_high => 25,
			c_verbosity => 0,
			c_mult_type => 1,
			c_ccm_imp => 0,
			c_latency => 3,
			c_has_ce => 1,
			c_has_zero_detect => 0,
			c_round_output => 0,
			c_optimize_goal => 1,
			c_xdevicefamily => "virtex5",
			c_a_type => 0,
			c_out_low => 0,
			c_b_width => 9,
			c_b_value => "10000001");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_multiplier_virtex5_10_1_db7246963acedc92
		port map (
			clk => clk,
			a => a,
			b => b,
			ce => ce,
			sclr => sclr,
			p => p);
-- synthesis translate_on

END multiplier_virtex5_10_1_db7246963acedc92_a;

--------------------------------------------------------------------------------
--     This file is owned and controlled by Xilinx and must be used           --
--     solely for design, simulation, implementation and creation of          --
--     design files limited to Xilinx devices or technologies. Use            --
--     with non-Xilinx devices or technologies is expressly prohibited        --
--     and immediately terminates your license.                               --
--                                                                            --
--     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"          --
--     SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR                --
--     XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION        --
--     AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION            --
--     OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS              --
--     IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,                --
--     AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE       --
--     FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY               --
--     WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE                --
--     IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR         --
--     REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF        --
--     INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS        --
--     FOR A PARTICULAR PURPOSE.                                              --
--                                                                            --
--     Xilinx products are not intended for use in life support               --
--     appliances, devices, or systems. Use in such applications are          --
--     expressly prohibited.                                                  --
--                                                                            --
--     (c) Copyright 1995-2007 Xilinx, Inc.                                   --
--     All rights reserved.                                                   --
--------------------------------------------------------------------------------
-- You must compile the wrapper file multiplier_virtex5_10_1_e96fd0f2d7a7d0c5.vhd when simulating
-- the core, multiplier_virtex5_10_1_e96fd0f2d7a7d0c5. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
Library XilinxCoreLib;
-- synthesis translate_on
ENTITY multiplier_virtex5_10_1_e96fd0f2d7a7d0c5 IS
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(15 downto 0);
	b: IN std_logic_VECTOR(9 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(25 downto 0));
END multiplier_virtex5_10_1_e96fd0f2d7a7d0c5;

ARCHITECTURE multiplier_virtex5_10_1_e96fd0f2d7a7d0c5_a OF multiplier_virtex5_10_1_e96fd0f2d7a7d0c5 IS
-- synthesis translate_off
component wrapped_multiplier_virtex5_10_1_e96fd0f2d7a7d0c5
	port (
	clk: IN std_logic;
	a: IN std_logic_VECTOR(15 downto 0);
	b: IN std_logic_VECTOR(9 downto 0);
	ce: IN std_logic;
	sclr: IN std_logic;
	p: OUT std_logic_VECTOR(25 downto 0));
end component;

-- Configuration specification 
	for all : wrapped_multiplier_virtex5_10_1_e96fd0f2d7a7d0c5 use entity XilinxCoreLib.mult_gen_v10_1(behavioral)
		generic map(
			c_a_width => 16,
			c_b_type => 0,
			c_ce_overrides_sclr => 1,
			c_has_sclr => 1,
			c_round_pt => 0,
			c_model_type => 0,
			c_out_high => 25,
			c_verbosity => 0,
			c_mult_type => 1,
			c_ccm_imp => 0,
			c_latency => 3,
			c_has_ce => 1,
			c_has_zero_detect => 0,
			c_round_output => 0,
			c_optimize_goal => 1,
			c_xdevicefamily => "virtex5",
			c_a_type => 0,
			c_out_low => 0,
			c_b_width => 10,
			c_b_value => "10000001");
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_multiplier_virtex5_10_1_e96fd0f2d7a7d0c5
		port map (
			clk => clk,
			a => a,
			b => b,
			ce => ce,
			sclr => sclr,
			p => p);
-- synthesis translate_on

END multiplier_virtex5_10_1_e96fd0f2d7a7d0c5_a;


-------------------------------------------------------------------
-- System Generator version 10.1.3 VHDL source file.
--
-- Copyright(C) 2008 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2008 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
package conv_pkg is
    constant simulating : boolean := false
      -- synopsys translate_off
        or true
      -- synopsys translate_on
    ;
    constant xlUnsigned : integer := 1;
    constant xlSigned : integer := 2;
    constant xlWrap : integer := 1;
    constant xlSaturate : integer := 2;
    constant xlTruncate : integer := 1;
    constant xlRound : integer := 2;
    constant xlRoundBanker : integer := 3;
    constant xlAddMode : integer := 1;
    constant xlSubMode : integer := 2;
    attribute black_box : boolean;
    attribute syn_black_box : boolean;
    attribute fpga_dont_touch: string;
    attribute box_type :  string;
    attribute keep : string;
    attribute syn_keep : boolean;
    function std_logic_vector_to_unsigned(inp : std_logic_vector) return unsigned;
    function unsigned_to_std_logic_vector(inp : unsigned) return std_logic_vector;
    function std_logic_vector_to_signed(inp : std_logic_vector) return signed;
    function signed_to_std_logic_vector(inp : signed) return std_logic_vector;
    function unsigned_to_signed(inp : unsigned) return signed;
    function signed_to_unsigned(inp : signed) return unsigned;
    function pos(inp : std_logic_vector; arith : INTEGER) return boolean;
    function all_same(inp: std_logic_vector) return boolean;
    function all_zeros(inp: std_logic_vector) return boolean;
    function is_point_five(inp: std_logic_vector) return boolean;
    function all_ones(inp: std_logic_vector) return boolean;
    function convert_type (inp : std_logic_vector; old_width, old_bin_pt,
                           old_arith, new_width, new_bin_pt, new_arith,
                           quantization, overflow : INTEGER)
        return std_logic_vector;
    function cast (inp : std_logic_vector; old_bin_pt,
                   new_width, new_bin_pt, new_arith : INTEGER)
        return std_logic_vector;
    function vec_slice (inp : std_logic_vector; upper, lower : INTEGER)
        return std_logic_vector;
    function s2u_slice (inp : signed; upper, lower : INTEGER)
        return unsigned;
    function u2u_slice (inp : unsigned; upper, lower : INTEGER)
        return unsigned;
    function s2s_cast (inp : signed; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return signed;
    function u2s_cast (inp : unsigned; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return signed;
    function s2u_cast (inp : signed; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return unsigned;
    function u2u_cast (inp : unsigned; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return unsigned;
    function u2v_cast (inp : unsigned; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return std_logic_vector;
    function s2v_cast (inp : signed; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return std_logic_vector;
    function trunc (inp : std_logic_vector; old_width, old_bin_pt, old_arith,
                    new_width, new_bin_pt, new_arith : INTEGER)
        return std_logic_vector;
    function round_towards_inf (inp : std_logic_vector; old_width, old_bin_pt,
                                old_arith, new_width, new_bin_pt,
                                new_arith : INTEGER) return std_logic_vector;
    function round_towards_even (inp : std_logic_vector; old_width, old_bin_pt,
                                old_arith, new_width, new_bin_pt,
                                new_arith : INTEGER) return std_logic_vector;
    function max_signed(width : INTEGER) return std_logic_vector;
    function min_signed(width : INTEGER) return std_logic_vector;
    function saturation_arith(inp:  std_logic_vector;  old_width, old_bin_pt,
                              old_arith, new_width, new_bin_pt, new_arith
                              : INTEGER) return std_logic_vector;
    function wrap_arith(inp:  std_logic_vector;  old_width, old_bin_pt,
                        old_arith, new_width, new_bin_pt, new_arith : INTEGER)
                        return std_logic_vector;
    function fractional_bits(a_bin_pt, b_bin_pt: INTEGER) return INTEGER;
    function integer_bits(a_width, a_bin_pt, b_width, b_bin_pt: INTEGER)
        return INTEGER;
    function sign_ext(inp : std_logic_vector; new_width : INTEGER)
        return std_logic_vector;
    function zero_ext(inp : std_logic_vector; new_width : INTEGER)
        return std_logic_vector;
    function zero_ext(inp : std_logic; new_width : INTEGER)
        return std_logic_vector;
    function extend_MSB(inp : std_logic_vector; new_width, arith : INTEGER)
        return std_logic_vector;
    function align_input(inp : std_logic_vector; old_width, delta, new_arith,
                          new_width: INTEGER)
        return std_logic_vector;
    function pad_LSB(inp : std_logic_vector; new_width: integer)
        return std_logic_vector;
    function pad_LSB(inp : std_logic_vector; new_width, arith : integer)
        return std_logic_vector;
    function max(L, R: INTEGER) return INTEGER;
    function min(L, R: INTEGER) return INTEGER;
    function "="(left,right: STRING) return boolean;
    function boolean_to_signed (inp : boolean; width: integer)
        return signed;
    function boolean_to_unsigned (inp : boolean; width: integer)
        return unsigned;
    function boolean_to_vector (inp : boolean)
        return std_logic_vector;
    function std_logic_to_vector (inp : std_logic)
        return std_logic_vector;
    function integer_to_std_logic_vector (inp : integer;  width, arith : integer)
        return std_logic_vector;
    function std_logic_vector_to_integer (inp : std_logic_vector;  arith : integer)
        return integer;
    function std_logic_to_integer(constant inp : std_logic := '0')
        return integer;
    function bin_string_element_to_std_logic_vector (inp : string;  width, index : integer)
        return std_logic_vector;
    function bin_string_to_std_logic_vector (inp : string)
        return std_logic_vector;
    function hex_string_to_std_logic_vector (inp : string; width : integer)
        return std_logic_vector;
    function makeZeroBinStr (width : integer) return STRING;
    function and_reduce(inp: std_logic_vector) return std_logic;
    -- synopsys translate_off
    function is_binary_string_invalid (inp : string)
        return boolean;
    function is_binary_string_undefined (inp : string)
        return boolean;
    function is_XorU(inp : std_logic_vector)
        return boolean;
    function to_real(inp : std_logic_vector; bin_pt : integer; arith : integer)
        return real;
    function std_logic_to_real(inp : std_logic; bin_pt : integer; arith : integer)
        return real;
    function real_to_std_logic_vector (inp : real;  width, bin_pt, arith : integer)
        return std_logic_vector;
    function real_string_to_std_logic_vector (inp : string;  width, bin_pt, arith : integer)
        return std_logic_vector;
    constant display_precision : integer := 20;
    function real_to_string (inp : real) return string;
    function valid_bin_string(inp : string) return boolean;
    function std_logic_vector_to_bin_string(inp : std_logic_vector) return string;
    function std_logic_to_bin_string(inp : std_logic) return string;
    function std_logic_vector_to_bin_string_w_point(inp : std_logic_vector; bin_pt : integer)
        return string;
    function real_to_bin_string(inp : real;  width, bin_pt, arith : integer)
        return string;
    type stdlogic_to_char_t is array(std_logic) of character;
    constant to_char : stdlogic_to_char_t := (
        'U' => 'U',
        'X' => 'X',
        '0' => '0',
        '1' => '1',
        'Z' => 'Z',
        'W' => 'W',
        'L' => 'L',
        'H' => 'H',
        '-' => '-');
    -- synopsys translate_on
end conv_pkg;
package body conv_pkg is
    function std_logic_vector_to_unsigned(inp : std_logic_vector)
        return unsigned
    is
    begin
        return unsigned (inp);
    end;
    function unsigned_to_std_logic_vector(inp : unsigned)
        return std_logic_vector
    is
    begin
        return std_logic_vector(inp);
    end;
    function std_logic_vector_to_signed(inp : std_logic_vector)
        return signed
    is
    begin
        return  signed (inp);
    end;
    function signed_to_std_logic_vector(inp : signed)
        return std_logic_vector
    is
    begin
        return std_logic_vector(inp);
    end;
    function unsigned_to_signed (inp : unsigned)
        return signed
    is
    begin
        return signed(std_logic_vector(inp));
    end;
    function signed_to_unsigned (inp : signed)
        return unsigned
    is
    begin
        return unsigned(std_logic_vector(inp));
    end;
    function pos(inp : std_logic_vector; arith : INTEGER)
        return boolean
    is
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
    begin
        vec := inp;
        if arith = xlUnsigned then
            return true;
        else
            if vec(width-1) = '0' then
                return true;
            else
                return false;
            end if;
        end if;
        return true;
    end;
    function max_signed(width : INTEGER)
        return std_logic_vector
    is
        variable ones : std_logic_vector(width-2 downto 0);
        variable result : std_logic_vector(width-1 downto 0);
    begin
        ones := (others => '1');
        result(width-1) := '0';
        result(width-2 downto 0) := ones;
        return result;
    end;
    function min_signed(width : INTEGER)
        return std_logic_vector
    is
        variable zeros : std_logic_vector(width-2 downto 0);
        variable result : std_logic_vector(width-1 downto 0);
    begin
        zeros := (others => '0');
        result(width-1) := '1';
        result(width-2 downto 0) := zeros;
        return result;
    end;
    function and_reduce(inp: std_logic_vector) return std_logic
    is
        variable result: std_logic;
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
    begin
        vec := inp;
        result := vec(0);
        if width > 1 then
            for i in 1 to width-1 loop
                result := result and vec(i);
            end loop;
        end if;
        return result;
    end;
    function all_same(inp: std_logic_vector) return boolean
    is
        variable result: boolean;
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
    begin
        vec := inp;
        result := true;
        if width > 0 then
            for i in 1 to width-1 loop
                if vec(i) /= vec(0) then
                    result := false;
                end if;
            end loop;
        end if;
        return result;
    end;
    function all_zeros(inp: std_logic_vector)
        return boolean
    is
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
        variable zero : std_logic_vector(width-1 downto 0);
        variable result : boolean;
    begin
        zero := (others => '0');
        vec := inp;
        -- synopsys translate_off
        if (is_XorU(vec)) then
            return false;
        end if;
         -- synopsys translate_on
        if (std_logic_vector_to_unsigned(vec) = std_logic_vector_to_unsigned(zero)) then
            result := true;
        else
            result := false;
        end if;
        return result;
    end;
    function is_point_five(inp: std_logic_vector)
        return boolean
    is
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
        variable result : boolean;
    begin
        vec := inp;
        -- synopsys translate_off
        if (is_XorU(vec)) then
            return false;
        end if;
         -- synopsys translate_on
        if (width > 1) then
           if ((vec(width-1) = '1') and (all_zeros(vec(width-2 downto 0)) = true)) then
               result := true;
           else
               result := false;
           end if;
        else
           if (vec(width-1) = '1') then
               result := true;
           else
               result := false;
           end if;
        end if;
        return result;
    end;
    function all_ones(inp: std_logic_vector)
        return boolean
    is
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
        variable one : std_logic_vector(width-1 downto 0);
        variable result : boolean;
    begin
        one := (others => '1');
        vec := inp;
        -- synopsys translate_off
        if (is_XorU(vec)) then
            return false;
        end if;
         -- synopsys translate_on
        if (std_logic_vector_to_unsigned(vec) = std_logic_vector_to_unsigned(one)) then
            result := true;
        else
            result := false;
        end if;
        return result;
    end;
    function full_precision_num_width(quantization, overflow, old_width,
                                      old_bin_pt, old_arith,
                                      new_width, new_bin_pt, new_arith : INTEGER)
        return integer
    is
        variable result : integer;
    begin
        result := old_width + 2;
        return result;
    end;
    function quantized_num_width(quantization, overflow, old_width, old_bin_pt,
                                 old_arith, new_width, new_bin_pt, new_arith
                                 : INTEGER)
        return integer
    is
        variable right_of_dp, left_of_dp, result : integer;
    begin
        right_of_dp := max(new_bin_pt, old_bin_pt);
        left_of_dp := max((new_width - new_bin_pt), (old_width - old_bin_pt));
        result := (old_width + 2) + (new_bin_pt - old_bin_pt);
        return result;
    end;
    function convert_type (inp : std_logic_vector; old_width, old_bin_pt,
                           old_arith, new_width, new_bin_pt, new_arith,
                           quantization, overflow : INTEGER)
        return std_logic_vector
    is
        constant fp_width : integer :=
            full_precision_num_width(quantization, overflow, old_width,
                                     old_bin_pt, old_arith, new_width,
                                     new_bin_pt, new_arith);
        constant fp_bin_pt : integer := old_bin_pt;
        constant fp_arith : integer := old_arith;
        variable full_precision_result : std_logic_vector(fp_width-1 downto 0);
        constant q_width : integer :=
            quantized_num_width(quantization, overflow, old_width, old_bin_pt,
                                old_arith, new_width, new_bin_pt, new_arith);
        constant q_bin_pt : integer := new_bin_pt;
        constant q_arith : integer := old_arith;
        variable quantized_result : std_logic_vector(q_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        result := (others => '0');
        full_precision_result := cast(inp, old_bin_pt, fp_width, fp_bin_pt,
                                      fp_arith);
        if (quantization = xlRound) then
            quantized_result := round_towards_inf(full_precision_result,
                                                  fp_width, fp_bin_pt,
                                                  fp_arith, q_width, q_bin_pt,
                                                  q_arith);
        elsif (quantization = xlRoundBanker) then
            quantized_result := round_towards_even(full_precision_result,
                                                  fp_width, fp_bin_pt,
                                                  fp_arith, q_width, q_bin_pt,
                                                  q_arith);
        else
            quantized_result := trunc(full_precision_result, fp_width, fp_bin_pt,
                                      fp_arith, q_width, q_bin_pt, q_arith);
        end if;
        if (overflow = xlSaturate) then
            result := saturation_arith(quantized_result, q_width, q_bin_pt,
                                       q_arith, new_width, new_bin_pt, new_arith);
        else
             result := wrap_arith(quantized_result, q_width, q_bin_pt, q_arith,
                                  new_width, new_bin_pt, new_arith);
        end if;
        return result;
    end;
    function cast (inp : std_logic_vector; old_bin_pt, new_width,
                   new_bin_pt, new_arith : INTEGER)
        return std_logic_vector
    is
        constant old_width : integer := inp'length;
        constant left_of_dp : integer := (new_width - new_bin_pt)
                                         - (old_width - old_bin_pt);
        constant right_of_dp : integer := (new_bin_pt - old_bin_pt);
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
        variable j   : integer;
    begin
        vec := inp;
        for i in new_width-1 downto 0 loop
            j := i - right_of_dp;
            if ( j > old_width-1) then
                if (new_arith = xlUnsigned) then
                    result(i) := '0';
                else
                    result(i) := vec(old_width-1);
                end if;
            elsif ( j >= 0) then
                result(i) := vec(j);
            else
                result(i) := '0';
            end if;
        end loop;
        return result;
    end;
    function vec_slice (inp : std_logic_vector; upper, lower : INTEGER)
      return std_logic_vector
    is
    begin
        return inp(upper downto lower);
    end;
    function s2u_slice (inp : signed; upper, lower : INTEGER)
      return unsigned
    is
    begin
        return unsigned(vec_slice(std_logic_vector(inp), upper, lower));
    end;
    function u2u_slice (inp : unsigned; upper, lower : INTEGER)
      return unsigned
    is
    begin
        return unsigned(vec_slice(std_logic_vector(inp), upper, lower));
    end;
    function s2s_cast (inp : signed; old_bin_pt, new_width, new_bin_pt : INTEGER)
        return signed
    is
    begin
        return signed(cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlSigned));
    end;
    function s2u_cast (inp : signed; old_bin_pt, new_width,
                   new_bin_pt : INTEGER)
        return unsigned
    is
    begin
        return unsigned(cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlSigned));
    end;
    function u2s_cast (inp : unsigned; old_bin_pt, new_width,
                   new_bin_pt : INTEGER)
        return signed
    is
    begin
        return signed(cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlUnsigned));
    end;
    function u2u_cast (inp : unsigned; old_bin_pt, new_width,
                   new_bin_pt : INTEGER)
        return unsigned
    is
    begin
        return unsigned(cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlUnsigned));
    end;
    function u2v_cast (inp : unsigned; old_bin_pt, new_width,
                   new_bin_pt : INTEGER)
        return std_logic_vector
    is
    begin
        return cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlUnsigned);
    end;
    function s2v_cast (inp : signed; old_bin_pt, new_width,
                   new_bin_pt : INTEGER)
        return std_logic_vector
    is
    begin
        return cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlSigned);
    end;
    function boolean_to_signed (inp : boolean; width : integer)
        return signed
    is
        variable result : signed(width - 1 downto 0);
    begin
        result := (others => '0');
        if inp then
          result(0) := '1';
        else
          result(0) := '0';
        end if;
        return result;
    end;
    function boolean_to_unsigned (inp : boolean; width : integer)
        return unsigned
    is
        variable result : unsigned(width - 1 downto 0);
    begin
        result := (others => '0');
        if inp then
          result(0) := '1';
        else
          result(0) := '0';
        end if;
        return result;
    end;
    function boolean_to_vector (inp : boolean)
        return std_logic_vector
    is
        variable result : std_logic_vector(1 - 1 downto 0);
    begin
        result := (others => '0');
        if inp then
          result(0) := '1';
        else
          result(0) := '0';
        end if;
        return result;
    end;
    function std_logic_to_vector (inp : std_logic)
        return std_logic_vector
    is
        variable result : std_logic_vector(1 - 1 downto 0);
    begin
        result(0) := inp;
        return result;
    end;
    function trunc (inp : std_logic_vector; old_width, old_bin_pt, old_arith,
                                new_width, new_bin_pt, new_arith : INTEGER)
        return std_logic_vector
    is
        constant right_of_dp : integer := (old_bin_pt - new_bin_pt);
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if right_of_dp >= 0 then
            if new_arith = xlUnsigned then
                result := zero_ext(vec(old_width-1 downto right_of_dp), new_width);
            else
                result := sign_ext(vec(old_width-1 downto right_of_dp), new_width);
            end if;
        else
            if new_arith = xlUnsigned then
                result := zero_ext(pad_LSB(vec, old_width +
                                           abs(right_of_dp)), new_width);
            else
                result := sign_ext(pad_LSB(vec, old_width +
                                           abs(right_of_dp)), new_width);
            end if;
        end if;
        return result;
    end;
    function round_towards_inf (inp : std_logic_vector; old_width, old_bin_pt,
                                old_arith, new_width, new_bin_pt, new_arith
                                : INTEGER)
        return std_logic_vector
    is
        constant right_of_dp : integer := (old_bin_pt - new_bin_pt);
        constant expected_new_width : integer :=  old_width - right_of_dp  + 1;
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable one_or_zero : std_logic_vector(new_width-1 downto 0);
        variable truncated_val : std_logic_vector(new_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if right_of_dp >= 0 then
            if new_arith = xlUnsigned then
                truncated_val := zero_ext(vec(old_width-1 downto right_of_dp),
                                          new_width);
            else
                truncated_val := sign_ext(vec(old_width-1 downto right_of_dp),
                                          new_width);
            end if;
        else
            if new_arith = xlUnsigned then
                truncated_val := zero_ext(pad_LSB(vec, old_width +
                                                  abs(right_of_dp)), new_width);
            else
                truncated_val := sign_ext(pad_LSB(vec, old_width +
                                                  abs(right_of_dp)), new_width);
            end if;
        end if;
        one_or_zero := (others => '0');
        if (new_arith = xlSigned) then
            if (vec(old_width-1) = '0') then
                one_or_zero(0) := '1';
            end if;
            if (right_of_dp >= 2) and (right_of_dp <= old_width) then
                if (all_zeros(vec(right_of_dp-2 downto 0)) = false) then
                    one_or_zero(0) := '1';
                end if;
            end if;
            if (right_of_dp >= 1) and (right_of_dp <= old_width) then
                if vec(right_of_dp-1) = '0' then
                    one_or_zero(0) := '0';
                end if;
            else
                one_or_zero(0) := '0';
            end if;
        else
            if (right_of_dp >= 1) and (right_of_dp <= old_width) then
                one_or_zero(0) :=  vec(right_of_dp-1);
            end if;
        end if;
        if new_arith = xlSigned then
            result := signed_to_std_logic_vector(std_logic_vector_to_signed(truncated_val) +
                                                 std_logic_vector_to_signed(one_or_zero));
        else
            result := unsigned_to_std_logic_vector(std_logic_vector_to_unsigned(truncated_val) +
                                                  std_logic_vector_to_unsigned(one_or_zero));
        end if;
        return result;
    end;
    function round_towards_even (inp : std_logic_vector; old_width, old_bin_pt,
                                old_arith, new_width, new_bin_pt, new_arith
                                : INTEGER)
        return std_logic_vector
    is
        constant right_of_dp : integer := (old_bin_pt - new_bin_pt);
        constant expected_new_width : integer :=  old_width - right_of_dp  + 1;
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable one_or_zero : std_logic_vector(new_width-1 downto 0);
        variable truncated_val : std_logic_vector(new_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if right_of_dp >= 0 then
            if new_arith = xlUnsigned then
                truncated_val := zero_ext(vec(old_width-1 downto right_of_dp),
                                          new_width);
            else
                truncated_val := sign_ext(vec(old_width-1 downto right_of_dp),
                                          new_width);
            end if;
        else
            if new_arith = xlUnsigned then
                truncated_val := zero_ext(pad_LSB(vec, old_width +
                                                  abs(right_of_dp)), new_width);
            else
                truncated_val := sign_ext(pad_LSB(vec, old_width +
                                                  abs(right_of_dp)), new_width);
            end if;
        end if;
        one_or_zero := (others => '0');
        if (right_of_dp >= 1) and (right_of_dp <= old_width) then
            if (is_point_five(vec(right_of_dp-1 downto 0)) = false) then
                one_or_zero(0) :=  vec(right_of_dp-1);
            else
                one_or_zero(0) :=  vec(right_of_dp);
            end if;
        end if;
        if new_arith = xlSigned then
            result := signed_to_std_logic_vector(std_logic_vector_to_signed(truncated_val) +
                                                 std_logic_vector_to_signed(one_or_zero));
        else
            result := unsigned_to_std_logic_vector(std_logic_vector_to_unsigned(truncated_val) +
                                                  std_logic_vector_to_unsigned(one_or_zero));
        end if;
        return result;
    end;
    function saturation_arith(inp:  std_logic_vector;  old_width, old_bin_pt,
                              old_arith, new_width, new_bin_pt, new_arith
                              : INTEGER)
        return std_logic_vector
    is
        constant left_of_dp : integer := (old_width - old_bin_pt) -
                                         (new_width - new_bin_pt);
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
        variable overflow : boolean;
    begin
        vec := inp;
        overflow := true;
        result := (others => '0');
        if (new_width >= old_width) then
            overflow := false;
        end if;
        if ((old_arith = xlSigned and new_arith = xlSigned) and (old_width > new_width)) then
            if all_same(vec(old_width-1 downto new_width-1)) then
                overflow := false;
            end if;
        end if;
        if (old_arith = xlSigned and new_arith = xlUnsigned) then
            if (old_width > new_width) then
                if all_zeros(vec(old_width-1 downto new_width)) then
                    overflow := false;
                end if;
            else
                if (old_width = new_width) then
                    if (vec(new_width-1) = '0') then
                        overflow := false;
                    end if;
                end if;
            end if;
        end if;
        if (old_arith = xlUnsigned and new_arith = xlUnsigned) then
            if (old_width > new_width) then
                if all_zeros(vec(old_width-1 downto new_width)) then
                    overflow := false;
                end if;
            else
                if (old_width = new_width) then
                    overflow := false;
                end if;
            end if;
        end if;
        if ((old_arith = xlUnsigned and new_arith = xlSigned) and (old_width > new_width)) then
            if all_same(vec(old_width-1 downto new_width-1)) then
                overflow := false;
            end if;
        end if;
        if overflow then
            if new_arith = xlSigned then
                if vec(old_width-1) = '0' then
                    result := max_signed(new_width);
                else
                    result := min_signed(new_width);
                end if;
            else
                if ((old_arith = xlSigned) and vec(old_width-1) = '1') then
                    result := (others => '0');
                else
                    result := (others => '1');
                end if;
            end if;
        else
            if (old_arith = xlSigned) and (new_arith = xlUnsigned) then
                if (vec(old_width-1) = '1') then
                    vec := (others => '0');
                end if;
            end if;
            if new_width <= old_width then
                result := vec(new_width-1 downto 0);
            else
                if new_arith = xlUnsigned then
                    result := zero_ext(vec, new_width);
                else
                    result := sign_ext(vec, new_width);
                end if;
            end if;
        end if;
        return result;
    end;
   function wrap_arith(inp:  std_logic_vector;  old_width, old_bin_pt,
                       old_arith, new_width, new_bin_pt, new_arith : INTEGER)
        return std_logic_vector
    is
        variable result : std_logic_vector(new_width-1 downto 0);
        variable result_arith : integer;
    begin
        if (old_arith = xlSigned) and (new_arith = xlUnsigned) then
            result_arith := xlSigned;
        end if;
        result := cast(inp, old_bin_pt, new_width, new_bin_pt, result_arith);
        return result;
    end;
    function fractional_bits(a_bin_pt, b_bin_pt: INTEGER) return INTEGER is
    begin
        return max(a_bin_pt, b_bin_pt);
    end;
    function integer_bits(a_width, a_bin_pt, b_width, b_bin_pt: INTEGER)
        return INTEGER is
    begin
        return  max(a_width - a_bin_pt, b_width - b_bin_pt);
    end;
    function pad_LSB(inp : std_logic_vector; new_width: integer)
        return STD_LOGIC_VECTOR
    is
        constant orig_width : integer := inp'length;
        variable vec : std_logic_vector(orig_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
        variable pos : integer;
        constant pad_pos : integer := new_width - orig_width - 1;
    begin
        vec := inp;
        pos := new_width-1;
        if (new_width >= orig_width) then
            for i in orig_width-1 downto 0 loop
                result(pos) := vec(i);
                pos := pos - 1;
            end loop;
            if pad_pos >= 0 then
                for i in pad_pos downto 0 loop
                    result(i) := '0';
                end loop;
            end if;
        end if;
        return result;
    end;
    function sign_ext(inp : std_logic_vector; new_width : INTEGER)
        return std_logic_vector
    is
        constant old_width : integer := inp'length;
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if new_width >= old_width then
            result(old_width-1 downto 0) := vec;
            if new_width-1 >= old_width then
                for i in new_width-1 downto old_width loop
                    result(i) := vec(old_width-1);
                end loop;
            end if;
        else
            result(new_width-1 downto 0) := vec(new_width-1 downto 0);
        end if;
        return result;
    end;
    function zero_ext(inp : std_logic_vector; new_width : INTEGER)
        return std_logic_vector
    is
        constant old_width : integer := inp'length;
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if new_width >= old_width then
            result(old_width-1 downto 0) := vec;
            if new_width-1 >= old_width then
                for i in new_width-1 downto old_width loop
                    result(i) := '0';
                end loop;
            end if;
        else
            result(new_width-1 downto 0) := vec(new_width-1 downto 0);
        end if;
        return result;
    end;
    function zero_ext(inp : std_logic; new_width : INTEGER)
        return std_logic_vector
    is
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        result(0) := inp;
        for i in new_width-1 downto 1 loop
            result(i) := '0';
        end loop;
        return result;
    end;
    function extend_MSB(inp : std_logic_vector; new_width, arith : INTEGER)
        return std_logic_vector
    is
        constant orig_width : integer := inp'length;
        variable vec : std_logic_vector(orig_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if arith = xlUnsigned then
            result := zero_ext(vec, new_width);
        else
            result := sign_ext(vec, new_width);
        end if;
        return result;
    end;
    function pad_LSB(inp : std_logic_vector; new_width, arith: integer)
        return STD_LOGIC_VECTOR
    is
        constant orig_width : integer := inp'length;
        variable vec : std_logic_vector(orig_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
        variable pos : integer;
    begin
        vec := inp;
        pos := new_width-1;
        if (arith = xlUnsigned) then
            result(pos) := '0';
            pos := pos - 1;
        else
            result(pos) := vec(orig_width-1);
            pos := pos - 1;
        end if;
        if (new_width >= orig_width) then
            for i in orig_width-1 downto 0 loop
                result(pos) := vec(i);
                pos := pos - 1;
            end loop;
            if pos >= 0 then
                for i in pos downto 0 loop
                    result(i) := '0';
                end loop;
            end if;
        end if;
        return result;
    end;
    function align_input(inp : std_logic_vector; old_width, delta, new_arith,
                         new_width: INTEGER)
        return std_logic_vector
    is
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable padded_inp : std_logic_vector((old_width + delta)-1  downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if delta > 0 then
            padded_inp := pad_LSB(vec, old_width+delta);
            result := extend_MSB(padded_inp, new_width, new_arith);
        else
            result := extend_MSB(vec, new_width, new_arith);
        end if;
        return result;
    end;
    function max(L, R: INTEGER) return INTEGER is
    begin
        if L > R then
            return L;
        else
            return R;
        end if;
    end;
    function min(L, R: INTEGER) return INTEGER is
    begin
        if L < R then
            return L;
        else
            return R;
        end if;
    end;
    function "="(left,right: STRING) return boolean is
    begin
        if (left'length /= right'length) then
            return false;
        else
            test : for i in 1 to left'length loop
                if left(i) /= right(i) then
                    return false;
                end if;
            end loop test;
            return true;
        end if;
    end;
    -- synopsys translate_off
    function is_binary_string_invalid (inp : string)
        return boolean
    is
        variable vec : string(1 to inp'length);
        variable result : boolean;
    begin
        vec := inp;
        result := false;
        for i in 1 to vec'length loop
            if ( vec(i) = 'X' ) then
                result := true;
            end if;
        end loop;
        return result;
    end;
    function is_binary_string_undefined (inp : string)
        return boolean
    is
        variable vec : string(1 to inp'length);
        variable result : boolean;
    begin
        vec := inp;
        result := false;
        for i in 1 to vec'length loop
            if ( vec(i) = 'U' ) then
                result := true;
            end if;
        end loop;
        return result;
    end;
    function is_XorU(inp : std_logic_vector)
        return boolean
    is
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
        variable result : boolean;
    begin
        vec := inp;
        result := false;
        for i in 0 to width-1 loop
            if (vec(i) = 'U') or (vec(i) = 'X') then
                result := true;
            end if;
        end loop;
        return result;
    end;
    function to_real(inp : std_logic_vector; bin_pt : integer; arith : integer)
        return real
    is
        variable  vec : std_logic_vector(inp'length-1 downto 0);
        variable result, shift_val, undefined_real : real;
        variable neg_num : boolean;
    begin
        vec := inp;
        result := 0.0;
        neg_num := false;
        if vec(inp'length-1) = '1' then
            neg_num := true;
        end if;
        for i in 0 to inp'length-1 loop
            if  vec(i) = 'U' or vec(i) = 'X' then
                return undefined_real;
            end if;
            if arith = xlSigned then
                if neg_num then
                    if vec(i) = '0' then
                        result := result + 2.0**i;
                    end if;
                else
                    if vec(i) = '1' then
                        result := result + 2.0**i;
                    end if;
                end if;
            else
                if vec(i) = '1' then
                    result := result + 2.0**i;
                end if;
            end if;
        end loop;
        if arith = xlSigned then
            if neg_num then
                result := result + 1.0;
                result := result * (-1.0);
            end if;
        end if;
        shift_val := 2.0**(-1*bin_pt);
        result := result * shift_val;
        return result;
    end;
    function std_logic_to_real(inp : std_logic; bin_pt : integer; arith : integer)
        return real
    is
        variable result : real := 0.0;
    begin
        if inp = '1' then
            result := 1.0;
        end if;
        if arith = xlSigned then
            assert false
                report "It doesn't make sense to convert a 1 bit number to a signed real.";
        end if;
        return result;
    end;
    -- synopsys translate_on
    function integer_to_std_logic_vector (inp : integer;  width, arith : integer)
        return std_logic_vector
    is
        variable result : std_logic_vector(width-1 downto 0);
        variable unsigned_val : unsigned(width-1 downto 0);
        variable signed_val : signed(width-1 downto 0);
    begin
        if (arith = xlSigned) then
            signed_val := to_signed(inp, width);
            result := signed_to_std_logic_vector(signed_val);
        else
            unsigned_val := to_unsigned(inp, width);
            result := unsigned_to_std_logic_vector(unsigned_val);
        end if;
        return result;
    end;
    function std_logic_vector_to_integer (inp : std_logic_vector;  arith : integer)
        return integer
    is
        constant width : integer := inp'length;
        variable unsigned_val : unsigned(width-1 downto 0);
        variable signed_val : signed(width-1 downto 0);
        variable result : integer;
    begin
        if (arith = xlSigned) then
            signed_val := std_logic_vector_to_signed(inp);
            result := to_integer(signed_val);
        else
            unsigned_val := std_logic_vector_to_unsigned(inp);
            result := to_integer(unsigned_val);
        end if;
        return result;
    end;
    function std_logic_to_integer(constant inp : std_logic := '0')
        return integer
    is
    begin
        if inp = '1' then
            return 1;
        else
            return 0;
        end if;
    end;
    function makeZeroBinStr (width : integer) return STRING is
        variable result : string(1 to width+3);
    begin
        result(1) := '0';
        result(2) := 'b';
        for i in 3 to width+2 loop
            result(i) := '0';
        end loop;
        result(width+3) := '.';
        return result;
    end;
    -- synopsys translate_off
    function real_string_to_std_logic_vector (inp : string;  width, bin_pt, arith : integer)
        return std_logic_vector
    is
        variable result : std_logic_vector(width-1 downto 0);
    begin
        result := (others => '0');
        return result;
    end;
    function real_to_std_logic_vector (inp : real;  width, bin_pt, arith : integer)
        return std_logic_vector
    is
        variable real_val : real;
        variable int_val : integer;
        variable result : std_logic_vector(width-1 downto 0) := (others => '0');
        variable unsigned_val : unsigned(width-1 downto 0) := (others => '0');
        variable signed_val : signed(width-1 downto 0) := (others => '0');
    begin
        real_val := inp;
        int_val := integer(real_val * 2.0**(bin_pt));
        if (arith = xlSigned) then
            signed_val := to_signed(int_val, width);
            result := signed_to_std_logic_vector(signed_val);
        else
            unsigned_val := to_unsigned(int_val, width);
            result := unsigned_to_std_logic_vector(unsigned_val);
        end if;
        return result;
    end;
    -- synopsys translate_on
    function valid_bin_string (inp : string)
        return boolean
    is
        variable vec : string(1 to inp'length);
    begin
        vec := inp;
        if (vec(1) = '0' and vec(2) = 'b') then
            return true;
        else
            return false;
        end if;
    end;
    function hex_string_to_std_logic_vector(inp: string; width : integer)
        return std_logic_vector is
        constant strlen       : integer := inp'LENGTH;
        variable result       : std_logic_vector(width-1 downto 0);
        variable bitval       : std_logic_vector((strlen*4)-1 downto 0);
        variable posn         : integer;
        variable ch           : character;
        variable vec          : string(1 to strlen);
    begin
        vec := inp;
        result := (others => '0');
        posn := (strlen*4)-1;
        for i in 1 to strlen loop
            ch := vec(i);
            case ch is
                when '0' => bitval(posn downto posn-3) := "0000";
                when '1' => bitval(posn downto posn-3) := "0001";
                when '2' => bitval(posn downto posn-3) := "0010";
                when '3' => bitval(posn downto posn-3) := "0011";
                when '4' => bitval(posn downto posn-3) := "0100";
                when '5' => bitval(posn downto posn-3) := "0101";
                when '6' => bitval(posn downto posn-3) := "0110";
                when '7' => bitval(posn downto posn-3) := "0111";
                when '8' => bitval(posn downto posn-3) := "1000";
                when '9' => bitval(posn downto posn-3) := "1001";
                when 'A' | 'a' => bitval(posn downto posn-3) := "1010";
                when 'B' | 'b' => bitval(posn downto posn-3) := "1011";
                when 'C' | 'c' => bitval(posn downto posn-3) := "1100";
                when 'D' | 'd' => bitval(posn downto posn-3) := "1101";
                when 'E' | 'e' => bitval(posn downto posn-3) := "1110";
                when 'F' | 'f' => bitval(posn downto posn-3) := "1111";
                when others => bitval(posn downto posn-3) := "XXXX";
                               -- synopsys translate_off
                               ASSERT false
                                   REPORT "Invalid hex value" SEVERITY ERROR;
                               -- synopsys translate_on
            end case;
            posn := posn - 4;
        end loop;
        if (width <= strlen*4) then
            result :=  bitval(width-1 downto 0);
        else
            result((strlen*4)-1 downto 0) := bitval;
        end if;
        return result;
    end;
    function bin_string_to_std_logic_vector (inp : string)
        return std_logic_vector
    is
        variable pos : integer;
        variable vec : string(1 to inp'length);
        variable result : std_logic_vector(inp'length-1 downto 0);
    begin
        vec := inp;
        pos := inp'length-1;
        result := (others => '0');
        for i in 1 to vec'length loop
            -- synopsys translate_off
            if (pos < 0) and (vec(i) = '0' or vec(i) = '1' or vec(i) = 'X' or vec(i) = 'U')  then
                assert false
                    report "Input string is larger than output std_logic_vector. Truncating output.";
                return result;
            end if;
            -- synopsys translate_on
            if vec(i) = '0' then
                result(pos) := '0';
                pos := pos - 1;
            end if;
            if vec(i) = '1' then
                result(pos) := '1';
                pos := pos - 1;
            end if;
            -- synopsys translate_off
            if (vec(i) = 'X' or vec(i) = 'U') then
                result(pos) := 'U';
                pos := pos - 1;
            end if;
            -- synopsys translate_on
        end loop;
        return result;
    end;
    function bin_string_element_to_std_logic_vector (inp : string;  width, index : integer)
        return std_logic_vector
    is
        constant str_width : integer := width + 4;
        constant inp_len : integer := inp'length;
        constant num_elements : integer := (inp_len + 1)/str_width;
        constant reverse_index : integer := (num_elements-1) - index;
        variable left_pos : integer;
        variable right_pos : integer;
        variable vec : string(1 to inp'length);
        variable result : std_logic_vector(width-1 downto 0);
    begin
        vec := inp;
        result := (others => '0');
        if (reverse_index = 0) and (reverse_index < num_elements) and (inp_len-3 >= width) then
            left_pos := 1;
            right_pos := width + 3;
            result := bin_string_to_std_logic_vector(vec(left_pos to right_pos));
        end if;
        if (reverse_index > 0) and (reverse_index < num_elements) and (inp_len-3 >= width) then
            left_pos := (reverse_index * str_width) + 1;
            right_pos := left_pos + width + 2;
            result := bin_string_to_std_logic_vector(vec(left_pos to right_pos));
        end if;
        return result;
    end;
   -- synopsys translate_off
    function std_logic_vector_to_bin_string(inp : std_logic_vector)
        return string
    is
        variable vec : std_logic_vector(1 to inp'length);
        variable result : string(vec'range);
    begin
        vec := inp;
        for i in vec'range loop
            result(i) := to_char(vec(i));
        end loop;
        return result;
    end;
    function std_logic_to_bin_string(inp : std_logic)
        return string
    is
        variable result : string(1 to 3);
    begin
        result(1) := '0';
        result(2) := 'b';
        result(3) := to_char(inp);
        return result;
    end;
    function std_logic_vector_to_bin_string_w_point(inp : std_logic_vector; bin_pt : integer)
        return string
    is
        variable width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
        variable str_pos : integer;
        variable result : string(1 to width+3);
    begin
        vec := inp;
        str_pos := 1;
        result(str_pos) := '0';
        str_pos := 2;
        result(str_pos) := 'b';
        str_pos := 3;
        for i in width-1 downto 0  loop
            if (((width+3) - bin_pt) = str_pos) then
                result(str_pos) := '.';
                str_pos := str_pos + 1;
            end if;
            result(str_pos) := to_char(vec(i));
            str_pos := str_pos + 1;
        end loop;
        if (bin_pt = 0) then
            result(str_pos) := '.';
        end if;
        return result;
    end;
    function real_to_bin_string(inp : real;  width, bin_pt, arith : integer)
        return string
    is
        variable result : string(1 to width);
        variable vec : std_logic_vector(width-1 downto 0);
    begin
        vec := real_to_std_logic_vector(inp, width, bin_pt, arith);
        result := std_logic_vector_to_bin_string(vec);
        return result;
    end;
    function real_to_string (inp : real) return string
    is
        variable result : string(1 to display_precision) := (others => ' ');
    begin
        result(real'image(inp)'range) := real'image(inp);
        return result;
    end;
    -- synopsys translate_on
end conv_pkg;
library IEEE;
use IEEE.std_logic_1164.all;
package clock_pkg is
-- synopsys translate_off
   signal int_clk : std_logic;
-- synopsys translate_on
end clock_pkg;

-------------------------------------------------------------------
-- System Generator version 10.1.3 VHDL source file.
--
-- Copyright(C) 2008 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2008 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library unisim;
use unisim.vcomponents.all;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity srl17e is
    generic (width : integer:=16;
             latency : integer :=8);
    port (clk   : in std_logic;
          ce    : in std_logic;
          d     : in std_logic_vector(width-1 downto 0);
          q     : out std_logic_vector(width-1 downto 0));
end srl17e;
architecture structural of srl17e is
    component SRL16E
        port (D   : in STD_ULOGIC;
              CE  : in STD_ULOGIC;
              CLK : in STD_ULOGIC;
              A0  : in STD_ULOGIC;
              A1  : in STD_ULOGIC;
              A2  : in STD_ULOGIC;
              A3  : in STD_ULOGIC;
              Q   : out STD_ULOGIC);
    end component;
    attribute syn_black_box of SRL16E : component is true;
    attribute fpga_dont_touch of SRL16E : component is "true";
    component FDE
        port(
            Q  :        out   STD_ULOGIC;
            D  :        in    STD_ULOGIC;
            C  :        in    STD_ULOGIC;
            CE :        in    STD_ULOGIC);
    end component;
    attribute syn_black_box of FDE : component is true;
    attribute fpga_dont_touch of FDE : component is "true";
    constant a : std_logic_vector(4 downto 0) :=
        integer_to_std_logic_vector(latency-2,5,xlSigned);
    signal d_delayed : std_logic_vector(width-1 downto 0);
    signal srl16_out : std_logic_vector(width-1 downto 0);
begin
    d_delayed <= d after 200 ps;
    reg_array : for i in 0 to width-1 generate
        srl16_used: if latency > 1 generate
            u1 : srl16e port map(clk => clk,
                                 d => d_delayed(i),
                                 q => srl16_out(i),
                                 ce => ce,
                                 a0 => a(0),
                                 a1 => a(1),
                                 a2 => a(2),
                                 a3 => a(3));
        end generate;
        srl16_not_used: if latency <= 1 generate
            srl16_out(i) <= d_delayed(i);
        end generate;
        fde_used: if latency /= 0  generate
            u2 : fde port map(c => clk,
                              d => srl16_out(i),
                              q => q(i),
                              ce => ce);
        end generate;
        fde_not_used: if latency = 0  generate
            q(i) <= srl16_out(i);
        end generate;
    end generate;
 end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity synth_reg is
    generic (width           : integer := 8;
             latency         : integer := 1);
    port (i       : in std_logic_vector(width-1 downto 0);
          ce      : in std_logic;
          clr     : in std_logic;
          clk     : in std_logic;
          o       : out std_logic_vector(width-1 downto 0));
end synth_reg;
architecture structural of synth_reg is
    component srl17e
        generic (width : integer:=16;
                 latency : integer :=8);
        port (clk : in std_logic;
              ce  : in std_logic;
              d   : in std_logic_vector(width-1 downto 0);
              q   : out std_logic_vector(width-1 downto 0));
    end component;
    function calc_num_srl17es (latency : integer)
        return integer
    is
        variable remaining_latency : integer;
        variable result : integer;
    begin
        result := latency / 17;
        remaining_latency := latency - (result * 17);
        if (remaining_latency /= 0) then
            result := result + 1;
        end if;
        return result;
    end;
    constant complete_num_srl17es : integer := latency / 17;
    constant num_srl17es : integer := calc_num_srl17es(latency);
    constant remaining_latency : integer := latency - (complete_num_srl17es * 17);
    type register_array is array (num_srl17es downto 0) of
        std_logic_vector(width-1 downto 0);
    signal z : register_array;
begin
    z(0) <= i;
    complete_ones : if complete_num_srl17es > 0 generate
        srl17e_array: for i in 0 to complete_num_srl17es-1 generate
            delay_comp : srl17e
                generic map (width => width,
                             latency => 17)
                port map (clk => clk,
                          ce  => ce,
                          d       => z(i),
                          q       => z(i+1));
        end generate;
    end generate;
    partial_one : if remaining_latency > 0 generate
        last_srl17e : srl17e
            generic map (width => width,
                         latency => remaining_latency)
            port map (clk => clk,
                      ce  => ce,
                      d   => z(num_srl17es-1),
                      q   => z(num_srl17es));
    end generate;
    o <= z(num_srl17es);
end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity synth_reg_reg is
    generic (width           : integer := 8;
             latency         : integer := 1);
    port (i       : in std_logic_vector(width-1 downto 0);
          ce      : in std_logic;
          clr     : in std_logic;
          clk     : in std_logic;
          o       : out std_logic_vector(width-1 downto 0));
end synth_reg_reg;
architecture behav of synth_reg_reg is
  type reg_array_type is array (latency-1 downto 0) of std_logic_vector(width -1 downto 0);
  signal reg_bank : reg_array_type := (others => (others => '0'));
  signal reg_bank_in : reg_array_type := (others => (others => '0'));
  attribute syn_allow_retiming : boolean;
  attribute syn_srlstyle : string;
  attribute syn_allow_retiming of reg_bank : signal is true;
  attribute syn_allow_retiming of reg_bank_in : signal is true;
  attribute syn_srlstyle of reg_bank : signal is "registers";
  attribute syn_srlstyle of reg_bank_in : signal is "registers";
begin
  latency_eq_0: if latency = 0 generate
    o <= i;
  end generate latency_eq_0;
  latency_gt_0: if latency >= 1 generate
    o <= reg_bank(latency-1);
    reg_bank_in(0) <= i;
    loop_gen: for idx in latency-2 downto 0 generate
      reg_bank_in(idx+1) <= reg_bank(idx);
    end generate loop_gen;
    sync_loop: for sync_idx in latency-1 downto 0 generate
      sync_proc: process (clk)
      begin
        if clk'event and clk = '1' then
          if ce = '1'  then
            reg_bank(sync_idx) <= reg_bank_in(sync_idx);
          end if;
        end if;
      end process sync_proc;
    end generate sync_loop;
  end generate latency_gt_0;
end behav;

-------------------------------------------------------------------
-- System Generator version 10.1.3 VHDL source file.
--
-- Copyright(C) 2008 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2008 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library unisim;
use unisim.vcomponents.all;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity single_reg_w_init is
  generic (
    width: integer := 8;
    init_index: integer := 0;
    init_value: bit_vector := b"0000"
  );
  port (
    i: in std_logic_vector(width - 1 downto 0);
    ce: in std_logic;
    clr: in std_logic;
    clk: in std_logic;
    o: out std_logic_vector(width - 1 downto 0)
  );
end single_reg_w_init;
architecture structural of single_reg_w_init is
  function build_init_const(width: integer;
                            init_index: integer;
                            init_value: bit_vector)
    return std_logic_vector
  is
    variable result: std_logic_vector(width - 1 downto 0);
  begin
    if init_index = 0 then
      result := (others => '0');
    elsif init_index = 1 then
      result := (others => '0');
      result(0) := '1';
    else
      result := to_stdlogicvector(init_value);
    end if;
    return result;
  end;
  component fdre
    port (
      q: out std_ulogic;
      d: in  std_ulogic;
      c: in  std_ulogic;
      ce: in  std_ulogic;
      r: in  std_ulogic
    );
  end component;
  attribute syn_black_box of fdre: component is true;
  attribute fpga_dont_touch of fdre: component is "true";
  component fdse
    port (
      q: out std_ulogic;
      d: in  std_ulogic;
      c: in  std_ulogic;
      ce: in  std_ulogic;
      s: in  std_ulogic
    );
  end component;
  attribute syn_black_box of fdse: component is true;
  attribute fpga_dont_touch of fdse: component is "true";
  constant init_const: std_logic_vector(width - 1 downto 0)
    := build_init_const(width, init_index, init_value);
begin
  fd_prim_array: for index in 0 to width - 1 generate
    bit_is_0: if (init_const(index) = '0') generate
      fdre_comp: fdre
        port map (
          c => clk,
          d => i(index),
          q => o(index),
          ce => ce,
          r => clr
        );
    end generate;
    bit_is_1: if (init_const(index) = '1') generate
      fdse_comp: fdse
        port map (
          c => clk,
          d => i(index),
          q => o(index),
          ce => ce,
          s => clr
        );
    end generate;
  end generate;
end architecture structural;
-- synopsys translate_off
library unisim;
use unisim.vcomponents.all;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity synth_reg_w_init is
  generic (
    width: integer := 8;
    init_index: integer := 0;
    init_value: bit_vector := b"0000";
    latency: integer := 1
  );
  port (
    i: in std_logic_vector(width - 1 downto 0);
    ce: in std_logic;
    clr: in std_logic;
    clk: in std_logic;
    o: out std_logic_vector(width - 1 downto 0)
  );
end synth_reg_w_init;
architecture structural of synth_reg_w_init is
  component single_reg_w_init
    generic (
      width: integer := 8;
      init_index: integer := 0;
      init_value: bit_vector := b"0000"
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;
  signal dly_i: std_logic_vector((latency + 1) * width - 1 downto 0);
  signal dly_clr: std_logic;
begin
  latency_eq_0: if (latency = 0) generate
    o <= i;
  end generate;
  latency_gt_0: if (latency >= 1) generate
    dly_i((latency + 1) * width - 1 downto latency * width) <= i
      after 200 ps;
    dly_clr <= clr after 200 ps;
    fd_array: for index in latency downto 1 generate
       reg_comp: single_reg_w_init
          generic map (
            width => width,
            init_index => init_index,
            init_value => init_value
          )
          port map (
            clk => clk,
            i => dly_i((index + 1) * width - 1 downto index * width),
            o => dly_i(index * width - 1 downto (index - 1) * width),
            ce => ce,
            clr => dly_clr
          );
    end generate;
    o <= dly_i(width - 1 downto 0);
  end generate;
end structural;

-------------------------------------------------------------------
-- System Generator version 10.1.3 VHDL source file.
--
-- Copyright(C) 2008 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2008 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity convert_func_call is
    generic (
        din_width    : integer := 16;
        din_bin_pt   : integer := 4;
        din_arith    : integer := xlUnsigned;
        dout_width   : integer := 8;
        dout_bin_pt  : integer := 2;
        dout_arith   : integer := xlUnsigned;
        quantization : integer := xlTruncate;
        overflow     : integer := xlWrap);
    port (
        din : in std_logic_vector (din_width-1 downto 0);
        result : out std_logic_vector (dout_width-1 downto 0));
end convert_func_call;
architecture behavior of convert_func_call is
begin
    result <= convert_type(din, din_width, din_bin_pt, din_arith,
                           dout_width, dout_bin_pt, dout_arith,
                           quantization, overflow);
end behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xlconvert is
    generic (
        din_width    : integer := 16;
        din_bin_pt   : integer := 4;
        din_arith    : integer := xlUnsigned;
        dout_width   : integer := 8;
        dout_bin_pt  : integer := 2;
        dout_arith   : integer := xlUnsigned;
        bool_conversion : integer :=0;
        latency      : integer := 0;
        quantization : integer := xlTruncate;
        overflow     : integer := xlWrap);
    port (
        din : in std_logic_vector (din_width-1 downto 0);
        ce  : in std_logic;
        clr : in std_logic;
        clk : in std_logic;
        dout : out std_logic_vector (dout_width-1 downto 0));
end xlconvert;
architecture behavior of xlconvert is
    component synth_reg
        generic (width       : integer;
                 latency     : integer);
        port (i           : in std_logic_vector(width-1 downto 0);
              ce      : in std_logic;
              clr     : in std_logic;
              clk     : in std_logic;
              o       : out std_logic_vector(width-1 downto 0));
    end component;
    component convert_func_call
        generic (
            din_width    : integer := 16;
            din_bin_pt   : integer := 4;
            din_arith    : integer := xlUnsigned;
            dout_width   : integer := 8;
            dout_bin_pt  : integer := 2;
            dout_arith   : integer := xlUnsigned;
            quantization : integer := xlTruncate;
            overflow     : integer := xlWrap);
        port (
            din : in std_logic_vector (din_width-1 downto 0);
            result : out std_logic_vector (dout_width-1 downto 0));
    end component;
    -- synopsys translate_off
    signal real_din, real_dout : real;
    -- synopsys translate_on
    signal result : std_logic_vector(dout_width-1 downto 0);
begin
    -- synopsys translate_off
    -- synopsys translate_on
    bool_conversion_generate : if (bool_conversion = 1)
    generate
      result <= din;
    end generate;
    std_conversion_generate : if (bool_conversion = 0)
    generate
      convert : convert_func_call
        generic map (
          din_width   => din_width,
          din_bin_pt  => din_bin_pt,
          din_arith   => din_arith,
          dout_width  => dout_width,
          dout_bin_pt => dout_bin_pt,
          dout_arith  => dout_arith,
          quantization => quantization,
          overflow     => overflow)
        port map (
          din => din,
          result => result);
    end generate;
    latency_test : if (latency > 0)
    generate
        reg : synth_reg
            generic map ( width => dout_width,
                          latency => latency)
            port map (i => result,
                      ce => ce,
                      clr => clr,
                      clk => clk,
                      o => dout);
    end generate;
    latency0 : if (latency = 0)
    generate
        dout <= result;
    end generate latency0;
end  behavior;

-------------------------------------------------------------------
-- System Generator version 10.1.3 VHDL source file.
--
-- Copyright(C) 2008 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2008 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xldelay is
   generic(width        : integer := -1;
           latency      : integer := -1;
           reg_retiming : integer := 0);
   port(d       : in std_logic_vector (width-1 downto 0);
        ce      : in std_logic;
        clk     : in std_logic;
        en      : in std_logic;
        q       : out std_logic_vector (width-1 downto 0));
end xldelay;
architecture behavior of xldelay is
   component synth_reg
      generic (width       : integer;
               latency     : integer);
      port (i       : in std_logic_vector(width-1 downto 0);
            ce      : in std_logic;
            clr     : in std_logic;
            clk     : in std_logic;
            o       : out std_logic_vector(width-1 downto 0));
   end component;
   component synth_reg_reg
      generic (width       : integer;
               latency     : integer);
      port (i       : in std_logic_vector(width-1 downto 0);
            ce      : in std_logic;
            clr     : in std_logic;
            clk     : in std_logic;
            o       : out std_logic_vector(width-1 downto 0));
   end component;
   signal internal_ce  : std_logic;
begin
   internal_ce  <= ce and en;
   srl_delay: if (reg_retiming = 0) or (latency < 1) generate
     synth_reg_srl_inst : synth_reg
       generic map (
         width   => width,
         latency => latency)
       port map (
         i   => d,
         ce  => internal_ce,
         clr => '0',
         clk => clk,
         o   => q);
   end generate srl_delay;
   reg_delay: if (reg_retiming = 1) and (latency >= 1) generate
     synth_reg_reg_inst : synth_reg_reg
       generic map (
         width   => width,
         latency => latency)
       port map (
         i   => d,
         ce  => internal_ce,
         clr => '0',
         clk => clk,
         o   => q);
   end generate reg_delay;
end architecture behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity inverter_e5b38cca3b is
  port (
    ip : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end inverter_e5b38cca3b;


architecture behavior of inverter_e5b38cca3b is
  signal ip_1_26: boolean;
  type array_type_op_mem_22_20 is array (0 to (1 - 1)) of boolean;
  signal op_mem_22_20: array_type_op_mem_22_20 := (
    0 => false);
  signal op_mem_22_20_front_din: boolean;
  signal op_mem_22_20_back: boolean;
  signal op_mem_22_20_push_front_pop_back_en: std_logic;
  signal internal_ip_12_1_bitnot: boolean;
begin
  ip_1_26 <= ((ip) = "1");
  op_mem_22_20_back <= op_mem_22_20(0);
  proc_op_mem_22_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_22_20_push_front_pop_back_en = '1')) then
        op_mem_22_20(0) <= op_mem_22_20_front_din;
      end if;
    end if;
  end process proc_op_mem_22_20;
  internal_ip_12_1_bitnot <= ((not boolean_to_vector(ip_1_26)) = "1");
  op_mem_22_20_push_front_pop_back_en <= '0';
  op <= boolean_to_vector(internal_ip_12_1_bitnot);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_80f90b97d0 is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_80f90b97d0;


architecture behavior of logical_80f90b97d0 is
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal fully_2_1_bit: std_logic;
begin
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  fully_2_1_bit <= d0_1_24 and d1_1_27;
  y <= std_logic_to_vector(fully_2_1_bit);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_672d2b8d1e is
  port (
    d : in std_logic_vector((32 - 1) downto 0);
    q : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_672d2b8d1e;


architecture behavior of delay_672d2b8d1e is
  signal d_1_22: std_logic_vector((32 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((32 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "00000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((32 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((32 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_aacf6e1b0e is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_aacf6e1b0e;


architecture behavior of logical_aacf6e1b0e is
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal fully_2_1_bit: std_logic;
begin
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  fully_2_1_bit <= d0_1_24 or d1_1_27;
  y <= std_logic_to_vector(fully_2_1_bit);
end behavior;


-------------------------------------------------------------------
-- System Generator version 10.1.3 VHDL source file.
--
-- Copyright(C) 2008 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2008 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xlregister is
   generic (d_width          : integer := 5;
            init_value       : bit_vector := b"00");
   port (d   : in std_logic_vector (d_width-1 downto 0);
         rst : in std_logic_vector(0 downto 0) := "0";
         en  : in std_logic_vector(0 downto 0) := "1";
         ce  : in std_logic;
         clk : in std_logic;
         q   : out std_logic_vector (d_width-1 downto 0));
end xlregister;
architecture behavior of xlregister is
   component synth_reg_w_init
      generic (width      : integer;
               init_index : integer;
               init_value : bit_vector;
               latency    : integer);
      port (i   : in std_logic_vector(width-1 downto 0);
            ce  : in std_logic;
            clr : in std_logic;
            clk : in std_logic;
            o   : out std_logic_vector(width-1 downto 0));
   end component;
   -- synopsys translate_off
   signal real_d, real_q           : real;
   -- synopsys translate_on
   signal internal_clr             : std_logic;
   signal internal_ce              : std_logic;
begin
   internal_clr <= rst(0) and ce;
   internal_ce  <= en(0) and ce;
   synth_reg_inst : synth_reg_w_init
      generic map (width      => d_width,
                   init_index => 2,
                   init_value => init_value,
                   latency    => 1)
      port map (i   => d,
                ce  => internal_ce,
                clr => internal_clr,
                clk => clk,
                o   => q);
end architecture behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_8782e16b67 is
  port (
    a : in std_logic_vector((32 - 1) downto 0);
    b : in std_logic_vector((32 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_8782e16b67;


architecture behavior of relational_8782e16b67 is
  signal a_1_31: unsigned((32 - 1) downto 0);
  signal b_1_34: unsigned((32 - 1) downto 0);
  signal result_22_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_22_3_rel <= a_1_31 >= b_1_34;
  op <= boolean_to_vector(result_22_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity shift_657b5342cc is
  port (
    ip : in std_logic_vector((32 - 1) downto 0);
    op : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end shift_657b5342cc;


architecture behavior of shift_657b5342cc is
  signal ip_1_23: unsigned((32 - 1) downto 0);
  type array_type_op_mem_46_20 is array (0 to (1 - 1)) of unsigned((32 - 1) downto 0);
  signal op_mem_46_20: array_type_op_mem_46_20 := (
    0 => "00000000000000000000000000000000");
  signal op_mem_46_20_front_din: unsigned((32 - 1) downto 0);
  signal op_mem_46_20_back: unsigned((32 - 1) downto 0);
  signal op_mem_46_20_push_front_pop_back_en: std_logic;
  signal cast_internal_ip_25_3_lsh: unsigned((43 - 1) downto 0);
  signal cast_internal_ip_36_3_convert: unsigned((32 - 1) downto 0);
begin
  ip_1_23 <= std_logic_vector_to_unsigned(ip);
  op_mem_46_20_back <= op_mem_46_20(0);
  proc_op_mem_46_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_46_20_push_front_pop_back_en = '1')) then
        op_mem_46_20(0) <= op_mem_46_20_front_din;
      end if;
    end if;
  end process proc_op_mem_46_20;
  cast_internal_ip_25_3_lsh <= u2u_cast(ip_1_23, 0, 43, 11);
  cast_internal_ip_36_3_convert <= u2u_cast(cast_internal_ip_25_3_lsh, 0, 32, 0);
  op_mem_46_20_push_front_pop_back_en <= '0';
  op <= unsigned_to_std_logic_vector(cast_internal_ip_36_3_convert);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_044fafc0c4 is
  port (
    rst : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_044fafc0c4;


architecture behavior of counter_044fafc0c4 is
  signal rst_1_40: boolean;
  signal count_reg_20_23: unsigned((32 - 1) downto 0) := "00000000000000000000000000000001";
  signal count_reg_20_23_rst: std_logic;
  signal bool_44_4: boolean;
  signal rst_limit_join_44_1: boolean;
  signal count_reg_join_44_1: unsigned((33 - 1) downto 0);
  signal count_reg_join_44_1_rst: std_logic;
begin
  rst_1_40 <= ((rst) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "00000000000000000000000000000001";
      elsif (ce = '1') then 
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("00000000000000000000000000000001");
      end if;
    end if;
  end process proc_count_reg_20_23;
  bool_44_4 <= rst_1_40 or false;
  proc_if_44_1: process (bool_44_4, count_reg_20_23)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= false;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_83e473517e is
  port (
    in0 : in std_logic_vector((1 - 1) downto 0);
    in1 : in std_logic_vector((7 - 1) downto 0);
    y : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_83e473517e;


architecture behavior of concat_83e473517e is
  signal in0_1_23: unsigned((1 - 1) downto 0);
  signal in1_1_27: unsigned((7 - 1) downto 0);
  signal y_2_1_concat: unsigned((8 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity inverter_e2b989a05e is
  port (
    ip : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end inverter_e2b989a05e;


architecture behavior of inverter_e2b989a05e is
  signal ip_1_26: unsigned((1 - 1) downto 0);
  type array_type_op_mem_22_20 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal op_mem_22_20: array_type_op_mem_22_20 := (
    0 => "0");
  signal op_mem_22_20_front_din: unsigned((1 - 1) downto 0);
  signal op_mem_22_20_back: unsigned((1 - 1) downto 0);
  signal op_mem_22_20_push_front_pop_back_en: std_logic;
  signal internal_ip_12_1_bitnot: unsigned((1 - 1) downto 0);
begin
  ip_1_26 <= std_logic_vector_to_unsigned(ip);
  op_mem_22_20_back <= op_mem_22_20(0);
  proc_op_mem_22_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_22_20_push_front_pop_back_en = '1')) then
        op_mem_22_20(0) <= op_mem_22_20_front_din;
      end if;
    end if;
  end process proc_op_mem_22_20;
  internal_ip_12_1_bitnot <= std_logic_vector_to_unsigned(not unsigned_to_std_logic_vector(ip_1_26));
  op_mem_22_20_push_front_pop_back_en <= '0';
  op <= unsigned_to_std_logic_vector(internal_ip_12_1_bitnot);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_4389dc89bf is
  port (
    input_port : in std_logic_vector((8 - 1) downto 0);
    output_port : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_4389dc89bf;


architecture behavior of reinterpret_4389dc89bf is
  signal input_port_1_40: unsigned((8 - 1) downto 0);
  signal output_port_5_5_force: signed((8 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;


-------------------------------------------------------------------
-- System Generator version 10.1.3 VHDL source file.
--
-- Copyright(C) 2008 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2008 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use work.conv_pkg.all;
entity xlslice is
    generic (
        new_msb      : integer := 9;
        new_lsb      : integer := 1;
        x_width      : integer := 16;
        y_width      : integer := 8);
    port (
        x : in std_logic_vector (x_width-1 downto 0);
        y : out std_logic_vector (y_width-1 downto 0));
end xlslice;
architecture behavior of xlslice is
begin
    y <= x(new_msb downto new_lsb);
end  behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_ea71bb555c is
  port (
    input_port : in std_logic_vector((17 - 1) downto 0);
    output_port : out std_logic_vector((17 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_ea71bb555c;


architecture behavior of reinterpret_ea71bb555c is
  signal input_port_1_40: unsigned((17 - 1) downto 0);
  signal output_port_5_5_force: signed((17 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_f2f6490a28 is
  port (
    in0 : in std_logic_vector((9 - 1) downto 0);
    in1 : in std_logic_vector((9 - 1) downto 0);
    y : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_f2f6490a28;


architecture behavior of concat_f2f6490a28 is
  signal in0_1_23: unsigned((9 - 1) downto 0);
  signal in1_1_27: unsigned((9 - 1) downto 0);
  signal y_2_1_concat: unsigned((18 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_de38ef9df5 is
  port (
    input_port : in std_logic_vector((9 - 1) downto 0);
    output_port : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_de38ef9df5;


architecture behavior of reinterpret_de38ef9df5 is
  signal input_port_1_40: signed((9 - 1) downto 0);
  signal output_port_5_5_force: unsigned((9 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;


-------------------------------------------------------------------
-- System Generator version 10.1.3 VHDL source file.
--
-- Copyright(C) 2008 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2008 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity convert_pipeline is
    generic (
        old_width   : integer := 16;
        old_bin_pt  : integer := 4;
        old_arith   : integer := xlUnsigned;
        new_width   : integer := 8;
        new_bin_pt  : integer := 2;
        new_arith   : integer := xlUnsigned;
        quantization : integer := xlTruncate;
        overflow    : integer := xlWrap;
        latency     : integer := 1);
    port (
        din : in std_logic_vector (old_width-1 downto 0);
        ce  : in std_logic;
        clr : in std_logic;
        clk : in std_logic;
        result : out std_logic_vector (new_width-1 downto 0));
end convert_pipeline;
architecture behavior of convert_pipeline is
    component synth_reg
        generic (width       : integer;
                 latency     : integer);
        port (i           : in std_logic_vector(width-1 downto 0);
              ce      : in std_logic;
              clr     : in std_logic;
              clk     : in std_logic;
              o       : out std_logic_vector(width-1 downto 0));
    end component;
    constant fp_width : integer := old_width + 2;
    constant fp_bin_pt : integer := old_bin_pt;
    constant fp_arith : integer := old_arith;
    constant q_width : integer := (old_width + 2) + (new_bin_pt - old_bin_pt);
    constant q_bin_pt : integer := new_bin_pt;
    constant q_arith : integer := old_arith;
    signal full_precision_result_in, full_precision_result_out
        : std_logic_vector(fp_width-1 downto 0);
    signal quantized_result_in, quantized_result_out
        : std_logic_vector(q_width-1 downto 0);
    signal result_in : std_logic_vector(new_width-1 downto 0):= (others => '0');
begin
    fp_result : process (din)
    begin
        full_precision_result_in <= cast(din, old_bin_pt,
                                         fp_width, fp_bin_pt, fp_arith);
    end process;
    latency_fpr : if (latency > 2)
    generate
        reg_fpr : synth_reg
            generic map ( width => fp_width,
                          latency => 1)
            port map (i => full_precision_result_in,
                      ce => ce,
                      clr => clr,
                      clk => clk,
                      o => full_precision_result_out);
    end generate;
    no_latency_fpr : if (latency < 3)
    generate
        full_precision_result_out <= full_precision_result_in;
    end generate;
    xlround_generate : if (quantization = xlRound)
    generate
      xlround_result : process (full_precision_result_out)
      begin
          quantized_result_in <= round_towards_inf(full_precision_result_out,
                                                   fp_width, fp_bin_pt,
                                                   fp_arith, q_width, q_bin_pt,
                                                   q_arith);
      end process;
    end generate;
    xlroundbanker_generate : if (quantization = xlRoundBanker)
    generate
      xlroundbanker_result : process (full_precision_result_out)
      begin
          quantized_result_in <= round_towards_even(full_precision_result_out,
                                                   fp_width, fp_bin_pt,
                                                   fp_arith, q_width, q_bin_pt,
                                                   q_arith);
      end process;
    end generate;
    xltruncate_generate : if (quantization = xlTruncate)
    generate
      xltruncate_result : process (full_precision_result_out)
      begin
          quantized_result_in <= trunc(full_precision_result_out,
                                       fp_width, fp_bin_pt,
                                       fp_arith, q_width, q_bin_pt,
                                       q_arith);
      end process;
    end generate;
    latency_qr : if (latency > 1)
    generate
        reg_qr : synth_reg
            generic map ( width => q_width,
                          latency => 1)
            port map (i => quantized_result_in,
                      ce => ce,
                      clr => clr,
                      clk => clk,
                      o => quantized_result_out);
    end generate;
    no_latency_qr : if (latency < 2)
    generate
        quantized_result_out <= quantized_result_in;
    end generate;
    xlsaturate_generate : if (overflow = xlSaturate)
    generate
      xlsaturate_result : process (quantized_result_out)
      begin
          result_in <= saturation_arith(quantized_result_out, q_width, q_bin_pt,
                                       q_arith, new_width, new_bin_pt, new_arith);
      end process;
    end generate;
    xlwrap_generate : if (overflow = xlWrap)
    generate
      xlwrap_result : process (quantized_result_out)
      begin
          result_in <= wrap_arith(quantized_result_out, q_width, q_bin_pt,
                                  q_arith, new_width, new_bin_pt, new_arith);
      end process;
    end generate;
    latency_gt_3 : if (latency > 3)
    generate
        reg_out : synth_reg
            generic map ( width => new_width,
                          latency => latency-2)
            port map (i => result_in,
                      ce => ce,
                      clr => clr,
                      clk => clk,
                      o => result);
    end generate;
    latency_lt_4 : if ((latency < 4) and (latency > 0))
    generate
        reg_out : synth_reg
            generic map ( width => new_width,
                          latency => 1)
            port map (i => result_in,
                      ce => ce,
                      clr => clr,
                      clk => clk,
                      o => result);
    end generate;
    latency0 : if (latency = 0)
    generate
        result <= result_in;
    end generate latency0;
end behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xlconvert_pipeline is
    generic (
        din_width    : integer := 16;
        din_bin_pt   : integer := 4;
        din_arith    : integer := xlUnsigned;
        dout_width   : integer := 8;
        dout_bin_pt  : integer := 2;
        dout_arith   : integer := xlUnsigned;
        bool_conversion : integer :=0;
        latency      : integer := 0;
        quantization : integer := xlTruncate;
        overflow     : integer := xlWrap);
    port (
        din : in std_logic_vector (din_width-1 downto 0);
        ce  : in std_logic;
        clr : in std_logic;
        clk : in std_logic;
        dout : out std_logic_vector (dout_width-1 downto 0));
end xlconvert_pipeline;
architecture behavior of xlconvert_pipeline is
    component convert_pipeline
        generic (
            old_width    : integer := 16;
            old_bin_pt   : integer := 4;
            old_arith    : integer := xlUnsigned;
            new_width   : integer := 8;
            new_bin_pt  : integer := 2;
            new_arith   : integer := xlUnsigned;
            quantization : integer := xlTruncate;
            overflow     : integer := xlWrap;
            latency : integer := 1);
        port (
            din : in std_logic_vector (din_width-1 downto 0);
            ce      : in std_logic;
            clr     : in std_logic;
            clk     : in std_logic;
            result : out std_logic_vector (dout_width-1 downto 0));
    end component;
   begin
      convert : convert_pipeline
        generic map (
          old_width   => din_width,
          old_bin_pt  => din_bin_pt,
          old_arith   => din_arith,
          new_width  => dout_width,
          new_bin_pt => dout_bin_pt,
          new_arith  => dout_arith,
          quantization => quantization,
          overflow     => overflow,
          latency => latency)
        port map (
          din => din,
          ce => ce,
          clr => clr,
          clk => clk,
          result => dout);
end  behavior;

-------------------------------------------------------------------
-- System Generator version 10.1.3 VHDL source file.
--
-- Copyright(C) 2008 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2008 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library XilinxCoreLib;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;
entity xlcounter_limit is
  generic (
    core_name0: string := "";
    op_width: integer := 5;
    op_arith: integer := xlSigned;
    cnt_63_48: integer:= 0;
    cnt_47_32: integer:= 0;
    cnt_31_16: integer:= 0;
    cnt_15_0: integer:= 0;
    count_limited: integer := 0
  );
  port (
    ce: in std_logic;
    clr: in std_logic;
    clk: in std_logic;
    op: out std_logic_vector(op_width - 1 downto 0);
    up: in std_logic_vector(0 downto 0) := (others => '0');
    en: in std_logic_vector(0 downto 0);
    rst: in std_logic_vector(0 downto 0)
  );
end xlcounter_limit ;
architecture behavior of xlcounter_limit is
  signal high_cnt_to: std_logic_vector(31 downto 0);
  signal low_cnt_to: std_logic_vector(31 downto 0);
  signal cnt_to: std_logic_vector(63 downto 0);
  signal core_sinit, op_thresh0, core_ce: std_logic;
  signal rst_overrides_en: std_logic;
  signal op_net: std_logic_vector(op_width - 1 downto 0);
  -- synopsys translate_off
  signal real_op : real;
   -- synopsys translate_on
  function equals(op, cnt_to : std_logic_vector; width, arith : integer)
    return std_logic
  is
    variable signed_op, signed_cnt_to : signed (width - 1 downto 0);
    variable unsigned_op, unsigned_cnt_to : unsigned (width - 1 downto 0);
    variable result : std_logic;
  begin
    -- synopsys translate_off
    if ((is_XorU(op)) or (is_XorU(cnt_to)) ) then
      result := '0';
      return result;
    end if;
    -- synopsys translate_on
    if (op = cnt_to) then
      result := '1';
    else
      result := '0';
    end if;
    return result;
  end;
  component binary_counter_virtex5_10_0_1ee993c8ed57b9ce
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_1ee993c8ed57b9ce:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_1ee993c8ed57b9ce:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_1ee993c8ed57b9ce:
    component  is "black_box";
  component binary_counter_virtex5_10_0_01e34ae12479a5e1
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_01e34ae12479a5e1:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_01e34ae12479a5e1:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_01e34ae12479a5e1:
    component  is "black_box";
  component binary_counter_virtex5_10_0_1c25d2b550c5fffc
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_1c25d2b550c5fffc:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_1c25d2b550c5fffc:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_1c25d2b550c5fffc:
    component  is "black_box";
  component binary_counter_virtex5_10_0_fe346e03af2452eb
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_fe346e03af2452eb:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_fe346e03af2452eb:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_fe346e03af2452eb:
    component  is "black_box";
  component binary_counter_virtex5_10_0_722dc5ef3883365e
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_722dc5ef3883365e:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_722dc5ef3883365e:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_722dc5ef3883365e:
    component  is "black_box";
-- synopsys translate_off
  constant zeroVec : std_logic_vector(op_width - 1 downto 0) := (others => '0');
  constant oneVec : std_logic_vector(op_width - 1 downto 0) := (others => '1');
  constant zeroStr : string(1 to op_width) :=
    std_logic_vector_to_bin_string(zeroVec);
  constant oneStr : string(1 to op_width) :=
    std_logic_vector_to_bin_string(oneVec);
-- synopsys translate_on
begin
  -- synopsys translate_off
  -- synopsys translate_on
  cnt_to(63 downto 48) <= integer_to_std_logic_vector(cnt_63_48, 16, op_arith);
  cnt_to(47 downto 32) <= integer_to_std_logic_vector(cnt_47_32, 16, op_arith);
  cnt_to(31 downto 16) <= integer_to_std_logic_vector(cnt_31_16, 16, op_arith);
  cnt_to(15 downto 0) <= integer_to_std_logic_vector(cnt_15_0, 16, op_arith);
  op <= op_net;
  core_ce <= ce and en(0);
  rst_overrides_en <= rst(0) or en(0);
  limit : if (count_limited = 1) generate
    eq_cnt_to : process (op_net, cnt_to)
    begin
      op_thresh0 <= equals(op_net, cnt_to(op_width - 1 downto 0),
                     op_width, op_arith);
    end process;
    core_sinit <= (op_thresh0 or clr or rst(0)) and ce and rst_overrides_en;
  end generate;
  no_limit : if (count_limited = 0) generate
    core_sinit <= (clr or rst(0)) and ce and rst_overrides_en;
  end generate;
  comp0: if ((core_name0 = "binary_counter_virtex5_10_0_1ee993c8ed57b9ce")) generate
    core_instance0: binary_counter_virtex5_10_0_1ee993c8ed57b9ce
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
  comp2: if ((core_name0 = "binary_counter_virtex5_10_0_01e34ae12479a5e1")) generate
    core_instance2: binary_counter_virtex5_10_0_01e34ae12479a5e1
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
  comp3: if ((core_name0 = "binary_counter_virtex5_10_0_1c25d2b550c5fffc")) generate
    core_instance3: binary_counter_virtex5_10_0_1c25d2b550c5fffc
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
  comp4: if ((core_name0 = "binary_counter_virtex5_10_0_fe346e03af2452eb")) generate
    core_instance4: binary_counter_virtex5_10_0_fe346e03af2452eb
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
  comp5: if ((core_name0 = "binary_counter_virtex5_10_0_722dc5ef3883365e")) generate
    core_instance5: binary_counter_virtex5_10_0_722dc5ef3883365e
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
end  behavior;

-------------------------------------------------------------------
-- System Generator version 10.1.3 VHDL source file.
--
-- Copyright(C) 2008 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2008 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use work.conv_pkg.all;
entity xlsprom is
  generic (
    core_name0: string := "";
    c_width: integer := 12;
    c_address_width: integer := 4;
    latency: integer := 1
  );
  port (
    addr: in std_logic_vector(c_address_width - 1 downto 0);
    en: in std_logic_vector(0 downto 0);
    rst: in std_logic_vector(0 downto 0);
    ce: in std_logic;
    clk: in std_logic;
    data: out std_logic_vector(c_width - 1 downto 0)
  );
end xlsprom ;
architecture behavior of xlsprom is
  component synth_reg
    generic (
      width: integer;
      latency: integer
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;
  signal core_addr: std_logic_vector(c_address_width - 1 downto 0);
  signal core_data_out: std_logic_vector(c_width - 1 downto 0);
  signal core_ce, sinit: std_logic;
  component bmg_24_vx5_916edb207080a9d0
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_916edb207080a9d0:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_916edb207080a9d0:
    component is "true";
  attribute box_type of bmg_24_vx5_916edb207080a9d0:
    component  is "black_box";
  component bmg_24_vx5_17f5cef47a567d97
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_17f5cef47a567d97:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_17f5cef47a567d97:
    component is "true";
  attribute box_type of bmg_24_vx5_17f5cef47a567d97:
    component  is "black_box";
  component bmg_24_vx5_22468d6827fd0e85
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_22468d6827fd0e85:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_22468d6827fd0e85:
    component is "true";
  attribute box_type of bmg_24_vx5_22468d6827fd0e85:
    component  is "black_box";
  component bmg_24_vx5_2c89c45c28fef7b6
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_2c89c45c28fef7b6:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_2c89c45c28fef7b6:
    component is "true";
  attribute box_type of bmg_24_vx5_2c89c45c28fef7b6:
    component  is "black_box";
  component bmg_24_vx5_7bc1e03f2e4955ca
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_7bc1e03f2e4955ca:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_7bc1e03f2e4955ca:
    component is "true";
  attribute box_type of bmg_24_vx5_7bc1e03f2e4955ca:
    component  is "black_box";
  component bmg_24_vx5_8259598782c619da
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_8259598782c619da:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_8259598782c619da:
    component is "true";
  attribute box_type of bmg_24_vx5_8259598782c619da:
    component  is "black_box";
  component bmg_24_vx5_e356d8b9149f54d5
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_e356d8b9149f54d5:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_e356d8b9149f54d5:
    component is "true";
  attribute box_type of bmg_24_vx5_e356d8b9149f54d5:
    component  is "black_box";
  component bmg_24_vx5_c5c136a08dd56dbc
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_c5c136a08dd56dbc:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_c5c136a08dd56dbc:
    component is "true";
  attribute box_type of bmg_24_vx5_c5c136a08dd56dbc:
    component  is "black_box";
  component bmg_24_vx5_9d8577c93c4baa0d
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_9d8577c93c4baa0d:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_9d8577c93c4baa0d:
    component is "true";
  attribute box_type of bmg_24_vx5_9d8577c93c4baa0d:
    component  is "black_box";
  component bmg_24_vx5_462f2ec6a7a3f012
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_462f2ec6a7a3f012:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_462f2ec6a7a3f012:
    component is "true";
  attribute box_type of bmg_24_vx5_462f2ec6a7a3f012:
    component  is "black_box";
  component bmg_24_vx5_cee1e5321fc14302
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_cee1e5321fc14302:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_cee1e5321fc14302:
    component is "true";
  attribute box_type of bmg_24_vx5_cee1e5321fc14302:
    component  is "black_box";
  component bmg_24_vx5_2c49e6ef11a51d10
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_2c49e6ef11a51d10:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_2c49e6ef11a51d10:
    component is "true";
  attribute box_type of bmg_24_vx5_2c49e6ef11a51d10:
    component  is "black_box";
begin
  core_addr <= addr;
  core_ce <= ce and en(0);
  sinit <= rst(0) and ce;
  comp0: if ((core_name0 = "bmg_24_vx5_916edb207080a9d0")) generate
    core_instance0: bmg_24_vx5_916edb207080a9d0
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp1: if ((core_name0 = "bmg_24_vx5_17f5cef47a567d97")) generate
    core_instance1: bmg_24_vx5_17f5cef47a567d97
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp2: if ((core_name0 = "bmg_24_vx5_22468d6827fd0e85")) generate
    core_instance2: bmg_24_vx5_22468d6827fd0e85
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp3: if ((core_name0 = "bmg_24_vx5_2c89c45c28fef7b6")) generate
    core_instance3: bmg_24_vx5_2c89c45c28fef7b6
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp4: if ((core_name0 = "bmg_24_vx5_7bc1e03f2e4955ca")) generate
    core_instance4: bmg_24_vx5_7bc1e03f2e4955ca
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp5: if ((core_name0 = "bmg_24_vx5_8259598782c619da")) generate
    core_instance5: bmg_24_vx5_8259598782c619da
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp6: if ((core_name0 = "bmg_24_vx5_e356d8b9149f54d5")) generate
    core_instance6: bmg_24_vx5_e356d8b9149f54d5
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp7: if ((core_name0 = "bmg_24_vx5_c5c136a08dd56dbc")) generate
    core_instance7: bmg_24_vx5_c5c136a08dd56dbc
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp8: if ((core_name0 = "bmg_24_vx5_9d8577c93c4baa0d")) generate
    core_instance8: bmg_24_vx5_9d8577c93c4baa0d
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp9: if ((core_name0 = "bmg_24_vx5_462f2ec6a7a3f012")) generate
    core_instance9: bmg_24_vx5_462f2ec6a7a3f012
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp10: if ((core_name0 = "bmg_24_vx5_cee1e5321fc14302")) generate
    core_instance10: bmg_24_vx5_cee1e5321fc14302
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  comp11: if ((core_name0 = "bmg_24_vx5_2c49e6ef11a51d10")) generate
    core_instance11: bmg_24_vx5_2c49e6ef11a51d10
      port map (
        addra => core_addr,
        clka => clk,
        ena => core_ce,
        douta => core_data_out
                        );
  end generate;
  latency_test: if (latency > 1) generate
    reg: synth_reg
      generic map (
        width => c_width,
        latency => latency - 1
      )
      port map (
        i => core_data_out,
        ce => core_ce,
        clr => '0',
        clk => clk,
        o => data
      );
  end generate;
  latency_1: if (latency <= 1) generate
    data <= core_data_out;
  end generate;
end  behavior;

-------------------------------------------------------------------
-- System Generator version 10.1.3 VHDL source file.
--
-- Copyright(C) 2008 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2008 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library XilinxCoreLib;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use work.conv_pkg.all;
entity xlmult_v9_0 is
  generic (
    core_name0: string := "";
    a_width: integer := 4;
    a_bin_pt: integer := 2;
    a_arith: integer := xlSigned;
    b_width: integer := 4;
    b_bin_pt: integer := 1;
    b_arith: integer := xlSigned;
    p_width: integer := 8;
    p_bin_pt: integer := 2;
    p_arith: integer := xlSigned;
    rst_width: integer := 1;
    rst_bin_pt: integer := 0;
    rst_arith: integer := xlUnsigned;
    en_width: integer := 1;
    en_bin_pt: integer := 0;
    en_arith: integer := xlUnsigned;
    quantization: integer := xlTruncate;
    overflow: integer := xlWrap;
    extra_registers: integer := 0;
    c_a_width: integer := 7;
    c_b_width: integer := 7;
    c_type: integer := 0;
    c_a_type: integer := 0;
    c_b_type: integer := 0;
    c_pipelined: integer := 1;
    c_baat: integer := 4;
    multsign: integer := xlSigned;
    c_output_width: integer := 16
  );
  port (
    a: in std_logic_vector(a_width - 1 downto 0);
    b: in std_logic_vector(b_width - 1 downto 0);
    ce: in std_logic;
    clr: in std_logic;
    clk: in std_logic;
    core_ce: in std_logic := '0';
    core_clr: in std_logic := '0';
    core_clk: in std_logic := '0';
    rst: in std_logic_vector(rst_width - 1 downto 0);
    en: in std_logic_vector(en_width - 1 downto 0);
    p: out std_logic_vector(p_width - 1 downto 0)
  );
end xlmult_v9_0 ;
architecture behavior of xlmult_v9_0 is
  component synth_reg
    generic (
      width: integer := 16;
      latency: integer := 5
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;
  component multiplier_virtex5_10_1_2f77ace24e40581e
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of multiplier_virtex5_10_1_2f77ace24e40581e:
    component is true;
  attribute fpga_dont_touch of multiplier_virtex5_10_1_2f77ace24e40581e:
    component is "true";
  attribute box_type of multiplier_virtex5_10_1_2f77ace24e40581e:
    component  is "black_box";
  component multiplier_virtex5_10_1_b0c844385805a270
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of multiplier_virtex5_10_1_b0c844385805a270:
    component is true;
  attribute fpga_dont_touch of multiplier_virtex5_10_1_b0c844385805a270:
    component is "true";
  attribute box_type of multiplier_virtex5_10_1_b0c844385805a270:
    component  is "black_box";
  component multiplier_virtex5_10_1_c90585d1a7e9d3a6
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of multiplier_virtex5_10_1_c90585d1a7e9d3a6:
    component is true;
  attribute fpga_dont_touch of multiplier_virtex5_10_1_c90585d1a7e9d3a6:
    component is "true";
  attribute box_type of multiplier_virtex5_10_1_c90585d1a7e9d3a6:
    component  is "black_box";
  component multiplier_virtex5_10_1_845caa9bc89072e0
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of multiplier_virtex5_10_1_845caa9bc89072e0:
    component is true;
  attribute fpga_dont_touch of multiplier_virtex5_10_1_845caa9bc89072e0:
    component is "true";
  attribute box_type of multiplier_virtex5_10_1_845caa9bc89072e0:
    component  is "black_box";
  component multiplier_virtex5_10_1_35568d5aa6a70475
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of multiplier_virtex5_10_1_35568d5aa6a70475:
    component is true;
  attribute fpga_dont_touch of multiplier_virtex5_10_1_35568d5aa6a70475:
    component is "true";
  attribute box_type of multiplier_virtex5_10_1_35568d5aa6a70475:
    component  is "black_box";
  component multiplier_virtex5_10_1_9a2572cfdd818f42
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of multiplier_virtex5_10_1_9a2572cfdd818f42:
    component is true;
  attribute fpga_dont_touch of multiplier_virtex5_10_1_9a2572cfdd818f42:
    component is "true";
  attribute box_type of multiplier_virtex5_10_1_9a2572cfdd818f42:
    component  is "black_box";
  component multiplier_virtex5_10_1_e96fd0f2d7a7d0c5
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of multiplier_virtex5_10_1_e96fd0f2d7a7d0c5:
    component is true;
  attribute fpga_dont_touch of multiplier_virtex5_10_1_e96fd0f2d7a7d0c5:
    component is "true";
  attribute box_type of multiplier_virtex5_10_1_e96fd0f2d7a7d0c5:
    component  is "black_box";
  component multiplier_virtex5_10_1_db7246963acedc92
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of multiplier_virtex5_10_1_db7246963acedc92:
    component is true;
  attribute fpga_dont_touch of multiplier_virtex5_10_1_db7246963acedc92:
    component is "true";
  attribute box_type of multiplier_virtex5_10_1_db7246963acedc92:
    component  is "black_box";
  component multiplier_virtex5_10_1_34b4d3fe22ca9845
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of multiplier_virtex5_10_1_34b4d3fe22ca9845:
    component is true;
  attribute fpga_dont_touch of multiplier_virtex5_10_1_34b4d3fe22ca9845:
    component is "true";
  attribute box_type of multiplier_virtex5_10_1_34b4d3fe22ca9845:
    component  is "black_box";
  component multiplier_virtex5_10_1_36b8f4cb731cc5b3
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of multiplier_virtex5_10_1_36b8f4cb731cc5b3:
    component is true;
  attribute fpga_dont_touch of multiplier_virtex5_10_1_36b8f4cb731cc5b3:
    component is "true";
  attribute box_type of multiplier_virtex5_10_1_36b8f4cb731cc5b3:
    component  is "black_box";
  signal tmp_a: std_logic_vector(c_a_width - 1 downto 0);
  signal conv_a: std_logic_vector(c_a_width - 1 downto 0);
  signal tmp_b: std_logic_vector(c_b_width - 1 downto 0);
  signal conv_b: std_logic_vector(c_b_width - 1 downto 0);
  signal tmp_p: std_logic_vector(c_output_width - 1 downto 0);
  signal conv_p: std_logic_vector(p_width - 1 downto 0);
  -- synopsys translate_off
  signal real_a, real_b, real_p: real;
  -- synopsys translate_on
  signal rfd: std_logic;
  signal rdy: std_logic;
  signal nd: std_logic;
  signal internal_ce: std_logic;
  signal internal_clr: std_logic;
  signal internal_core_ce: std_logic;
begin
-- synopsys translate_off
-- synopsys translate_on
  internal_ce <= ce and en(0);
  internal_core_ce <= core_ce and en(0);
  internal_clr <= (clr or rst(0)) and ce;
  nd <= internal_ce;
  input_process:  process (a,b)
  begin
    tmp_a <= zero_ext(a, c_a_width);
    tmp_b <= zero_ext(b, c_b_width);
  end process;
  output_process: process (tmp_p)
  begin
    conv_p <= convert_type(tmp_p, c_output_width, a_bin_pt+b_bin_pt, multsign,
                           p_width, p_bin_pt, p_arith, quantization, overflow);
  end process;
  comp0: if ((core_name0 = "multiplier_virtex5_10_1_2f77ace24e40581e")) generate
    core_instance0: multiplier_virtex5_10_1_2f77ace24e40581e
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  comp1: if ((core_name0 = "multiplier_virtex5_10_1_b0c844385805a270")) generate
    core_instance1: multiplier_virtex5_10_1_b0c844385805a270
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  comp2: if ((core_name0 = "multiplier_virtex5_10_1_c90585d1a7e9d3a6")) generate
    core_instance2: multiplier_virtex5_10_1_c90585d1a7e9d3a6
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  comp3: if ((core_name0 = "multiplier_virtex5_10_1_845caa9bc89072e0")) generate
    core_instance3: multiplier_virtex5_10_1_845caa9bc89072e0
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  comp4: if ((core_name0 = "multiplier_virtex5_10_1_35568d5aa6a70475")) generate
    core_instance4: multiplier_virtex5_10_1_35568d5aa6a70475
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  comp5: if ((core_name0 = "multiplier_virtex5_10_1_9a2572cfdd818f42")) generate
    core_instance5: multiplier_virtex5_10_1_9a2572cfdd818f42
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  comp6: if ((core_name0 = "multiplier_virtex5_10_1_e96fd0f2d7a7d0c5")) generate
    core_instance6: multiplier_virtex5_10_1_e96fd0f2d7a7d0c5
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  comp7: if ((core_name0 = "multiplier_virtex5_10_1_db7246963acedc92")) generate
    core_instance7: multiplier_virtex5_10_1_db7246963acedc92
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  comp8: if ((core_name0 = "multiplier_virtex5_10_1_34b4d3fe22ca9845")) generate
    core_instance8: multiplier_virtex5_10_1_34b4d3fe22ca9845
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  comp9: if ((core_name0 = "multiplier_virtex5_10_1_36b8f4cb731cc5b3")) generate
    core_instance9: multiplier_virtex5_10_1_36b8f4cb731cc5b3
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  latency_gt_0: if (extra_registers > 0) generate
    reg: synth_reg
      generic map (
        width => p_width,
        latency => extra_registers
      )
      port map (
        i => conv_p,
        ce => internal_ce,
        clr => internal_clr,
        clk => clk,
        o => p
      );
  end generate;
  latency_eq_0: if (extra_registers = 0) generate
    p <= conv_p;
  end generate;
end architecture behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_25b7e1d1f5 is
  port (
    in0 : in std_logic_vector((17 - 1) downto 0);
    in1 : in std_logic_vector((17 - 1) downto 0);
    y : out std_logic_vector((34 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_25b7e1d1f5;


architecture behavior of concat_25b7e1d1f5 is
  signal in0_1_23: unsigned((17 - 1) downto 0);
  signal in1_1_27: unsigned((17 - 1) downto 0);
  signal y_2_1_concat: unsigned((34 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_573890e1c0 is
  port (
    input_port : in std_logic_vector((17 - 1) downto 0);
    output_port : out std_logic_vector((17 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_573890e1c0;


architecture behavior of reinterpret_573890e1c0 is
  signal input_port_1_40: signed((17 - 1) downto 0);
  signal output_port_5_5_force: unsigned((17 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_6293007044 is
  port (
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_6293007044;


architecture behavior of constant_6293007044 is
begin
  op <= "1";
end behavior;


-------------------------------------------------------------------
-- System Generator version 10.1.3 VHDL source file.
--
-- Copyright(C) 2008 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2008 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xlspram is
  generic (
    core_name0: string := "";
    c_width: integer := 12;
    c_address_width: integer := 4;
    latency: integer := 1
    );
  port (
    data_in: in std_logic_vector(c_width - 1 downto 0);
    addr: in std_logic_vector(c_address_width - 1 downto 0);
    we: in std_logic_vector(0 downto 0);
    en: in std_logic_vector(0 downto 0);
    rst: in std_logic_vector(0 downto 0);
    ce: in std_logic;
    clk: in std_logic;
    data_out: out std_logic_vector(c_width - 1 downto 0)
  );
end xlspram ;
architecture behavior of xlspram is
  component synth_reg
    generic (
      width: integer;
      latency: integer
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;
  signal core_data_out, dly_data_out: std_logic_vector(c_width - 1 downto 0);
  signal core_we, core_ce, sinit: std_logic;
  component bmg_24_vx5_b3a285035a3712ee
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_b3a285035a3712ee:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_b3a285035a3712ee:
    component is "true";
  attribute box_type of bmg_24_vx5_b3a285035a3712ee:
    component  is "black_box";
  component bmg_24_vx5_cd3584ee10cade7e
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_cd3584ee10cade7e:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_cd3584ee10cade7e:
    component is "true";
  attribute box_type of bmg_24_vx5_cd3584ee10cade7e:
    component  is "black_box";
  component bmg_24_vx5_941504d2ced01311
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_941504d2ced01311:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_941504d2ced01311:
    component is "true";
  attribute box_type of bmg_24_vx5_941504d2ced01311:
    component  is "black_box";
  component bmg_24_vx5_b56a7cdaabc490ac
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_b56a7cdaabc490ac:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_b56a7cdaabc490ac:
    component is "true";
  attribute box_type of bmg_24_vx5_b56a7cdaabc490ac:
    component  is "black_box";
  component bmg_24_vx5_0206823b131149d8
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_0206823b131149d8:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_0206823b131149d8:
    component is "true";
  attribute box_type of bmg_24_vx5_0206823b131149d8:
    component  is "black_box";
  component bmg_24_vx5_94232660d90f6688
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_94232660d90f6688:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_94232660d90f6688:
    component is "true";
  attribute box_type of bmg_24_vx5_94232660d90f6688:
    component  is "black_box";
  component bmg_24_vx5_491b66ad487fb1cf
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_491b66ad487fb1cf:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_491b66ad487fb1cf:
    component is "true";
  attribute box_type of bmg_24_vx5_491b66ad487fb1cf:
    component  is "black_box";
  component bmg_24_vx5_6f3d016421754f60
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of bmg_24_vx5_6f3d016421754f60:
    component is true;
  attribute fpga_dont_touch of bmg_24_vx5_6f3d016421754f60:
    component is "true";
  attribute box_type of bmg_24_vx5_6f3d016421754f60:
    component  is "black_box";
begin
  data_out <= dly_data_out;
  core_we <= we(0);
  core_ce <= ce and en(0);
  sinit <= rst(0) and ce;
  comp0: if ((core_name0 = "bmg_24_vx5_b3a285035a3712ee")) generate
    core_instance0: bmg_24_vx5_b3a285035a3712ee
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp1: if ((core_name0 = "bmg_24_vx5_cd3584ee10cade7e")) generate
    core_instance1: bmg_24_vx5_cd3584ee10cade7e
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp2: if ((core_name0 = "bmg_24_vx5_941504d2ced01311")) generate
    core_instance2: bmg_24_vx5_941504d2ced01311
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp3: if ((core_name0 = "bmg_24_vx5_b56a7cdaabc490ac")) generate
    core_instance3: bmg_24_vx5_b56a7cdaabc490ac
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp4: if ((core_name0 = "bmg_24_vx5_0206823b131149d8")) generate
    core_instance4: bmg_24_vx5_0206823b131149d8
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp5: if ((core_name0 = "bmg_24_vx5_94232660d90f6688")) generate
    core_instance5: bmg_24_vx5_94232660d90f6688
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp6: if ((core_name0 = "bmg_24_vx5_491b66ad487fb1cf")) generate
    core_instance6: bmg_24_vx5_491b66ad487fb1cf
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp7: if ((core_name0 = "bmg_24_vx5_6f3d016421754f60")) generate
    core_instance7: bmg_24_vx5_6f3d016421754f60
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  latency_test: if (latency > 1) generate
    reg: synth_reg
      generic map (
        width => c_width,
        latency => latency - 1
      )
      port map (
        i => core_data_out,
        ce => core_ce,
        clr => '0',
        clk => clk,
        o => dly_data_out
      );
  end generate;
  latency_1: if (latency <= 1) generate
    dly_data_out <= core_data_out;
  end generate;
end behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_bfd97cd167 is
  port (
    a : in std_logic_vector((17 - 1) downto 0);
    b : in std_logic_vector((17 - 1) downto 0);
    s : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_bfd97cd167;


architecture behavior of addsub_bfd97cd167 is
  signal a_17_32: signed((17 - 1) downto 0);
  signal b_17_35: signed((17 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((18 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "000000000000000000");
  signal op_mem_91_20_front_din: signed((18 - 1) downto 0);
  signal op_mem_91_20_back: signed((18 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((18 - 1) downto 0);
  signal cast_69_22: signed((18 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((18 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 15, 18, 15);
  cast_69_22 <= s2s_cast(b_17_35, 15, 18, 15);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_2ae71e3b73 is
  port (
    op : out std_logic_vector((25 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_2ae71e3b73;


architecture behavior of constant_2ae71e3b73 is
begin
  op <= "1000000000000000000000000";
end behavior;


-------------------------------------------------------------------
-- System Generator version 10.1.3 VHDL source file.
--
-- Copyright(C) 2008 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2008 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library XilinxCoreLib;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xlcounter_free is
  generic (
    core_name0: string := "";
    op_width: integer := 5;
    op_arith: integer := xlSigned
  );
  port (
    ce: in std_logic;
    clr: in std_logic;
    clk: in std_logic;
    op: out std_logic_vector(op_width - 1 downto 0);
    up: in std_logic_vector(0 downto 0) := (others => '0');
    load: in std_logic_vector(0 downto 0) := (others => '0');
    din: in std_logic_vector(op_width - 1 downto 0) := (others => '0');
    en: in std_logic_vector(0 downto 0);
    rst: in std_logic_vector(0 downto 0)
  );
end xlcounter_free ;
architecture behavior of xlcounter_free is
  component binary_counter_virtex5_10_0_092422ed79c7db12
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_092422ed79c7db12:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_092422ed79c7db12:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_092422ed79c7db12:
    component  is "black_box";
  component binary_counter_virtex5_10_0_01e34ae12479a5e1
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_01e34ae12479a5e1:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_01e34ae12479a5e1:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_01e34ae12479a5e1:
    component  is "black_box";
  component binary_counter_virtex5_10_0_1c25d2b550c5fffc
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_1c25d2b550c5fffc:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_1c25d2b550c5fffc:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_1c25d2b550c5fffc:
    component  is "black_box";
  component binary_counter_virtex5_10_0_1ee993c8ed57b9ce
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_1ee993c8ed57b9ce:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_1ee993c8ed57b9ce:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_1ee993c8ed57b9ce:
    component  is "black_box";
  component binary_counter_virtex5_10_0_722dc5ef3883365e
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_722dc5ef3883365e:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_722dc5ef3883365e:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_722dc5ef3883365e:
    component  is "black_box";
  component binary_counter_virtex5_10_0_ad5bcb1136ed8cf6
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_ad5bcb1136ed8cf6:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_ad5bcb1136ed8cf6:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_ad5bcb1136ed8cf6:
    component  is "black_box";
  component binary_counter_virtex5_10_0_fe346e03af2452eb
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_fe346e03af2452eb:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_fe346e03af2452eb:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_fe346e03af2452eb:
    component  is "black_box";
  component binary_counter_virtex5_10_0_924a7f7132ea4004
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_924a7f7132ea4004:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_924a7f7132ea4004:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_924a7f7132ea4004:
    component  is "black_box";
  component binary_counter_virtex5_10_0_833a35886d0c544c
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_833a35886d0c544c:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_833a35886d0c544c:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_833a35886d0c544c:
    component  is "black_box";
  component binary_counter_virtex5_10_0_76ea00975735b561
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_76ea00975735b561:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_76ea00975735b561:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_76ea00975735b561:
    component  is "black_box";
  component binary_counter_virtex5_10_0_6ddb97ef480a3f10
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_6ddb97ef480a3f10:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_6ddb97ef480a3f10:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_6ddb97ef480a3f10:
    component  is "black_box";
  component binary_counter_virtex5_10_0_ed17144209261f47
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_ed17144209261f47:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_ed17144209261f47:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_ed17144209261f47:
    component  is "black_box";
  component binary_counter_virtex5_10_0_487c95d8131ef26d
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_487c95d8131ef26d:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_487c95d8131ef26d:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_487c95d8131ef26d:
    component  is "black_box";
  component binary_counter_virtex5_10_0_f8c7b661c01eeb1d
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of binary_counter_virtex5_10_0_f8c7b661c01eeb1d:
    component is true;
  attribute fpga_dont_touch of binary_counter_virtex5_10_0_f8c7b661c01eeb1d:
    component is "true";
  attribute box_type of binary_counter_virtex5_10_0_f8c7b661c01eeb1d:
    component  is "black_box";
-- synopsys translate_off
  constant zeroVec: std_logic_vector(op_width - 1 downto 0) := (others => '0');
  constant oneVec: std_logic_vector(op_width - 1 downto 0) := (others => '1');
  constant zeroStr: string(1 to op_width) :=
    std_logic_vector_to_bin_string(zeroVec);
  constant oneStr: string(1 to op_width) :=
    std_logic_vector_to_bin_string(oneVec);
-- synopsys translate_on
  signal core_sinit: std_logic;
  signal core_ce: std_logic;
  signal op_net: std_logic_vector(op_width - 1 downto 0);
begin
  core_ce <= ce and en(0);
  core_sinit <= (clr or rst(0)) and ce;
  op <= op_net;
  comp0: if ((core_name0 = "binary_counter_virtex5_10_0_092422ed79c7db12")) generate
    core_instance0: binary_counter_virtex5_10_0_092422ed79c7db12
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
  comp1: if ((core_name0 = "binary_counter_virtex5_10_0_01e34ae12479a5e1")) generate
    core_instance1: binary_counter_virtex5_10_0_01e34ae12479a5e1
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
  comp2: if ((core_name0 = "binary_counter_virtex5_10_0_1c25d2b550c5fffc")) generate
    core_instance2: binary_counter_virtex5_10_0_1c25d2b550c5fffc
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
  comp3: if ((core_name0 = "binary_counter_virtex5_10_0_1ee993c8ed57b9ce")) generate
    core_instance3: binary_counter_virtex5_10_0_1ee993c8ed57b9ce
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
  comp4: if ((core_name0 = "binary_counter_virtex5_10_0_722dc5ef3883365e")) generate
    core_instance4: binary_counter_virtex5_10_0_722dc5ef3883365e
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
  comp5: if ((core_name0 = "binary_counter_virtex5_10_0_ad5bcb1136ed8cf6")) generate
    core_instance5: binary_counter_virtex5_10_0_ad5bcb1136ed8cf6
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
  comp6: if ((core_name0 = "binary_counter_virtex5_10_0_fe346e03af2452eb")) generate
    core_instance6: binary_counter_virtex5_10_0_fe346e03af2452eb
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
  comp7: if ((core_name0 = "binary_counter_virtex5_10_0_924a7f7132ea4004")) generate
    core_instance7: binary_counter_virtex5_10_0_924a7f7132ea4004
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
  comp8: if ((core_name0 = "binary_counter_virtex5_10_0_833a35886d0c544c")) generate
    core_instance8: binary_counter_virtex5_10_0_833a35886d0c544c
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
  comp9: if ((core_name0 = "binary_counter_virtex5_10_0_76ea00975735b561")) generate
    core_instance9: binary_counter_virtex5_10_0_76ea00975735b561
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
  comp10: if ((core_name0 = "binary_counter_virtex5_10_0_6ddb97ef480a3f10")) generate
    core_instance10: binary_counter_virtex5_10_0_6ddb97ef480a3f10
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
  comp11: if ((core_name0 = "binary_counter_virtex5_10_0_ed17144209261f47")) generate
    core_instance11: binary_counter_virtex5_10_0_ed17144209261f47
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
  comp12: if ((core_name0 = "binary_counter_virtex5_10_0_487c95d8131ef26d")) generate
    core_instance12: binary_counter_virtex5_10_0_487c95d8131ef26d
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
  comp13: if ((core_name0 = "binary_counter_virtex5_10_0_f8c7b661c01eeb1d")) generate
    core_instance13: binary_counter_virtex5_10_0_f8c7b661c01eeb1d
      port map (
        clk => clk,
        ce => core_ce,
        SINIT=> core_sinit,
        q => op_net
      );
  end generate;
end behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_487ac75be9 is
  port (
    a : in std_logic_vector((25 - 1) downto 0);
    b : in std_logic_vector((25 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_487ac75be9;


architecture behavior of relational_487ac75be9 is
  signal a_1_31: unsigned((25 - 1) downto 0);
  signal b_1_34: unsigned((25 - 1) downto 0);
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_14_3_rel <= a_1_31 /= b_1_34;
  op <= boolean_to_vector(result_14_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_7673b9b993 is
  port (
    in0 : in std_logic_vector((1 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    in2 : in std_logic_vector((1 - 1) downto 0);
    in3 : in std_logic_vector((1 - 1) downto 0);
    in4 : in std_logic_vector((1 - 1) downto 0);
    in5 : in std_logic_vector((1 - 1) downto 0);
    in6 : in std_logic_vector((1 - 1) downto 0);
    in7 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_7673b9b993;


architecture behavior of concat_7673b9b993 is
  signal in0_1_23: unsigned((1 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal in2_1_31: unsigned((1 - 1) downto 0);
  signal in3_1_35: unsigned((1 - 1) downto 0);
  signal in4_1_39: unsigned((1 - 1) downto 0);
  signal in5_1_43: unsigned((1 - 1) downto 0);
  signal in6_1_47: unsigned((1 - 1) downto 0);
  signal in7_1_51: unsigned((1 - 1) downto 0);
  signal y_2_1_concat: unsigned((8 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  in4_1_39 <= std_logic_vector_to_unsigned(in4);
  in5_1_43 <= std_logic_vector_to_unsigned(in5);
  in6_1_47 <= std_logic_vector_to_unsigned(in6);
  in7_1_51 <= std_logic_vector_to_unsigned(in7);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35) & unsigned_to_std_logic_vector(in4_1_39) & unsigned_to_std_logic_vector(in5_1_43) & unsigned_to_std_logic_vector(in6_1_47) & unsigned_to_std_logic_vector(in7_1_51));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_63700884f5 is
  port (
    input_port : in std_logic_vector((19 - 1) downto 0);
    output_port : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_63700884f5;


architecture behavior of reinterpret_63700884f5 is
  signal input_port_1_40: unsigned((19 - 1) downto 0);
  signal output_port_5_5_force: signed((19 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_5a12f8f9be is
  port (
    in0 : in std_logic_vector((19 - 1) downto 0);
    in1 : in std_logic_vector((19 - 1) downto 0);
    y : out std_logic_vector((38 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_5a12f8f9be;


architecture behavior of concat_5a12f8f9be is
  signal in0_1_23: unsigned((19 - 1) downto 0);
  signal in1_1_27: unsigned((19 - 1) downto 0);
  signal y_2_1_concat: unsigned((38 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_bc4405cd1e is
  port (
    input_port : in std_logic_vector((19 - 1) downto 0);
    output_port : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_bc4405cd1e;


architecture behavior of reinterpret_bc4405cd1e is
  signal input_port_1_40: signed((19 - 1) downto 0);
  signal output_port_5_5_force: unsigned((19 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_2943023fcf is
  port (
    en : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_2943023fcf;


architecture behavior of counter_2943023fcf is
  signal en_1_45: boolean;
  signal count_reg_20_23: unsigned((1 - 1) downto 0) := "0";
  signal count_reg_20_23_en: std_logic;
  signal count_reg_join_44_1: unsigned((2 - 1) downto 0);
  signal count_reg_join_44_1_en: std_logic;
begin
  en_1_45 <= ((en) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_en = '1')) then
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("1");
      end if;
    end if;
  end process proc_count_reg_20_23;
  proc_if_44_1: process (count_reg_20_23, en_1_45)
  is
  begin
    if en_1_45 then
      count_reg_join_44_1_en <= '1';
    else 
      count_reg_join_44_1_en <= '0';
    end if;
  end process proc_if_44_1;
  count_reg_20_23_en <= count_reg_join_44_1_en;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_7f6b7da686 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((8 - 1) downto 0);
    d1 : in std_logic_vector((8 - 1) downto 0);
    y : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_7f6b7da686;


architecture behavior of mux_7f6b7da686 is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((8 - 1) downto 0);
  signal d1_1_27: std_logic_vector((8 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((8 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "00000000");
  signal pipe_16_22_front_din: std_logic_vector((8 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((8 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((8 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_53c93d0689 is
  port (
    a : in std_logic_vector((1 - 1) downto 0);
    b : in std_logic_vector((8 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_53c93d0689;


architecture behavior of relational_53c93d0689 is
  signal a_1_31: signed((1 - 1) downto 0);
  signal b_1_34: signed((8 - 1) downto 0);
  type array_type_op_mem_32_22 is array (0 to (1 - 1)) of boolean;
  signal op_mem_32_22: array_type_op_mem_32_22 := (
    0 => false);
  signal op_mem_32_22_front_din: boolean;
  signal op_mem_32_22_back: boolean;
  signal op_mem_32_22_push_front_pop_back_en: std_logic;
  signal cast_12_12: signed((8 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_signed(a);
  b_1_34 <= std_logic_vector_to_signed(b);
  op_mem_32_22_back <= op_mem_32_22(0);
  proc_op_mem_32_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_32_22_push_front_pop_back_en = '1')) then
        op_mem_32_22(0) <= op_mem_32_22_front_din;
      end if;
    end if;
  end process proc_op_mem_32_22;
  cast_12_12 <= s2s_cast(a_1_31, 0, 8, 0);
  result_12_3_rel <= cast_12_12 = b_1_34;
  op_mem_32_22_front_din <= result_12_3_rel;
  op_mem_32_22_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_32_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_79b7e15c26 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((38 - 1) downto 0);
    d1 : in std_logic_vector((38 - 1) downto 0);
    y : out std_logic_vector((38 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_79b7e15c26;


architecture behavior of mux_79b7e15c26 is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((38 - 1) downto 0);
  signal d1_1_27: std_logic_vector((38 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((38 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "00000000000000000000000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((38 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((38 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((38 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_181e58d842 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((18 - 1) downto 0);
    d1 : in std_logic_vector((18 - 1) downto 0);
    y : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_181e58d842;


architecture behavior of mux_181e58d842 is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((18 - 1) downto 0);
  signal d1_1_27: std_logic_vector((18 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((18 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((18 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((18 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((18 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_ceef4fc23d is
  port (
    input_port : in std_logic_vector((9 - 1) downto 0);
    output_port : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_ceef4fc23d;


architecture behavior of reinterpret_ceef4fc23d is
  signal input_port_1_40: unsigned((9 - 1) downto 0);
  signal output_port_5_5_force: signed((9 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_9d608cd669 is
  port (
    in0 : in std_logic_vector((10 - 1) downto 0);
    in1 : in std_logic_vector((10 - 1) downto 0);
    y : out std_logic_vector((20 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_9d608cd669;


architecture behavior of concat_9d608cd669 is
  signal in0_1_23: unsigned((10 - 1) downto 0);
  signal in1_1_27: unsigned((10 - 1) downto 0);
  signal y_2_1_concat: unsigned((20 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_e2e786e1ed is
  port (
    input_port : in std_logic_vector((10 - 1) downto 0);
    output_port : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_e2e786e1ed;


architecture behavior of reinterpret_e2e786e1ed is
  signal input_port_1_40: signed((10 - 1) downto 0);
  signal output_port_5_5_force: unsigned((10 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_793ae25d23 is
  port (
    a : in std_logic_vector((9 - 1) downto 0);
    b : in std_logic_vector((9 - 1) downto 0);
    s : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_793ae25d23;


architecture behavior of addsub_793ae25d23 is
  signal a_17_32: signed((9 - 1) downto 0);
  signal b_17_35: signed((9 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((10 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0000000000");
  signal op_mem_91_20_front_din: signed((10 - 1) downto 0);
  signal op_mem_91_20_back: signed((10 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((10 - 1) downto 0);
  signal cast_69_22: signed((10 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((10 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 0, 10, 0);
  cast_69_22 <= s2s_cast(b_17_35, 0, 10, 0);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity scale_6d627f2811 is
  port (
    ip : in std_logic_vector((10 - 1) downto 0);
    op : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end scale_6d627f2811;


architecture behavior of scale_6d627f2811 is
  signal ip_17_23: signed((10 - 1) downto 0);
begin
  ip_17_23 <= std_logic_vector_to_signed(ip);
  op <= signed_to_std_logic_vector(ip_17_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_3700bc31ba is
  port (
    a : in std_logic_vector((9 - 1) downto 0);
    b : in std_logic_vector((9 - 1) downto 0);
    s : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_3700bc31ba;


architecture behavior of addsub_3700bc31ba is
  signal a_17_32: signed((9 - 1) downto 0);
  signal b_17_35: signed((9 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((10 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0000000000");
  signal op_mem_91_20_front_din: signed((10 - 1) downto 0);
  signal op_mem_91_20_back: signed((10 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((10 - 1) downto 0);
  signal cast_71_22: signed((10 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((10 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 0, 10, 0);
  cast_71_22 <= s2s_cast(b_17_35, 0, 10, 0);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  op_mem_91_20_front_din <= internal_s_71_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_a5a2f0dd62 is
  port (
    input_port : in std_logic_vector((10 - 1) downto 0);
    output_port : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_a5a2f0dd62;


architecture behavior of reinterpret_a5a2f0dd62 is
  signal input_port_1_40: unsigned((10 - 1) downto 0);
  signal output_port_5_5_force: signed((10 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_a9f0cfc482 is
  port (
    in0 : in std_logic_vector((11 - 1) downto 0);
    in1 : in std_logic_vector((11 - 1) downto 0);
    y : out std_logic_vector((22 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_a9f0cfc482;


architecture behavior of concat_a9f0cfc482 is
  signal in0_1_23: unsigned((11 - 1) downto 0);
  signal in1_1_27: unsigned((11 - 1) downto 0);
  signal y_2_1_concat: unsigned((22 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_d517af3309 is
  port (
    input_port : in std_logic_vector((11 - 1) downto 0);
    output_port : out std_logic_vector((11 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_d517af3309;


architecture behavior of reinterpret_d517af3309 is
  signal input_port_1_40: signed((11 - 1) downto 0);
  signal output_port_5_5_force: unsigned((11 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_74b65e93f7 is
  port (
    a : in std_logic_vector((10 - 1) downto 0);
    b : in std_logic_vector((10 - 1) downto 0);
    s : out std_logic_vector((11 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_74b65e93f7;


architecture behavior of addsub_74b65e93f7 is
  signal a_17_32: signed((10 - 1) downto 0);
  signal b_17_35: signed((10 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((11 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "00000000000");
  signal op_mem_91_20_front_din: signed((11 - 1) downto 0);
  signal op_mem_91_20_back: signed((11 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((11 - 1) downto 0);
  signal cast_69_22: signed((11 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((11 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 0, 11, 0);
  cast_69_22 <= s2s_cast(b_17_35, 0, 11, 0);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity scale_1a387a5a22 is
  port (
    ip : in std_logic_vector((11 - 1) downto 0);
    op : out std_logic_vector((11 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end scale_1a387a5a22;


architecture behavior of scale_1a387a5a22 is
  signal ip_17_23: signed((11 - 1) downto 0);
begin
  ip_17_23 <= std_logic_vector_to_signed(ip);
  op <= signed_to_std_logic_vector(ip_17_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_89c5949a28 is
  port (
    a : in std_logic_vector((10 - 1) downto 0);
    b : in std_logic_vector((10 - 1) downto 0);
    s : out std_logic_vector((11 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_89c5949a28;


architecture behavior of addsub_89c5949a28 is
  signal a_17_32: signed((10 - 1) downto 0);
  signal b_17_35: signed((10 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((11 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "00000000000");
  signal op_mem_91_20_front_din: signed((11 - 1) downto 0);
  signal op_mem_91_20_back: signed((11 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((11 - 1) downto 0);
  signal cast_71_22: signed((11 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((11 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 0, 11, 0);
  cast_71_22 <= s2s_cast(b_17_35, 0, 11, 0);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  op_mem_91_20_front_din <= internal_s_71_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_41416f6188 is
  port (
    input_port : in std_logic_vector((11 - 1) downto 0);
    output_port : out std_logic_vector((11 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_41416f6188;


architecture behavior of reinterpret_41416f6188 is
  signal input_port_1_40: unsigned((11 - 1) downto 0);
  signal output_port_5_5_force: signed((11 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_c83be1b493 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((22 - 1) downto 0);
    d1 : in std_logic_vector((22 - 1) downto 0);
    y : out std_logic_vector((22 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_c83be1b493;


architecture behavior of mux_c83be1b493 is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((22 - 1) downto 0);
  signal d1_1_27: std_logic_vector((22 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((22 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "0000000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((22 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((22 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((22 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_6188124172 is
  port (
    in0 : in std_logic_vector((12 - 1) downto 0);
    in1 : in std_logic_vector((12 - 1) downto 0);
    y : out std_logic_vector((24 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_6188124172;


architecture behavior of concat_6188124172 is
  signal in0_1_23: unsigned((12 - 1) downto 0);
  signal in1_1_27: unsigned((12 - 1) downto 0);
  signal y_2_1_concat: unsigned((24 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_a106f99236 is
  port (
    input_port : in std_logic_vector((12 - 1) downto 0);
    output_port : out std_logic_vector((12 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_a106f99236;


architecture behavior of reinterpret_a106f99236 is
  signal input_port_1_40: signed((12 - 1) downto 0);
  signal output_port_5_5_force: unsigned((12 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_470ffe01d4 is
  port (
    a : in std_logic_vector((11 - 1) downto 0);
    b : in std_logic_vector((11 - 1) downto 0);
    s : out std_logic_vector((12 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_470ffe01d4;


architecture behavior of addsub_470ffe01d4 is
  signal a_17_32: signed((11 - 1) downto 0);
  signal b_17_35: signed((11 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((12 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "000000000000");
  signal op_mem_91_20_front_din: signed((12 - 1) downto 0);
  signal op_mem_91_20_back: signed((12 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((12 - 1) downto 0);
  signal cast_69_22: signed((12 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((12 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 0, 12, 0);
  cast_69_22 <= s2s_cast(b_17_35, 0, 12, 0);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity scale_38e99696aa is
  port (
    ip : in std_logic_vector((12 - 1) downto 0);
    op : out std_logic_vector((12 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end scale_38e99696aa;


architecture behavior of scale_38e99696aa is
  signal ip_17_23: signed((12 - 1) downto 0);
begin
  ip_17_23 <= std_logic_vector_to_signed(ip);
  op <= signed_to_std_logic_vector(ip_17_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_388a97573b is
  port (
    a : in std_logic_vector((11 - 1) downto 0);
    b : in std_logic_vector((11 - 1) downto 0);
    s : out std_logic_vector((12 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_388a97573b;


architecture behavior of addsub_388a97573b is
  signal a_17_32: signed((11 - 1) downto 0);
  signal b_17_35: signed((11 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((12 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "000000000000");
  signal op_mem_91_20_front_din: signed((12 - 1) downto 0);
  signal op_mem_91_20_back: signed((12 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((12 - 1) downto 0);
  signal cast_71_22: signed((12 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((12 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 0, 12, 0);
  cast_71_22 <= s2s_cast(b_17_35, 0, 12, 0);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  op_mem_91_20_front_din <= internal_s_71_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_8f5500aea5 is
  port (
    input_port : in std_logic_vector((12 - 1) downto 0);
    output_port : out std_logic_vector((12 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_8f5500aea5;


architecture behavior of reinterpret_8f5500aea5 is
  signal input_port_1_40: unsigned((12 - 1) downto 0);
  signal output_port_5_5_force: signed((12 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_4720648850 is
  port (
    in0 : in std_logic_vector((13 - 1) downto 0);
    in1 : in std_logic_vector((13 - 1) downto 0);
    y : out std_logic_vector((26 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_4720648850;


architecture behavior of concat_4720648850 is
  signal in0_1_23: unsigned((13 - 1) downto 0);
  signal in1_1_27: unsigned((13 - 1) downto 0);
  signal y_2_1_concat: unsigned((26 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_18554b6b75 is
  port (
    input_port : in std_logic_vector((13 - 1) downto 0);
    output_port : out std_logic_vector((13 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_18554b6b75;


architecture behavior of reinterpret_18554b6b75 is
  signal input_port_1_40: signed((13 - 1) downto 0);
  signal output_port_5_5_force: unsigned((13 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_ed74d532a0 is
  port (
    a : in std_logic_vector((12 - 1) downto 0);
    b : in std_logic_vector((12 - 1) downto 0);
    s : out std_logic_vector((13 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_ed74d532a0;


architecture behavior of addsub_ed74d532a0 is
  signal a_17_32: signed((12 - 1) downto 0);
  signal b_17_35: signed((12 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((13 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0000000000000");
  signal op_mem_91_20_front_din: signed((13 - 1) downto 0);
  signal op_mem_91_20_back: signed((13 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((13 - 1) downto 0);
  signal cast_69_22: signed((13 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((13 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 0, 13, 0);
  cast_69_22 <= s2s_cast(b_17_35, 0, 13, 0);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity scale_d11c4b5145 is
  port (
    ip : in std_logic_vector((13 - 1) downto 0);
    op : out std_logic_vector((13 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end scale_d11c4b5145;


architecture behavior of scale_d11c4b5145 is
  signal ip_17_23: signed((13 - 1) downto 0);
begin
  ip_17_23 <= std_logic_vector_to_signed(ip);
  op <= signed_to_std_logic_vector(ip_17_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_f11535f968 is
  port (
    a : in std_logic_vector((12 - 1) downto 0);
    b : in std_logic_vector((12 - 1) downto 0);
    s : out std_logic_vector((13 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_f11535f968;


architecture behavior of addsub_f11535f968 is
  signal a_17_32: signed((12 - 1) downto 0);
  signal b_17_35: signed((12 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((13 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0000000000000");
  signal op_mem_91_20_front_din: signed((13 - 1) downto 0);
  signal op_mem_91_20_back: signed((13 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((13 - 1) downto 0);
  signal cast_71_22: signed((13 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((13 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 0, 13, 0);
  cast_71_22 <= s2s_cast(b_17_35, 0, 13, 0);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  op_mem_91_20_front_din <= internal_s_71_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_d661929060 is
  port (
    a : in std_logic_vector((11 - 1) downto 0);
    b : in std_logic_vector((11 - 1) downto 0);
    s : out std_logic_vector((12 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_d661929060;


architecture behavior of addsub_d661929060 is
  signal a_17_32: signed((11 - 1) downto 0);
  signal b_17_35: signed((11 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((12 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "000000000000");
  signal op_mem_91_20_front_din: signed((12 - 1) downto 0);
  signal op_mem_91_20_back: signed((12 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((12 - 1) downto 0);
  signal cast_69_22: signed((12 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((12 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 10, 12, 10);
  cast_69_22 <= s2s_cast(b_17_35, 10, 12, 10);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_c8df442ec4 is
  port (
    a : in std_logic_vector((18 - 1) downto 0);
    b : in std_logic_vector((18 - 1) downto 0);
    s : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_c8df442ec4;


architecture behavior of addsub_c8df442ec4 is
  signal a_17_32: signed((18 - 1) downto 0);
  signal b_17_35: signed((18 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((18 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "000000000000000000");
  signal op_mem_91_20_front_din: signed((18 - 1) downto 0);
  signal op_mem_91_20_back: signed((18 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((19 - 1) downto 0);
  signal cast_69_22: signed((19 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((19 - 1) downto 0);
  signal cast_internal_s_83_3_convert: signed((18 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 17, 19, 17);
  cast_69_22 <= s2s_cast(b_17_35, 17, 19, 17);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  cast_internal_s_83_3_convert <= s2s_cast(internal_s_69_5_addsub, 17, 18, 17);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_6dd6aca36b is
  port (
    a : in std_logic_vector((18 - 1) downto 0);
    b : in std_logic_vector((18 - 1) downto 0);
    s : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_6dd6aca36b;


architecture behavior of addsub_6dd6aca36b is
  signal a_17_32: signed((18 - 1) downto 0);
  signal b_17_35: signed((18 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (2 - 1)) of signed((18 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    "000000000000000000",
    "000000000000000000");
  signal op_mem_91_20_front_din: signed((18 - 1) downto 0);
  signal op_mem_91_20_back: signed((18 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (2 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    "0",
    "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((19 - 1) downto 0);
  signal cast_71_22: signed((19 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((19 - 1) downto 0);
  signal cast_internal_s_83_3_convert: signed((18 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(1);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_91_20(i) <= op_mem_91_20(i-1);
        end loop;
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(1);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        for i_x_000000 in 1 downto 1 loop 
          cout_mem_92_22(i_x_000000) <= cout_mem_92_22(i_x_000000-1);
        end loop;
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 17, 19, 17);
  cast_71_22 <= s2s_cast(b_17_35, 17, 19, 17);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  cast_internal_s_83_3_convert <= s2s_cast(internal_s_71_5_addsub, 17, 18, 17);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_21a1218bfe is
  port (
    a : in std_logic_vector((18 - 1) downto 0);
    b : in std_logic_vector((18 - 1) downto 0);
    s : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_21a1218bfe;


architecture behavior of addsub_21a1218bfe is
  signal a_17_32: signed((18 - 1) downto 0);
  signal b_17_35: signed((18 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((18 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "000000000000000000");
  signal op_mem_91_20_front_din: signed((18 - 1) downto 0);
  signal op_mem_91_20_back: signed((18 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((19 - 1) downto 0);
  signal cast_71_22: signed((19 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((19 - 1) downto 0);
  signal cast_internal_s_83_3_convert: signed((18 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 17, 19, 17);
  cast_71_22 <= s2s_cast(b_17_35, 17, 19, 17);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  cast_internal_s_83_3_convert <= s2s_cast(internal_s_71_5_addsub, 17, 18, 17);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_bd2bd198b1 is
  port (
    a : in std_logic_vector((9 - 1) downto 0);
    b : in std_logic_vector((9 - 1) downto 0);
    s : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_bd2bd198b1;


architecture behavior of addsub_bd2bd198b1 is
  signal a_17_32: signed((9 - 1) downto 0);
  signal b_17_35: signed((9 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((10 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0000000000");
  signal op_mem_91_20_front_din: signed((10 - 1) downto 0);
  signal op_mem_91_20_back: signed((10 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((10 - 1) downto 0);
  signal cast_69_22: signed((10 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((10 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 7, 10, 7);
  cast_69_22 <= s2s_cast(b_17_35, 7, 10, 7);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;


-------------------------------------------------------------------
-- System Generator version 10.1.3 VHDL source file.
--
-- Copyright(C) 2008 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2008 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library XilinxCoreLib;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use work.conv_pkg.all;
entity xlsprom_dist is
  generic (
    core_name0: string := "";
    addr_width: integer := 2;
    latency: integer := 0;
    c_width: integer := 12;
    c_address_width: integer := 4
  );
  port (
    addr: in std_logic_vector(addr_width - 1 downto 0);
    en: in std_logic_vector(0 downto 0);
    ce: in std_logic;
    clk: in std_logic;
    data: out std_logic_vector(c_width - 1 downto 0)
  );
end xlsprom_dist ;
architecture behavior of xlsprom_dist is
  component synth_reg
      generic (width       : integer;
               latency     : integer);
      port (i           : in std_logic_vector(width - 1 downto 0);
            ce      : in std_logic;
            clr     : in std_logic;
            clk     : in std_logic;
            o       : out std_logic_vector(width - 1 downto 0));
  end component;
  signal core_data_out: std_logic_vector(c_width - 1 downto 0);
  constant num_extra_addr_bits: integer := (c_address_width - addr_width);
  signal core_addr: std_logic_vector(c_address_width - 1 downto 0);
  signal core_ce: std_logic;
  component dmg_33_vx5_3b5827b9b9c34c2c
    port (
      a: in std_logic_vector(c_address_width - 1 downto 0);
      clk: in std_logic;
      qspo_ce: in std_logic;
      qspo: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of dmg_33_vx5_3b5827b9b9c34c2c:
    component is true;
  attribute fpga_dont_touch of dmg_33_vx5_3b5827b9b9c34c2c:
    component is "true";
  attribute box_type of dmg_33_vx5_3b5827b9b9c34c2c:
    component  is "black_box";
  component dmg_33_vx5_6ab87bec3a8932d3
    port (
      a: in std_logic_vector(c_address_width - 1 downto 0);
      clk: in std_logic;
      qspo_ce: in std_logic;
      qspo: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of dmg_33_vx5_6ab87bec3a8932d3:
    component is true;
  attribute fpga_dont_touch of dmg_33_vx5_6ab87bec3a8932d3:
    component is "true";
  attribute box_type of dmg_33_vx5_6ab87bec3a8932d3:
    component  is "black_box";
  component dmg_33_vx5_af86f8a7a0de7d76
    port (
      a: in std_logic_vector(c_address_width - 1 downto 0);
      clk: in std_logic;
      qspo_ce: in std_logic;
      qspo: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of dmg_33_vx5_af86f8a7a0de7d76:
    component is true;
  attribute fpga_dont_touch of dmg_33_vx5_af86f8a7a0de7d76:
    component is "true";
  attribute box_type of dmg_33_vx5_af86f8a7a0de7d76:
    component  is "black_box";
  component dmg_33_vx5_efe4f2e28a6a56b5
    port (
      a: in std_logic_vector(c_address_width - 1 downto 0);
      clk: in std_logic;
      qspo_ce: in std_logic;
      qspo: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of dmg_33_vx5_efe4f2e28a6a56b5:
    component is true;
  attribute fpga_dont_touch of dmg_33_vx5_efe4f2e28a6a56b5:
    component is "true";
  attribute box_type of dmg_33_vx5_efe4f2e28a6a56b5:
    component  is "black_box";
  component dmg_33_vx5_47bf930170fd8e60
    port (
      a: in std_logic_vector(c_address_width - 1 downto 0);
      clk: in std_logic;
      qspo_ce: in std_logic;
      qspo: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of dmg_33_vx5_47bf930170fd8e60:
    component is true;
  attribute fpga_dont_touch of dmg_33_vx5_47bf930170fd8e60:
    component is "true";
  attribute box_type of dmg_33_vx5_47bf930170fd8e60:
    component  is "black_box";
  component dmg_33_vx5_27954da46fb8f5d8
    port (
      a: in std_logic_vector(c_address_width - 1 downto 0);
      clk: in std_logic;
      qspo_ce: in std_logic;
      qspo: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;
  attribute syn_black_box of dmg_33_vx5_27954da46fb8f5d8:
    component is true;
  attribute fpga_dont_touch of dmg_33_vx5_27954da46fb8f5d8:
    component is "true";
  attribute box_type of dmg_33_vx5_27954da46fb8f5d8:
    component  is "black_box";
begin
  need_to_pad_addr: if num_extra_addr_bits > 0 generate
      core_addr(c_address_width - 1 downto addr_width) <= (others => '0');
    core_addr(addr_width - 1 downto 0) <= addr;
  end generate;
  no_need_to_pad_addr: if num_extra_addr_bits = 0 generate
    core_addr <= addr;
  end generate;
  core_ce <= ce and en(0);
  comp0: if ((core_name0 = "dmg_33_vx5_3b5827b9b9c34c2c")) generate
    core_instance0: dmg_33_vx5_3b5827b9b9c34c2c
      port map (
        a => core_addr,
        clk => clk,
        qspo_ce => core_ce,
        qspo => core_data_out
      );
  end generate;
  comp1: if ((core_name0 = "dmg_33_vx5_6ab87bec3a8932d3")) generate
    core_instance1: dmg_33_vx5_6ab87bec3a8932d3
      port map (
        a => core_addr,
        clk => clk,
        qspo_ce => core_ce,
        qspo => core_data_out
      );
  end generate;
  comp2: if ((core_name0 = "dmg_33_vx5_af86f8a7a0de7d76")) generate
    core_instance2: dmg_33_vx5_af86f8a7a0de7d76
      port map (
        a => core_addr,
        clk => clk,
        qspo_ce => core_ce,
        qspo => core_data_out
      );
  end generate;
  comp3: if ((core_name0 = "dmg_33_vx5_efe4f2e28a6a56b5")) generate
    core_instance3: dmg_33_vx5_efe4f2e28a6a56b5
      port map (
        a => core_addr,
        clk => clk,
        qspo_ce => core_ce,
        qspo => core_data_out
      );
  end generate;
  comp4: if ((core_name0 = "dmg_33_vx5_47bf930170fd8e60")) generate
    core_instance4: dmg_33_vx5_47bf930170fd8e60
      port map (
        a => core_addr,
        clk => clk,
        qspo_ce => core_ce,
        qspo => core_data_out
      );
  end generate;
  comp5: if ((core_name0 = "dmg_33_vx5_27954da46fb8f5d8")) generate
    core_instance5: dmg_33_vx5_27954da46fb8f5d8
      port map (
        a => core_addr,
        clk => clk,
        qspo_ce => core_ce,
        qspo => core_data_out
      );
  end generate;
  latency_test: if (latency > 1) generate
    reg: synth_reg
      generic map (
        width => c_width,
        latency => latency - 1
      )
      port map (
        i => core_data_out,
        ce => core_ce,
        clr => '0',
        clk => clk,
        o => data
      );
  end generate;
  latency_0_or_1: if (latency <= 1)
  generate
    data <= core_data_out;
  end generate;
end  behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_0eccfc7565 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((26 - 1) downto 0);
    d1 : in std_logic_vector((26 - 1) downto 0);
    y : out std_logic_vector((26 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_0eccfc7565;


architecture behavior of mux_0eccfc7565 is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((26 - 1) downto 0);
  signal d1_1_27: std_logic_vector((26 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((26 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "00000000000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((26 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((26 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((26 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_33580846c4 is
  port (
    input_port : in std_logic_vector((13 - 1) downto 0);
    output_port : out std_logic_vector((13 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_33580846c4;


architecture behavior of reinterpret_33580846c4 is
  signal input_port_1_40: unsigned((13 - 1) downto 0);
  signal output_port_5_5_force: signed((13 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_e5ffcbc394 is
  port (
    in0 : in std_logic_vector((14 - 1) downto 0);
    in1 : in std_logic_vector((14 - 1) downto 0);
    y : out std_logic_vector((28 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_e5ffcbc394;


architecture behavior of concat_e5ffcbc394 is
  signal in0_1_23: unsigned((14 - 1) downto 0);
  signal in1_1_27: unsigned((14 - 1) downto 0);
  signal y_2_1_concat: unsigned((28 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_eb72d4ea08 is
  port (
    input_port : in std_logic_vector((14 - 1) downto 0);
    output_port : out std_logic_vector((14 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_eb72d4ea08;


architecture behavior of reinterpret_eb72d4ea08 is
  signal input_port_1_40: signed((14 - 1) downto 0);
  signal output_port_5_5_force: unsigned((14 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_4a1b074932 is
  port (
    a : in std_logic_vector((13 - 1) downto 0);
    b : in std_logic_vector((13 - 1) downto 0);
    s : out std_logic_vector((14 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_4a1b074932;


architecture behavior of addsub_4a1b074932 is
  signal a_17_32: signed((13 - 1) downto 0);
  signal b_17_35: signed((13 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((14 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "00000000000000");
  signal op_mem_91_20_front_din: signed((14 - 1) downto 0);
  signal op_mem_91_20_back: signed((14 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((14 - 1) downto 0);
  signal cast_69_22: signed((14 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((14 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 0, 14, 0);
  cast_69_22 <= s2s_cast(b_17_35, 0, 14, 0);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity scale_a1339d14c7 is
  port (
    ip : in std_logic_vector((14 - 1) downto 0);
    op : out std_logic_vector((14 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end scale_a1339d14c7;


architecture behavior of scale_a1339d14c7 is
  signal ip_17_23: signed((14 - 1) downto 0);
begin
  ip_17_23 <= std_logic_vector_to_signed(ip);
  op <= signed_to_std_logic_vector(ip_17_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_f3687289ea is
  port (
    a : in std_logic_vector((13 - 1) downto 0);
    b : in std_logic_vector((13 - 1) downto 0);
    s : out std_logic_vector((14 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_f3687289ea;


architecture behavior of addsub_f3687289ea is
  signal a_17_32: signed((13 - 1) downto 0);
  signal b_17_35: signed((13 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((14 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "00000000000000");
  signal op_mem_91_20_front_din: signed((14 - 1) downto 0);
  signal op_mem_91_20_back: signed((14 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((14 - 1) downto 0);
  signal cast_71_22: signed((14 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((14 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 0, 14, 0);
  cast_71_22 <= s2s_cast(b_17_35, 0, 14, 0);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  op_mem_91_20_front_din <= internal_s_71_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_445612bb74 is
  port (
    input_port : in std_logic_vector((14 - 1) downto 0);
    output_port : out std_logic_vector((14 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_445612bb74;


architecture behavior of reinterpret_445612bb74 is
  signal input_port_1_40: unsigned((14 - 1) downto 0);
  signal output_port_5_5_force: signed((14 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_22467883b2 is
  port (
    in0 : in std_logic_vector((15 - 1) downto 0);
    in1 : in std_logic_vector((15 - 1) downto 0);
    y : out std_logic_vector((30 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_22467883b2;


architecture behavior of concat_22467883b2 is
  signal in0_1_23: unsigned((15 - 1) downto 0);
  signal in1_1_27: unsigned((15 - 1) downto 0);
  signal y_2_1_concat: unsigned((30 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_0d1490be80 is
  port (
    input_port : in std_logic_vector((15 - 1) downto 0);
    output_port : out std_logic_vector((15 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_0d1490be80;


architecture behavior of reinterpret_0d1490be80 is
  signal input_port_1_40: signed((15 - 1) downto 0);
  signal output_port_5_5_force: unsigned((15 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_79dc8835bc is
  port (
    a : in std_logic_vector((14 - 1) downto 0);
    b : in std_logic_vector((14 - 1) downto 0);
    s : out std_logic_vector((15 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_79dc8835bc;


architecture behavior of addsub_79dc8835bc is
  signal a_17_32: signed((14 - 1) downto 0);
  signal b_17_35: signed((14 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((15 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "000000000000000");
  signal op_mem_91_20_front_din: signed((15 - 1) downto 0);
  signal op_mem_91_20_back: signed((15 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((15 - 1) downto 0);
  signal cast_69_22: signed((15 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((15 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 0, 15, 0);
  cast_69_22 <= s2s_cast(b_17_35, 0, 15, 0);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity scale_11a6418200 is
  port (
    ip : in std_logic_vector((15 - 1) downto 0);
    op : out std_logic_vector((15 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end scale_11a6418200;


architecture behavior of scale_11a6418200 is
  signal ip_17_23: signed((15 - 1) downto 0);
begin
  ip_17_23 <= std_logic_vector_to_signed(ip);
  op <= signed_to_std_logic_vector(ip_17_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_f4e99698eb is
  port (
    a : in std_logic_vector((14 - 1) downto 0);
    b : in std_logic_vector((14 - 1) downto 0);
    s : out std_logic_vector((15 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_f4e99698eb;


architecture behavior of addsub_f4e99698eb is
  signal a_17_32: signed((14 - 1) downto 0);
  signal b_17_35: signed((14 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((15 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "000000000000000");
  signal op_mem_91_20_front_din: signed((15 - 1) downto 0);
  signal op_mem_91_20_back: signed((15 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((15 - 1) downto 0);
  signal cast_71_22: signed((15 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((15 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 0, 15, 0);
  cast_71_22 <= s2s_cast(b_17_35, 0, 15, 0);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  op_mem_91_20_front_din <= internal_s_71_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_c0d1d84d6b is
  port (
    a : in std_logic_vector((13 - 1) downto 0);
    b : in std_logic_vector((13 - 1) downto 0);
    s : out std_logic_vector((14 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_c0d1d84d6b;


architecture behavior of addsub_c0d1d84d6b is
  signal a_17_32: signed((13 - 1) downto 0);
  signal b_17_35: signed((13 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((14 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "00000000000000");
  signal op_mem_91_20_front_din: signed((14 - 1) downto 0);
  signal op_mem_91_20_back: signed((14 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((14 - 1) downto 0);
  signal cast_69_22: signed((14 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((14 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 12, 14, 12);
  cast_69_22 <= s2s_cast(b_17_35, 12, 14, 12);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_a9cdc93774 is
  port (
    a : in std_logic_vector((20 - 1) downto 0);
    b : in std_logic_vector((20 - 1) downto 0);
    s : out std_logic_vector((20 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_a9cdc93774;


architecture behavior of addsub_a9cdc93774 is
  signal a_17_32: signed((20 - 1) downto 0);
  signal b_17_35: signed((20 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((20 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "00000000000000000000");
  signal op_mem_91_20_front_din: signed((20 - 1) downto 0);
  signal op_mem_91_20_back: signed((20 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((21 - 1) downto 0);
  signal cast_69_22: signed((21 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((21 - 1) downto 0);
  signal cast_internal_s_83_3_convert: signed((20 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 19, 21, 19);
  cast_69_22 <= s2s_cast(b_17_35, 19, 21, 19);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  cast_internal_s_83_3_convert <= s2s_cast(internal_s_69_5_addsub, 19, 20, 19);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_370c0f2c47 is
  port (
    a : in std_logic_vector((20 - 1) downto 0);
    b : in std_logic_vector((20 - 1) downto 0);
    s : out std_logic_vector((20 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_370c0f2c47;


architecture behavior of addsub_370c0f2c47 is
  signal a_17_32: signed((20 - 1) downto 0);
  signal b_17_35: signed((20 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (2 - 1)) of signed((20 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    "00000000000000000000",
    "00000000000000000000");
  signal op_mem_91_20_front_din: signed((20 - 1) downto 0);
  signal op_mem_91_20_back: signed((20 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (2 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    "0",
    "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((21 - 1) downto 0);
  signal cast_71_22: signed((21 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((21 - 1) downto 0);
  signal cast_internal_s_83_3_convert: signed((20 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(1);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_91_20(i) <= op_mem_91_20(i-1);
        end loop;
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(1);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        for i_x_000000 in 1 downto 1 loop 
          cout_mem_92_22(i_x_000000) <= cout_mem_92_22(i_x_000000-1);
        end loop;
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 19, 21, 19);
  cast_71_22 <= s2s_cast(b_17_35, 19, 21, 19);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  cast_internal_s_83_3_convert <= s2s_cast(internal_s_71_5_addsub, 19, 20, 19);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_5777994232 is
  port (
    a : in std_logic_vector((20 - 1) downto 0);
    b : in std_logic_vector((20 - 1) downto 0);
    s : out std_logic_vector((20 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_5777994232;


architecture behavior of addsub_5777994232 is
  signal a_17_32: signed((20 - 1) downto 0);
  signal b_17_35: signed((20 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((20 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "00000000000000000000");
  signal op_mem_91_20_front_din: signed((20 - 1) downto 0);
  signal op_mem_91_20_back: signed((20 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((21 - 1) downto 0);
  signal cast_71_22: signed((21 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((21 - 1) downto 0);
  signal cast_internal_s_83_3_convert: signed((20 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 19, 21, 19);
  cast_71_22 <= s2s_cast(b_17_35, 19, 21, 19);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  cast_internal_s_83_3_convert <= s2s_cast(internal_s_71_5_addsub, 19, 20, 19);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_458eaa1690 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((30 - 1) downto 0);
    d1 : in std_logic_vector((30 - 1) downto 0);
    y : out std_logic_vector((30 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_458eaa1690;


architecture behavior of mux_458eaa1690 is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((30 - 1) downto 0);
  signal d1_1_27: std_logic_vector((30 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((30 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "000000000000000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((30 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((30 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((30 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_c2430bbd90 is
  port (
    input_port : in std_logic_vector((15 - 1) downto 0);
    output_port : out std_logic_vector((15 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_c2430bbd90;


architecture behavior of reinterpret_c2430bbd90 is
  signal input_port_1_40: unsigned((15 - 1) downto 0);
  signal output_port_5_5_force: signed((15 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_a369e00c6b is
  port (
    in0 : in std_logic_vector((16 - 1) downto 0);
    in1 : in std_logic_vector((16 - 1) downto 0);
    y : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_a369e00c6b;


architecture behavior of concat_a369e00c6b is
  signal in0_1_23: unsigned((16 - 1) downto 0);
  signal in1_1_27: unsigned((16 - 1) downto 0);
  signal y_2_1_concat: unsigned((32 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_7025463ea8 is
  port (
    input_port : in std_logic_vector((16 - 1) downto 0);
    output_port : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_7025463ea8;


architecture behavior of reinterpret_7025463ea8 is
  signal input_port_1_40: signed((16 - 1) downto 0);
  signal output_port_5_5_force: unsigned((16 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_e8bb7c4e8b is
  port (
    a : in std_logic_vector((15 - 1) downto 0);
    b : in std_logic_vector((15 - 1) downto 0);
    s : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_e8bb7c4e8b;


architecture behavior of addsub_e8bb7c4e8b is
  signal a_17_32: signed((15 - 1) downto 0);
  signal b_17_35: signed((15 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((16 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0000000000000000");
  signal op_mem_91_20_front_din: signed((16 - 1) downto 0);
  signal op_mem_91_20_back: signed((16 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((16 - 1) downto 0);
  signal cast_69_22: signed((16 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((16 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 0, 16, 0);
  cast_69_22 <= s2s_cast(b_17_35, 0, 16, 0);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity scale_fa7c2ab9f6 is
  port (
    ip : in std_logic_vector((16 - 1) downto 0);
    op : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end scale_fa7c2ab9f6;


architecture behavior of scale_fa7c2ab9f6 is
  signal ip_17_23: signed((16 - 1) downto 0);
begin
  ip_17_23 <= std_logic_vector_to_signed(ip);
  op <= signed_to_std_logic_vector(ip_17_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_81ed09e952 is
  port (
    a : in std_logic_vector((15 - 1) downto 0);
    b : in std_logic_vector((15 - 1) downto 0);
    s : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_81ed09e952;


architecture behavior of addsub_81ed09e952 is
  signal a_17_32: signed((15 - 1) downto 0);
  signal b_17_35: signed((15 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((16 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0000000000000000");
  signal op_mem_91_20_front_din: signed((16 - 1) downto 0);
  signal op_mem_91_20_back: signed((16 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((16 - 1) downto 0);
  signal cast_71_22: signed((16 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((16 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 0, 16, 0);
  cast_71_22 <= s2s_cast(b_17_35, 0, 16, 0);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  op_mem_91_20_front_din <= internal_s_71_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_151459306d is
  port (
    input_port : in std_logic_vector((16 - 1) downto 0);
    output_port : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_151459306d;


architecture behavior of reinterpret_151459306d is
  signal input_port_1_40: unsigned((16 - 1) downto 0);
  signal output_port_5_5_force: signed((16 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_14b004d38d is
  port (
    a : in std_logic_vector((16 - 1) downto 0);
    b : in std_logic_vector((16 - 1) downto 0);
    s : out std_logic_vector((17 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_14b004d38d;


architecture behavior of addsub_14b004d38d is
  signal a_17_32: signed((16 - 1) downto 0);
  signal b_17_35: signed((16 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((17 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "00000000000000000");
  signal op_mem_91_20_front_din: signed((17 - 1) downto 0);
  signal op_mem_91_20_back: signed((17 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((17 - 1) downto 0);
  signal cast_69_22: signed((17 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((17 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 0, 17, 0);
  cast_69_22 <= s2s_cast(b_17_35, 0, 17, 0);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity scale_b42effccbc is
  port (
    ip : in std_logic_vector((17 - 1) downto 0);
    op : out std_logic_vector((17 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end scale_b42effccbc;


architecture behavior of scale_b42effccbc is
  signal ip_17_23: signed((17 - 1) downto 0);
begin
  ip_17_23 <= std_logic_vector_to_signed(ip);
  op <= signed_to_std_logic_vector(ip_17_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_5d0bd43700 is
  port (
    a : in std_logic_vector((16 - 1) downto 0);
    b : in std_logic_vector((16 - 1) downto 0);
    s : out std_logic_vector((17 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_5d0bd43700;


architecture behavior of addsub_5d0bd43700 is
  signal a_17_32: signed((16 - 1) downto 0);
  signal b_17_35: signed((16 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((17 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "00000000000000000");
  signal op_mem_91_20_front_din: signed((17 - 1) downto 0);
  signal op_mem_91_20_back: signed((17 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((17 - 1) downto 0);
  signal cast_71_22: signed((17 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((17 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 0, 17, 0);
  cast_71_22 <= s2s_cast(b_17_35, 0, 17, 0);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  op_mem_91_20_front_din <= internal_s_71_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_24b2bc78a0 is
  port (
    a : in std_logic_vector((15 - 1) downto 0);
    b : in std_logic_vector((15 - 1) downto 0);
    s : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_24b2bc78a0;


architecture behavior of addsub_24b2bc78a0 is
  signal a_17_32: signed((15 - 1) downto 0);
  signal b_17_35: signed((15 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((16 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0000000000000000");
  signal op_mem_91_20_front_din: signed((16 - 1) downto 0);
  signal op_mem_91_20_back: signed((16 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((16 - 1) downto 0);
  signal cast_69_22: signed((16 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((16 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 14, 16, 14);
  cast_69_22 <= s2s_cast(b_17_35, 14, 16, 14);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_c7058621d7 is
  port (
    a : in std_logic_vector((22 - 1) downto 0);
    b : in std_logic_vector((22 - 1) downto 0);
    s : out std_logic_vector((22 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_c7058621d7;


architecture behavior of addsub_c7058621d7 is
  signal a_17_32: signed((22 - 1) downto 0);
  signal b_17_35: signed((22 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((22 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0000000000000000000000");
  signal op_mem_91_20_front_din: signed((22 - 1) downto 0);
  signal op_mem_91_20_back: signed((22 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((23 - 1) downto 0);
  signal cast_69_22: signed((23 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((23 - 1) downto 0);
  signal cast_internal_s_83_3_convert: signed((22 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 21, 23, 21);
  cast_69_22 <= s2s_cast(b_17_35, 21, 23, 21);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  cast_internal_s_83_3_convert <= s2s_cast(internal_s_69_5_addsub, 21, 22, 21);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_977ed7b8a2 is
  port (
    a : in std_logic_vector((22 - 1) downto 0);
    b : in std_logic_vector((22 - 1) downto 0);
    s : out std_logic_vector((22 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_977ed7b8a2;


architecture behavior of addsub_977ed7b8a2 is
  signal a_17_32: signed((22 - 1) downto 0);
  signal b_17_35: signed((22 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (2 - 1)) of signed((22 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    "0000000000000000000000",
    "0000000000000000000000");
  signal op_mem_91_20_front_din: signed((22 - 1) downto 0);
  signal op_mem_91_20_back: signed((22 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (2 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    "0",
    "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((23 - 1) downto 0);
  signal cast_71_22: signed((23 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((23 - 1) downto 0);
  signal cast_internal_s_83_3_convert: signed((22 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(1);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_91_20(i) <= op_mem_91_20(i-1);
        end loop;
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(1);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        for i_x_000000 in 1 downto 1 loop 
          cout_mem_92_22(i_x_000000) <= cout_mem_92_22(i_x_000000-1);
        end loop;
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 21, 23, 21);
  cast_71_22 <= s2s_cast(b_17_35, 21, 23, 21);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  cast_internal_s_83_3_convert <= s2s_cast(internal_s_71_5_addsub, 21, 22, 21);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_0f2f4c67a4 is
  port (
    a : in std_logic_vector((22 - 1) downto 0);
    b : in std_logic_vector((22 - 1) downto 0);
    s : out std_logic_vector((22 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_0f2f4c67a4;


architecture behavior of addsub_0f2f4c67a4 is
  signal a_17_32: signed((22 - 1) downto 0);
  signal b_17_35: signed((22 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((22 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0000000000000000000000");
  signal op_mem_91_20_front_din: signed((22 - 1) downto 0);
  signal op_mem_91_20_back: signed((22 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((23 - 1) downto 0);
  signal cast_71_22: signed((23 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((23 - 1) downto 0);
  signal cast_internal_s_83_3_convert: signed((22 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 21, 23, 21);
  cast_71_22 <= s2s_cast(b_17_35, 21, 23, 21);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  cast_internal_s_83_3_convert <= s2s_cast(internal_s_71_5_addsub, 21, 22, 21);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_9b03e3d644 is
  port (
    rst : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_9b03e3d644;


architecture behavior of counter_9b03e3d644 is
  signal rst_1_40: boolean;
  signal count_reg_20_23: unsigned((1 - 1) downto 0) := "0";
  signal count_reg_20_23_rst: std_logic;
  signal bool_44_4: boolean;
  signal rst_limit_join_44_1: boolean;
  signal count_reg_join_44_1: unsigned((2 - 1) downto 0);
  signal count_reg_join_44_1_rst: std_logic;
begin
  rst_1_40 <= ((rst) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "0";
      elsif (ce = '1') then 
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("1");
      end if;
    end if;
  end process proc_count_reg_20_23;
  bool_44_4 <= rst_1_40 or false;
  proc_if_44_1: process (bool_44_4, count_reg_20_23)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= false;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_22ce705a06 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((34 - 1) downto 0);
    d1 : in std_logic_vector((34 - 1) downto 0);
    y : out std_logic_vector((34 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_22ce705a06;


architecture behavior of mux_22ce705a06 is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((34 - 1) downto 0);
  signal d1_1_27: std_logic_vector((34 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((34 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "0000000000000000000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((34 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((34 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((34 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_b198bd62b0 is
  port (
    in0 : in std_logic_vector((18 - 1) downto 0);
    in1 : in std_logic_vector((18 - 1) downto 0);
    y : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_b198bd62b0;


architecture behavior of concat_b198bd62b0 is
  signal in0_1_23: unsigned((18 - 1) downto 0);
  signal in1_1_27: unsigned((18 - 1) downto 0);
  signal y_2_1_concat: unsigned((36 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_580feec131 is
  port (
    input_port : in std_logic_vector((18 - 1) downto 0);
    output_port : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_580feec131;


architecture behavior of reinterpret_580feec131 is
  signal input_port_1_40: signed((18 - 1) downto 0);
  signal output_port_5_5_force: unsigned((18 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_ed5d62a19c is
  port (
    a : in std_logic_vector((17 - 1) downto 0);
    b : in std_logic_vector((17 - 1) downto 0);
    s : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_ed5d62a19c;


architecture behavior of addsub_ed5d62a19c is
  signal a_17_32: signed((17 - 1) downto 0);
  signal b_17_35: signed((17 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((18 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "000000000000000000");
  signal op_mem_91_20_front_din: signed((18 - 1) downto 0);
  signal op_mem_91_20_back: signed((18 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((18 - 1) downto 0);
  signal cast_69_22: signed((18 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((18 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 0, 18, 0);
  cast_69_22 <= s2s_cast(b_17_35, 0, 18, 0);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity scale_1768584a8d is
  port (
    ip : in std_logic_vector((18 - 1) downto 0);
    op : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end scale_1768584a8d;


architecture behavior of scale_1768584a8d is
  signal ip_17_23: signed((18 - 1) downto 0);
begin
  ip_17_23 <= std_logic_vector_to_signed(ip);
  op <= signed_to_std_logic_vector(ip_17_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_cc9a7f7bbc is
  port (
    a : in std_logic_vector((17 - 1) downto 0);
    b : in std_logic_vector((17 - 1) downto 0);
    s : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_cc9a7f7bbc;


architecture behavior of addsub_cc9a7f7bbc is
  signal a_17_32: signed((17 - 1) downto 0);
  signal b_17_35: signed((17 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((18 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "000000000000000000");
  signal op_mem_91_20_front_din: signed((18 - 1) downto 0);
  signal op_mem_91_20_back: signed((18 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((18 - 1) downto 0);
  signal cast_71_22: signed((18 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((18 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 0, 18, 0);
  cast_71_22 <= s2s_cast(b_17_35, 0, 18, 0);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  op_mem_91_20_front_din <= internal_s_71_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_9a0fa0f632 is
  port (
    input_port : in std_logic_vector((18 - 1) downto 0);
    output_port : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_9a0fa0f632;


architecture behavior of reinterpret_9a0fa0f632 is
  signal input_port_1_40: unsigned((18 - 1) downto 0);
  signal output_port_5_5_force: signed((18 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_f10bd79bfe is
  port (
    a : in std_logic_vector((18 - 1) downto 0);
    b : in std_logic_vector((18 - 1) downto 0);
    s : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_f10bd79bfe;


architecture behavior of addsub_f10bd79bfe is
  signal a_17_32: signed((18 - 1) downto 0);
  signal b_17_35: signed((18 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((19 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0000000000000000000");
  signal op_mem_91_20_front_din: signed((19 - 1) downto 0);
  signal op_mem_91_20_back: signed((19 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((19 - 1) downto 0);
  signal cast_69_22: signed((19 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((19 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 0, 19, 0);
  cast_69_22 <= s2s_cast(b_17_35, 0, 19, 0);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity scale_9f61027ba4 is
  port (
    ip : in std_logic_vector((19 - 1) downto 0);
    op : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end scale_9f61027ba4;


architecture behavior of scale_9f61027ba4 is
  signal ip_17_23: signed((19 - 1) downto 0);
begin
  ip_17_23 <= std_logic_vector_to_signed(ip);
  op <= signed_to_std_logic_vector(ip_17_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_f5776ffb7e is
  port (
    a : in std_logic_vector((18 - 1) downto 0);
    b : in std_logic_vector((18 - 1) downto 0);
    s : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_f5776ffb7e;


architecture behavior of addsub_f5776ffb7e is
  signal a_17_32: signed((18 - 1) downto 0);
  signal b_17_35: signed((18 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((19 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0000000000000000000");
  signal op_mem_91_20_front_din: signed((19 - 1) downto 0);
  signal op_mem_91_20_back: signed((19 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((19 - 1) downto 0);
  signal cast_71_22: signed((19 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((19 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 0, 19, 0);
  cast_71_22 <= s2s_cast(b_17_35, 0, 19, 0);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  op_mem_91_20_front_din <= internal_s_71_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_555b5d0c45 is
  port (
    a : in std_logic_vector((17 - 1) downto 0);
    b : in std_logic_vector((17 - 1) downto 0);
    s : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_555b5d0c45;


architecture behavior of addsub_555b5d0c45 is
  signal a_17_32: signed((17 - 1) downto 0);
  signal b_17_35: signed((17 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((18 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "000000000000000000");
  signal op_mem_91_20_front_din: signed((18 - 1) downto 0);
  signal op_mem_91_20_back: signed((18 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((18 - 1) downto 0);
  signal cast_69_22: signed((18 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((18 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 16, 18, 16);
  cast_69_22 <= s2s_cast(b_17_35, 16, 18, 16);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_a90e22f5f3 is
  port (
    a : in std_logic_vector((24 - 1) downto 0);
    b : in std_logic_vector((24 - 1) downto 0);
    s : out std_logic_vector((24 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_a90e22f5f3;


architecture behavior of addsub_a90e22f5f3 is
  signal a_17_32: signed((24 - 1) downto 0);
  signal b_17_35: signed((24 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((24 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "000000000000000000000000");
  signal op_mem_91_20_front_din: signed((24 - 1) downto 0);
  signal op_mem_91_20_back: signed((24 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((25 - 1) downto 0);
  signal cast_69_22: signed((25 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((25 - 1) downto 0);
  signal cast_internal_s_83_3_convert: signed((24 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 23, 25, 23);
  cast_69_22 <= s2s_cast(b_17_35, 23, 25, 23);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  cast_internal_s_83_3_convert <= s2s_cast(internal_s_69_5_addsub, 23, 24, 23);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_0b3c6c31ef is
  port (
    a : in std_logic_vector((24 - 1) downto 0);
    b : in std_logic_vector((24 - 1) downto 0);
    s : out std_logic_vector((24 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_0b3c6c31ef;


architecture behavior of addsub_0b3c6c31ef is
  signal a_17_32: signed((24 - 1) downto 0);
  signal b_17_35: signed((24 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (2 - 1)) of signed((24 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    "000000000000000000000000",
    "000000000000000000000000");
  signal op_mem_91_20_front_din: signed((24 - 1) downto 0);
  signal op_mem_91_20_back: signed((24 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (2 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    "0",
    "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((25 - 1) downto 0);
  signal cast_71_22: signed((25 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((25 - 1) downto 0);
  signal cast_internal_s_83_3_convert: signed((24 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(1);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_91_20(i) <= op_mem_91_20(i-1);
        end loop;
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(1);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        for i_x_000000 in 1 downto 1 loop 
          cout_mem_92_22(i_x_000000) <= cout_mem_92_22(i_x_000000-1);
        end loop;
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 23, 25, 23);
  cast_71_22 <= s2s_cast(b_17_35, 23, 25, 23);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  cast_internal_s_83_3_convert <= s2s_cast(internal_s_71_5_addsub, 23, 24, 23);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_50f49c147d is
  port (
    a : in std_logic_vector((24 - 1) downto 0);
    b : in std_logic_vector((24 - 1) downto 0);
    s : out std_logic_vector((24 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_50f49c147d;


architecture behavior of addsub_50f49c147d is
  signal a_17_32: signed((24 - 1) downto 0);
  signal b_17_35: signed((24 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of signed((24 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "000000000000000000000000");
  signal op_mem_91_20_front_din: signed((24 - 1) downto 0);
  signal op_mem_91_20_back: signed((24 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((25 - 1) downto 0);
  signal cast_71_22: signed((25 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((25 - 1) downto 0);
  signal cast_internal_s_83_3_convert: signed((24 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= s2s_cast(a_17_32, 23, 25, 23);
  cast_71_22 <= s2s_cast(b_17_35, 23, 25, 23);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  cast_internal_s_83_3_convert <= s2s_cast(internal_s_71_5_addsub, 23, 24, 23);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_96d2a7e25e is
  port (
    a : in std_logic_vector((38 - 1) downto 0);
    b : in std_logic_vector((38 - 1) downto 0);
    s : out std_logic_vector((38 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_96d2a7e25e;


architecture behavior of addsub_96d2a7e25e is
  signal a_17_32: signed((38 - 1) downto 0);
  signal b_17_35: signed((38 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (2 - 1)) of unsigned((38 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    "00000000000000000000000000000000000000",
    "00000000000000000000000000000000000000");
  signal op_mem_91_20_front_din: unsigned((38 - 1) downto 0);
  signal op_mem_91_20_back: unsigned((38 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (2 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    "0",
    "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((39 - 1) downto 0);
  signal cast_69_22: signed((39 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((39 - 1) downto 0);
  signal cast_internal_s_83_3_convert: unsigned((38 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(1);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_91_20(i) <= op_mem_91_20(i-1);
        end loop;
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(1);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        for i_x_000000 in 1 downto 1 loop 
          cout_mem_92_22(i_x_000000) <= cout_mem_92_22(i_x_000000-1);
        end loop;
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 32, 39, 32);
  cast_69_22 <= s2s_cast(b_17_35, 32, 39, 32);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  cast_internal_s_83_3_convert <= s2u_cast(internal_s_69_5_addsub, 32, 38, 36);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= unsigned_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_d6fa0633b9 is
  port (
    d : in std_logic_vector((32 - 1) downto 0);
    q : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_d6fa0633b9;


architecture behavior of delay_d6fa0633b9 is
  signal d_1_22: std_logic_vector((32 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (4 - 1)) of std_logic_vector((32 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "00000000000000000000000000000000",
    "00000000000000000000000000000000",
    "00000000000000000000000000000000",
    "00000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((32 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((32 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(3);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 3 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_bab6621619 is
  port (
    d : in std_logic_vector((13 - 1) downto 0);
    q : out std_logic_vector((13 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_bab6621619;


architecture behavior of delay_bab6621619 is
  signal d_1_22: std_logic_vector((13 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (4 - 1)) of std_logic_vector((13 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "0000000000000",
    "0000000000000",
    "0000000000000",
    "0000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((13 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((13 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(3);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 3 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_c53de546ea is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_c53de546ea;


architecture behavior of delay_c53de546ea is
  signal d_1_22: std_logic;
  type array_type_op_mem_20_24 is array (0 to (4 - 1)) of std_logic;
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    '0',
    '0',
    '0',
    '0');
  signal op_mem_20_24_front_din: std_logic;
  signal op_mem_20_24_back: std_logic;
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d(0);
  op_mem_20_24_back <= op_mem_20_24(3);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 3 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= std_logic_to_vector(op_mem_20_24_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_d99e59b6d4 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_d99e59b6d4;


architecture behavior of mux_d99e59b6d4 is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic;
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  y <= std_logic_to_vector(unregy_join_6_1);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_9a13f6a2a0 is
  port (
    input_port : in std_logic_vector((64 - 1) downto 0);
    output_port : out std_logic_vector((64 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_9a13f6a2a0;


architecture behavior of reinterpret_9a13f6a2a0 is
  signal input_port_1_40: unsigned((64 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_3f7e3674f6 is
  port (
    input_port : in std_logic_vector((32 - 1) downto 0);
    output_port : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_3f7e3674f6;


architecture behavior of reinterpret_3f7e3674f6 is
  signal input_port_1_40: signed((32 - 1) downto 0);
  signal output_port_5_5_force: unsigned((32 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_0604807f72 is
  port (
    op : out std_logic_vector((11 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_0604807f72;


architecture behavior of constant_0604807f72 is
begin
  op <= "10000000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_b4b277ae0f is
  port (
    a : in std_logic_vector((11 - 1) downto 0);
    b : in std_logic_vector((11 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_b4b277ae0f;


architecture behavior of relational_b4b277ae0f is
  signal a_1_31: unsigned((11 - 1) downto 0);
  signal b_1_34: unsigned((11 - 1) downto 0);
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_14_3_rel <= a_1_31 /= b_1_34;
  op <= boolean_to_vector(result_14_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_4238e1a78a is
  port (
    a : in std_logic_vector((38 - 1) downto 0);
    b : in std_logic_vector((41 - 1) downto 0);
    s : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_4238e1a78a;


architecture behavior of addsub_4238e1a78a is
  signal a_17_32: unsigned((38 - 1) downto 0);
  signal b_17_35: signed((41 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (2 - 1)) of signed((32 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    "00000000000000000000000000000000",
    "00000000000000000000000000000000");
  signal op_mem_91_20_front_din: signed((32 - 1) downto 0);
  signal op_mem_91_20_back: signed((32 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (2 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    "0",
    "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((63 - 1) downto 0);
  signal cast_69_22: signed((63 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((63 - 1) downto 0);
  signal cast_internal_s_83_3_convert: signed((32 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_unsigned(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(1);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_91_20(i) <= op_mem_91_20(i-1);
        end loop;
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(1);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        for i_x_000000 in 1 downto 1 loop 
          cout_mem_92_22(i_x_000000) <= cout_mem_92_22(i_x_000000-1);
        end loop;
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= u2s_cast(a_17_32, 36, 63, 36);
  cast_69_22 <= s2s_cast(b_17_35, 15, 63, 36);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  cast_internal_s_83_3_convert <= s2s_cast(internal_s_69_5_addsub, 36, 32, 15);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_10eb3a1f2d is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((32 - 1) downto 0);
    d1 : in std_logic_vector((32 - 1) downto 0);
    y : out std_logic_vector((41 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_10eb3a1f2d;


architecture behavior of mux_10eb3a1f2d is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic_vector((32 - 1) downto 0);
  signal d1_1_27: std_logic_vector((32 - 1) downto 0);
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((41 - 1) downto 0);
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= cast(d0_1_24, 15, 41, 15, xlSigned);
      when others =>
        unregy_join_6_1 <= cast(d1_1_27, 6, 41, 15, xlSigned);
    end case;
  end process proc_switch_6_1;
  y <= unregy_join_6_1;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_37567836aa is
  port (
    op : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_37567836aa;


architecture behavior of constant_37567836aa is
begin
  op <= "00000000000000000000000000000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_15d98836ad is
  port (
    in0 : in std_logic_vector((8 - 1) downto 0);
    in1 : in std_logic_vector((8 - 1) downto 0);
    in2 : in std_logic_vector((8 - 1) downto 0);
    in3 : in std_logic_vector((8 - 1) downto 0);
    in4 : in std_logic_vector((8 - 1) downto 0);
    in5 : in std_logic_vector((8 - 1) downto 0);
    in6 : in std_logic_vector((8 - 1) downto 0);
    in7 : in std_logic_vector((8 - 1) downto 0);
    y : out std_logic_vector((64 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_15d98836ad;


architecture behavior of concat_15d98836ad is
  signal in0_1_23: unsigned((8 - 1) downto 0);
  signal in1_1_27: unsigned((8 - 1) downto 0);
  signal in2_1_31: unsigned((8 - 1) downto 0);
  signal in3_1_35: unsigned((8 - 1) downto 0);
  signal in4_1_39: unsigned((8 - 1) downto 0);
  signal in5_1_43: unsigned((8 - 1) downto 0);
  signal in6_1_47: unsigned((8 - 1) downto 0);
  signal in7_1_51: unsigned((8 - 1) downto 0);
  signal y_2_1_concat: unsigned((64 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  in4_1_39 <= std_logic_vector_to_unsigned(in4);
  in5_1_43 <= std_logic_vector_to_unsigned(in5);
  in6_1_47 <= std_logic_vector_to_unsigned(in6);
  in7_1_51 <= std_logic_vector_to_unsigned(in7);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35) & unsigned_to_std_logic_vector(in4_1_39) & unsigned_to_std_logic_vector(in5_1_43) & unsigned_to_std_logic_vector(in6_1_47) & unsigned_to_std_logic_vector(in7_1_51));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_23f848c85b is
  port (
    d : in std_logic_vector((8 - 1) downto 0);
    q : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_23f848c85b;


architecture behavior of delay_23f848c85b is
  signal d_1_22: std_logic_vector((8 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "00000000",
    "00000000");
  signal op_mem_20_24_front_din: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_3f5b23b538 is
  port (
    d : in std_logic_vector((32 - 1) downto 0);
    q : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_3f5b23b538;


architecture behavior of delay_3f5b23b538 is
  signal d_1_22: std_logic_vector((32 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic_vector((32 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "00000000000000000000000000000000",
    "00000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((32 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((32 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_9f02caa990 is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_9f02caa990;


architecture behavior of delay_9f02caa990 is
  signal d_1_22: std_logic;
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic;
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => '0');
  signal op_mem_20_24_front_din: std_logic;
  signal op_mem_20_24_back: std_logic;
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d(0);
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= std_logic_to_vector(op_mem_20_24_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_e18fb31a3d is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_e18fb31a3d;


architecture behavior of delay_e18fb31a3d is
  signal d_1_22: std_logic;
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic;
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    '0',
    '0');
  signal op_mem_20_24_front_din: std_logic;
  signal op_mem_20_24_back: std_logic;
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d(0);
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= std_logic_to_vector(op_mem_20_24_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_b40a532a7c is
  port (
    d : in std_logic_vector((38 - 1) downto 0);
    q : out std_logic_vector((38 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_b40a532a7c;


architecture behavior of delay_b40a532a7c is
  signal d_1_22: std_logic_vector((38 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic_vector((38 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "00000000000000000000000000000000000000",
    "00000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((38 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((38 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_d64b27fc5c is
  port (
    d : in std_logic_vector((38 - 1) downto 0);
    q : out std_logic_vector((38 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_d64b27fc5c;


architecture behavior of delay_d64b27fc5c is
  signal d_1_22: std_logic_vector((38 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((38 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "00000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((38 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((38 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_23d71a76f2 is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_23d71a76f2;


architecture behavior of delay_23d71a76f2 is
  signal d_1_22: std_logic;
  type array_type_op_mem_20_24 is array (0 to (3 - 1)) of std_logic;
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    '0',
    '0',
    '0');
  signal op_mem_20_24_front_din: std_logic;
  signal op_mem_20_24_back: std_logic;
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d(0);
  op_mem_20_24_back <= op_mem_20_24(2);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 2 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= std_logic_to_vector(op_mem_20_24_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_29899636e8 is
  port (
    d : in std_logic_vector((38 - 1) downto 0);
    q : out std_logic_vector((38 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_29899636e8;


architecture behavior of delay_29899636e8 is
  signal d_1_22: std_logic_vector((38 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (3 - 1)) of std_logic_vector((38 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "00000000000000000000000000000000000000",
    "00000000000000000000000000000000000000",
    "00000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((38 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((38 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(2);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 2 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_d51df7ac30 is
  port (
    input_port : in std_logic_vector((8 - 1) downto 0);
    output_port : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_d51df7ac30;


architecture behavior of reinterpret_d51df7ac30 is
  signal input_port_1_40: signed((8 - 1) downto 0);
  signal output_port_5_5_force: unsigned((8 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity shift_407d711ee5 is
  port (
    ip : in std_logic_vector((18 - 1) downto 0);
    op : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end shift_407d711ee5;


architecture behavior of shift_407d711ee5 is
  signal ip_1_23: unsigned((18 - 1) downto 0);
  type array_type_op_mem_46_20 is array (0 to (2 - 1)) of unsigned((18 - 1) downto 0);
  signal op_mem_46_20: array_type_op_mem_46_20 := (
    "000000000000000000",
    "000000000000000000");
  signal op_mem_46_20_front_din: unsigned((18 - 1) downto 0);
  signal op_mem_46_20_back: unsigned((18 - 1) downto 0);
  signal op_mem_46_20_push_front_pop_back_en: std_logic;
  signal cast_internal_ip_36_3_convert: unsigned((18 - 1) downto 0);
begin
  ip_1_23 <= std_logic_vector_to_unsigned(ip);
  op_mem_46_20_back <= op_mem_46_20(1);
  proc_op_mem_46_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_46_20_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_46_20(i) <= op_mem_46_20(i-1);
        end loop;
        op_mem_46_20(0) <= op_mem_46_20_front_din;
      end if;
    end if;
  end process proc_op_mem_46_20;
  cast_internal_ip_36_3_convert <= u2u_cast(ip_1_23, 2, 18, 0);
  op_mem_46_20_front_din <= cast_internal_ip_36_3_convert;
  op_mem_46_20_push_front_pop_back_en <= '1';
  op <= unsigned_to_std_logic_vector(op_mem_46_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/acc_cnt"

entity acc_cnt_entity_b52af162d4 is
  port (
    reg_out: in std_logic_vector(31 downto 0); 
    convert_x0: out std_logic_vector(31 downto 0)
  );
end acc_cnt_entity_b52af162d4;

architecture structural of acc_cnt_entity_b52af162d4 is
  signal convert_dout_net_x0: std_logic_vector(31 downto 0);
  signal delay1_q_net_x0: std_logic_vector(31 downto 0);

begin
  delay1_q_net_x0 <= reg_out;
  convert_x0 <= convert_dout_net_x0;

  convert: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => delay1_q_net_x0,
      dout => convert_dout_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/acc_cntrl/posedge1"

entity posedge1_entity_d70b7fecd6 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end posedge1_entity_d70b7fecd6;

architecture structural of posedge1_entity_d70b7fecd6 is
  signal ce_1_sg_x0: std_logic;
  signal clk_1_sg_x0: std_logic;
  signal delay_q_net: std_logic;
  signal inverter_op_net: std_logic;
  signal logical_y_net_x0: std_logic;
  signal register_q_net_x0: std_logic;

begin
  ce_1_sg_x0 <= ce_1;
  clk_1_sg_x0 <= clk_1;
  register_q_net_x0 <= in_x0;
  out_x0 <= logical_y_net_x0;

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x0,
      clk => clk_1_sg_x0,
      d(0) => register_q_net_x0,
      en => '1',
      q(0) => delay_q_net
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x0,
      clk => clk_1_sg_x0,
      clr => '0',
      ip(0) => delay_q_net,
      op(0) => inverter_op_net
    );

  logical: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => inverter_op_net,
      d1(0) => register_q_net_x0,
      y(0) => logical_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/acc_cntrl"

entity acc_cntrl_entity_1d98c79a3b is
  port (
    acc_len: in std_logic_vector(31 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync: in std_logic; 
    new_acc: out std_logic
  );
end acc_cntrl_entity_1d98c79a3b;

architecture structural of acc_cntrl_entity_1d98c79a3b is
  signal ce_1_sg_x2: std_logic;
  signal clk_1_sg_x2: std_logic;
  signal cntr_op_net: std_logic_vector(31 downto 0);
  signal delay10_q_net_x0: std_logic;
  signal delay23_q_net_x0: std_logic_vector(31 downto 0);
  signal delay_q_net: std_logic_vector(31 downto 0);
  signal logical_y_net: std_logic;
  signal logical_y_net_x0: std_logic;
  signal logical_y_net_x2: std_logic;
  signal register_q_net_x0: std_logic;
  signal relational5_op_net_x0: std_logic;
  signal shift_op_net: std_logic_vector(31 downto 0);

begin
  delay23_q_net_x0 <= acc_len;
  ce_1_sg_x2 <= ce_1;
  clk_1_sg_x2 <= clk_1;
  delay10_q_net_x0 <= sync;
  new_acc <= logical_y_net_x2;

  cntr: entity work.counter_044fafc0c4
    port map (
      ce => ce_1_sg_x2,
      clk => clk_1_sg_x2,
      clr => '0',
      rst(0) => logical_y_net,
      op => cntr_op_net
    );

  delay: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x2,
      clk => clk_1_sg_x2,
      clr => '0',
      d => shift_op_net,
      q => delay_q_net
    );

  logical: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => logical_y_net_x0,
      d1(0) => relational5_op_net_x0,
      y(0) => logical_y_net
    );

  posedge1_d70b7fecd6: entity work.posedge1_entity_d70b7fecd6
    port map (
      ce_1 => ce_1_sg_x2,
      clk_1 => clk_1_sg_x2,
      in_x0 => register_q_net_x0,
      out_x0 => logical_y_net_x0
    );

  posedge2_bcbe32b157: entity work.posedge1_entity_d70b7fecd6
    port map (
      ce_1 => ce_1_sg_x2,
      clk_1 => clk_1_sg_x2,
      in_x0 => relational5_op_net_x0,
      out_x0 => logical_y_net_x2
    );

  register_x0: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x2,
      clk => clk_1_sg_x2,
      d(0) => delay10_q_net_x0,
      en(0) => delay10_q_net_x0,
      rst => "0",
      q(0) => register_q_net_x0
    );

  relational5: entity work.relational_8782e16b67
    port map (
      a => cntr_op_net,
      b => delay_q_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational5_op_net_x0
    );

  shift: entity work.shift_657b5342cc
    port map (
      ce => ce_1_sg_x2,
      clk => clk_1_sg_x2,
      clr => '0',
      ip => delay23_q_net_x0,
      op => shift_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/adc_5g/conv"

entity conv_entity_47444a6b7b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in1: in std_logic_vector(7 downto 0); 
    out1: out std_logic_vector(7 downto 0)
  );
end conv_entity_47444a6b7b;

architecture structural of conv_entity_47444a6b7b is
  signal ce_1_sg_x3: std_logic;
  signal clk_1_sg_x3: std_logic;
  signal concat_y_net: std_logic_vector(7 downto 0);
  signal inverter_op_net: std_logic;
  signal r4_5g_specv5_adc_5g_user_datai0_net_x0: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x0: std_logic_vector(7 downto 0);
  signal slice1_y_net: std_logic_vector(6 downto 0);
  signal slice_y_net: std_logic;

begin
  ce_1_sg_x3 <= ce_1;
  clk_1_sg_x3 <= clk_1;
  r4_5g_specv5_adc_5g_user_datai0_net_x0 <= in1;
  out1 <= reinterpret_output_port_net_x0;

  concat: entity work.concat_83e473517e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => inverter_op_net,
      in1 => slice1_y_net,
      y => concat_y_net
    );

  inverter: entity work.inverter_e2b989a05e
    port map (
      ce => ce_1_sg_x3,
      clk => clk_1_sg_x3,
      clr => '0',
      ip(0) => slice_y_net,
      op(0) => inverter_op_net
    );

  reinterpret: entity work.reinterpret_4389dc89bf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concat_y_net,
      output_port => reinterpret_output_port_net_x0
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 7,
      new_msb => 7,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => r4_5g_specv5_adc_5g_user_datai0_net_x0,
      y(0) => slice_y_net
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 6,
      x_width => 8,
      y_width => 7
    )
    port map (
      x => r4_5g_specv5_adc_5g_user_datai0_net_x0,
      y => slice1_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/adc_5g"

entity adc_5g_entity_8d8c5a29fa is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    r4_5g_specv5_adc_5g_user_datai0: in std_logic_vector(7 downto 0); 
    r4_5g_specv5_adc_5g_user_datai1: in std_logic_vector(7 downto 0); 
    r4_5g_specv5_adc_5g_user_datai2: in std_logic_vector(7 downto 0); 
    r4_5g_specv5_adc_5g_user_datai3: in std_logic_vector(7 downto 0); 
    r4_5g_specv5_adc_5g_user_dataq0: in std_logic_vector(7 downto 0); 
    r4_5g_specv5_adc_5g_user_dataq1: in std_logic_vector(7 downto 0); 
    r4_5g_specv5_adc_5g_user_dataq2: in std_logic_vector(7 downto 0); 
    r4_5g_specv5_adc_5g_user_dataq3: in std_logic_vector(7 downto 0); 
    i0: out std_logic_vector(7 downto 0); 
    i1: out std_logic_vector(7 downto 0); 
    i2: out std_logic_vector(7 downto 0); 
    i3: out std_logic_vector(7 downto 0); 
    q0: out std_logic_vector(7 downto 0); 
    q1: out std_logic_vector(7 downto 0); 
    q2: out std_logic_vector(7 downto 0); 
    q3: out std_logic_vector(7 downto 0)
  );
end adc_5g_entity_8d8c5a29fa;

architecture structural of adc_5g_entity_8d8c5a29fa is
  signal ce_1_sg_x11: std_logic;
  signal clk_1_sg_x11: std_logic;
  signal r4_5g_specv5_adc_5g_user_datai0_net_x1: std_logic_vector(7 downto 0);
  signal r4_5g_specv5_adc_5g_user_datai1_net_x1: std_logic_vector(7 downto 0);
  signal r4_5g_specv5_adc_5g_user_datai2_net_x1: std_logic_vector(7 downto 0);
  signal r4_5g_specv5_adc_5g_user_datai3_net_x1: std_logic_vector(7 downto 0);
  signal r4_5g_specv5_adc_5g_user_dataq0_net_x1: std_logic_vector(7 downto 0);
  signal r4_5g_specv5_adc_5g_user_dataq1_net_x1: std_logic_vector(7 downto 0);
  signal r4_5g_specv5_adc_5g_user_dataq2_net_x1: std_logic_vector(7 downto 0);
  signal r4_5g_specv5_adc_5g_user_dataq3_net_x1: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x10: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x11: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x12: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x13: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x14: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x15: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x8: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x9: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x11 <= ce_1;
  clk_1_sg_x11 <= clk_1;
  r4_5g_specv5_adc_5g_user_datai0_net_x1 <= r4_5g_specv5_adc_5g_user_datai0;
  r4_5g_specv5_adc_5g_user_datai1_net_x1 <= r4_5g_specv5_adc_5g_user_datai1;
  r4_5g_specv5_adc_5g_user_datai2_net_x1 <= r4_5g_specv5_adc_5g_user_datai2;
  r4_5g_specv5_adc_5g_user_datai3_net_x1 <= r4_5g_specv5_adc_5g_user_datai3;
  r4_5g_specv5_adc_5g_user_dataq0_net_x1 <= r4_5g_specv5_adc_5g_user_dataq0;
  r4_5g_specv5_adc_5g_user_dataq1_net_x1 <= r4_5g_specv5_adc_5g_user_dataq1;
  r4_5g_specv5_adc_5g_user_dataq2_net_x1 <= r4_5g_specv5_adc_5g_user_dataq2;
  r4_5g_specv5_adc_5g_user_dataq3_net_x1 <= r4_5g_specv5_adc_5g_user_dataq3;
  i0 <= reinterpret_output_port_net_x8;
  i1 <= reinterpret_output_port_net_x9;
  i2 <= reinterpret_output_port_net_x10;
  i3 <= reinterpret_output_port_net_x11;
  q0 <= reinterpret_output_port_net_x12;
  q1 <= reinterpret_output_port_net_x13;
  q2 <= reinterpret_output_port_net_x14;
  q3 <= reinterpret_output_port_net_x15;

  conv1_a0b710ef7f: entity work.conv_entity_47444a6b7b
    port map (
      ce_1 => ce_1_sg_x11,
      clk_1 => clk_1_sg_x11,
      in1 => r4_5g_specv5_adc_5g_user_datai1_net_x1,
      out1 => reinterpret_output_port_net_x9
    );

  conv2_9f25c0945b: entity work.conv_entity_47444a6b7b
    port map (
      ce_1 => ce_1_sg_x11,
      clk_1 => clk_1_sg_x11,
      in1 => r4_5g_specv5_adc_5g_user_datai2_net_x1,
      out1 => reinterpret_output_port_net_x10
    );

  conv3_7c23520bfd: entity work.conv_entity_47444a6b7b
    port map (
      ce_1 => ce_1_sg_x11,
      clk_1 => clk_1_sg_x11,
      in1 => r4_5g_specv5_adc_5g_user_datai3_net_x1,
      out1 => reinterpret_output_port_net_x11
    );

  conv4_3b9b597490: entity work.conv_entity_47444a6b7b
    port map (
      ce_1 => ce_1_sg_x11,
      clk_1 => clk_1_sg_x11,
      in1 => r4_5g_specv5_adc_5g_user_dataq0_net_x1,
      out1 => reinterpret_output_port_net_x12
    );

  conv5_1cd260b861: entity work.conv_entity_47444a6b7b
    port map (
      ce_1 => ce_1_sg_x11,
      clk_1 => clk_1_sg_x11,
      in1 => r4_5g_specv5_adc_5g_user_dataq1_net_x1,
      out1 => reinterpret_output_port_net_x13
    );

  conv6_5eaab60e08: entity work.conv_entity_47444a6b7b
    port map (
      ce_1 => ce_1_sg_x11,
      clk_1 => clk_1_sg_x11,
      in1 => r4_5g_specv5_adc_5g_user_dataq2_net_x1,
      out1 => reinterpret_output_port_net_x14
    );

  conv7_11cbdf83aa: entity work.conv_entity_47444a6b7b
    port map (
      ce_1 => ce_1_sg_x11,
      clk_1 => clk_1_sg_x11,
      in1 => r4_5g_specv5_adc_5g_user_dataq3_net_x1,
      out1 => reinterpret_output_port_net_x15
    );

  conv_47444a6b7b: entity work.conv_entity_47444a6b7b
    port map (
      ce_1 => ce_1_sg_x11,
      clk_1 => clk_1_sg_x11,
      in1 => r4_5g_specv5_adc_5g_user_datai0_net_x1,
      out1 => reinterpret_output_port_net_x8
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_quantize/c_to_ri"

entity c_to_ri_entity_fe9d761bb1 is
  port (
    c: in std_logic_vector(33 downto 0); 
    im: out std_logic_vector(16 downto 0); 
    re: out std_logic_vector(16 downto 0)
  );
end c_to_ri_entity_fe9d761bb1;

architecture structural of c_to_ri_entity_fe9d761bb1 is
  signal concat_y_net_x0: std_logic_vector(33 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(16 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(16 downto 0);
  signal slice_im_y_net: std_logic_vector(16 downto 0);
  signal slice_re_y_net: std_logic_vector(16 downto 0);

begin
  concat_y_net_x0 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_ea71bb555c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_ea71bb555c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 16,
      x_width => 34,
      y_width => 17
    )
    port map (
      x => concat_y_net_x0,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 17,
      new_msb => 33,
      x_width => 34,
      y_width => 17
    )
    port map (
      x => concat_y_net_x0,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_quantize/ri_to_c"

entity ri_to_c_entity_e0bf40ff62 is
  port (
    im: in std_logic_vector(8 downto 0); 
    re: in std_logic_vector(8 downto 0); 
    c: out std_logic_vector(17 downto 0)
  );
end ri_to_c_entity_e0bf40ff62;

architecture structural of ri_to_c_entity_e0bf40ff62 is
  signal concat_y_net_x0: std_logic_vector(17 downto 0);
  signal force_im_output_port_net: std_logic_vector(8 downto 0);
  signal force_re_output_port_net: std_logic_vector(8 downto 0);
  signal quantize_im_dout_net_x0: std_logic_vector(8 downto 0);
  signal quantize_re_dout_net_x0: std_logic_vector(8 downto 0);

begin
  quantize_im_dout_net_x0 <= im;
  quantize_re_dout_net_x0 <= re;
  c <= concat_y_net_x0;

  concat: entity work.concat_f2f6490a28
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x0
    );

  force_im: entity work.reinterpret_de38ef9df5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => quantize_im_dout_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_de38ef9df5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => quantize_re_dout_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_quantize"

entity fir_quantize_entity_159d90c3b8 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sum_in: in std_logic_vector(33 downto 0); 
    sum_out: out std_logic_vector(17 downto 0)
  );
end fir_quantize_entity_159d90c3b8;

architecture structural of fir_quantize_entity_159d90c3b8 is
  signal ce_1_sg_x12: std_logic;
  signal clk_1_sg_x12: std_logic;
  signal concat_y_net_x2: std_logic_vector(33 downto 0);
  signal concat_y_net_x3: std_logic_vector(17 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(16 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(16 downto 0);
  signal quantize_im_dout_net_x0: std_logic_vector(8 downto 0);
  signal quantize_re_dout_net_x0: std_logic_vector(8 downto 0);

begin
  ce_1_sg_x12 <= ce_1;
  clk_1_sg_x12 <= clk_1;
  concat_y_net_x2 <= sum_in;
  sum_out <= concat_y_net_x3;

  c_to_ri_fe9d761bb1: entity work.c_to_ri_entity_fe9d761bb1
    port map (
      c => concat_y_net_x2,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  quantize_im: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 15,
      din_width => 17,
      dout_arith => 2,
      dout_bin_pt => 7,
      dout_width => 9,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x12,
      clk => clk_1_sg_x12,
      clr => '0',
      din => force_im_output_port_net_x0,
      dout => quantize_im_dout_net_x0
    );

  quantize_re: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 15,
      din_width => 17,
      dout_arith => 2,
      dout_bin_pt => 7,
      dout_width => 9,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x12,
      clk => clk_1_sg_x12,
      clr => '0',
      din => force_re_output_port_net_x0,
      dout => quantize_re_dout_net_x0
    );

  ri_to_c_e0bf40ff62: entity work.ri_to_c_entity_e0bf40ff62
    port map (
      im => quantize_im_dout_net_x0,
      re => quantize_re_dout_net_x0,
      c => concat_y_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_1/fir_coef/c_gen"

entity c_gen_entity_a4fea711a5 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    coef_out: out std_logic_vector(8 downto 0)
  );
end c_gen_entity_a4fea711a5;

architecture structural of c_gen_entity_a4fea711a5 is
  signal addr_sel_y_net: std_logic_vector(9 downto 0);
  signal ce_1_sg_x13: std_logic;
  signal clk_1_sg_x13: std_logic;
  signal counter_op_net: std_logic_vector(9 downto 0);
  signal delay7_q_net_x0: std_logic;
  signal mem_data_net_x0: std_logic_vector(8 downto 0);

begin
  ce_1_sg_x13 <= ce_1;
  clk_1_sg_x13 <= clk_1;
  delay7_q_net_x0 <= sync_in;
  coef_out <= mem_data_net_x0;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 9,
      x_width => 10,
      y_width => 10
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_limit
    generic map (
      cnt_15_0 => 1023,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "binary_counter_virtex5_10_0_1ee993c8ed57b9ce",
      count_limited => 0,
      op_arith => xlUnsigned,
      op_width => 10
    )
    port map (
      ce => ce_1_sg_x13,
      clk => clk_1_sg_x13,
      clr => '0',
      en => "1",
      rst(0) => delay7_q_net_x0,
      op => counter_op_net
    );

  mem: entity work.xlsprom
    generic map (
      c_address_width => 10,
      c_width => 9,
      core_name0 => "bmg_24_vx5_916edb207080a9d0",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x13,
      clk => clk_1_sg_x13,
      en => "1",
      rst => "0",
      data => mem_data_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_1/fir_coef"

entity fir_coef_entity_8b710ddd57 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(7 downto 0); 
    sync_in: in std_logic; 
    coef: out std_logic_vector(8 downto 0); 
    data_out: out std_logic_vector(7 downto 0); 
    sync_out: out std_logic
  );
end fir_coef_entity_8b710ddd57;

architecture structural of fir_coef_entity_8b710ddd57 is
  signal ce_1_sg_x14: std_logic;
  signal clk_1_sg_x14: std_logic;
  signal data_delay_q_net_x0: std_logic_vector(7 downto 0);
  signal delay7_q_net_x1: std_logic;
  signal delay_q_net_x0: std_logic_vector(7 downto 0);
  signal mem_data_net_x1: std_logic_vector(8 downto 0);
  signal sync_delay_q_net_x0: std_logic;

begin
  ce_1_sg_x14 <= ce_1;
  clk_1_sg_x14 <= clk_1;
  delay_q_net_x0 <= data_in;
  delay7_q_net_x1 <= sync_in;
  coef <= mem_data_net_x1;
  data_out <= data_delay_q_net_x0;
  sync_out <= sync_delay_q_net_x0;

  c_gen_a4fea711a5: entity work.c_gen_entity_a4fea711a5
    port map (
      ce_1 => ce_1_sg_x14,
      clk_1 => clk_1_sg_x14,
      sync_in => delay7_q_net_x1,
      coef_out => mem_data_net_x1
    );

  data_delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      d => delay_q_net_x0,
      en => '1',
      q => data_delay_q_net_x0
    );

  sync_delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x14,
      clk => clk_1_sg_x14,
      d(0) => delay7_q_net_x1,
      en => '1',
      q(0) => sync_delay_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_1/fir_core/c_to_ri_d"

entity c_to_ri_d_entity_f9c71271a8 is
  port (
    c: in std_logic_vector(7 downto 0); 
    im: out std_logic_vector(7 downto 0); 
    re: out std_logic_vector(7 downto 0)
  );
end c_to_ri_d_entity_f9c71271a8;

architecture structural of c_to_ri_d_entity_f9c71271a8 is
  signal data_delay_q_net_x1: std_logic_vector(7 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(7 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(7 downto 0);
  signal slice_im_y_net: std_logic_vector(7 downto 0);
  signal slice_re_y_net: std_logic_vector(7 downto 0);

begin
  data_delay_q_net_x1 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_4389dc89bf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_4389dc89bf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 8,
      y_width => 8
    )
    port map (
      x => data_delay_q_net_x1,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 8,
      y_width => 8
    )
    port map (
      x => data_delay_q_net_x1,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_1/fir_core/mult_add_im"

entity mult_add_im_entity_27fd95e9cc is
  port (
    a: in std_logic_vector(7 downto 0); 
    b: in std_logic_vector(8 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    out_x0: out std_logic_vector(16 downto 0)
  );
end mult_add_im_entity_27fd95e9cc;

architecture structural of mult_add_im_entity_27fd95e9cc is
  signal ce_1_sg_x15: std_logic;
  signal clk_1_sg_x15: std_logic;
  signal force_im_output_port_net_x1: std_logic_vector(7 downto 0);
  signal mem_data_net_x2: std_logic_vector(8 downto 0);
  signal mult_p_net_x0: std_logic_vector(16 downto 0);

begin
  force_im_output_port_net_x1 <= a;
  mem_data_net_x2 <= b;
  ce_1_sg_x15 <= ce_1;
  clk_1_sg_x15 <= clk_1;
  out_x0 <= mult_p_net_x0;

  mult: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 8,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 8,
      c_output_width => 17,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_2f77ace24e40581e",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 17,
      quantization => 1
    )
    port map (
      a => force_im_output_port_net_x1,
      b => mem_data_net_x2,
      ce => ce_1_sg_x15,
      clk => clk_1_sg_x15,
      clr => '0',
      core_ce => ce_1_sg_x15,
      core_clk => clk_1_sg_x15,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult_p_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_1/fir_core/ri_to_c"

entity ri_to_c_entity_007b667efe is
  port (
    im: in std_logic_vector(16 downto 0); 
    re: in std_logic_vector(16 downto 0); 
    c: out std_logic_vector(33 downto 0)
  );
end ri_to_c_entity_007b667efe;

architecture structural of ri_to_c_entity_007b667efe is
  signal concat_y_net_x0: std_logic_vector(33 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(16 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(16 downto 0);
  signal force_im_output_port_net: std_logic_vector(16 downto 0);
  signal force_re_output_port_net: std_logic_vector(16 downto 0);

begin
  convert_im_dout_net_x0 <= im;
  convert_re_dout_net_x0 <= re;
  c <= concat_y_net_x0;

  concat: entity work.concat_25b7e1d1f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x0
    );

  force_im: entity work.reinterpret_573890e1c0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert_im_dout_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_573890e1c0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert_re_dout_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_1/fir_core/tap_delay"

entity tap_delay_entity_8b0b4ca2e5 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(7 downto 0); 
    out_x0: out std_logic_vector(7 downto 0)
  );
end tap_delay_entity_8b0b4ca2e5;

architecture structural of tap_delay_entity_8b0b4ca2e5 is
  signal bram_data_out_net_x0: std_logic_vector(7 downto 0);
  signal ce_1_sg_x17: std_logic;
  signal clk_1_sg_x17: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(9 downto 0);
  signal dout_delay_q_net_x0: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x17 <= ce_1;
  clk_1_sg_x17 <= clk_1;
  dout_delay_q_net_x0 <= in_x0;
  out_x0 <= bram_data_out_net_x0;

  bram: entity work.xlspram
    generic map (
      c_address_width => 10,
      c_width => 8,
      core_name0 => "bmg_24_vx5_b3a285035a3712ee",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x17,
      clk => clk_1_sg_x17,
      data_in => dout_delay_q_net_x0,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => bram_data_out_net_x0
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit
    generic map (
      cnt_15_0 => 1022,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "binary_counter_virtex5_10_0_1ee993c8ed57b9ce",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 10
    )
    port map (
      ce => ce_1_sg_x17,
      clk => clk_1_sg_x17,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_1/fir_core"

entity fir_core_entity_9dfb5ea5d5 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    coef: in std_logic_vector(8 downto 0); 
    data_in: in std_logic_vector(7 downto 0); 
    sync_in: in std_logic; 
    data_out: out std_logic_vector(7 downto 0); 
    sum_out: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end fir_core_entity_9dfb5ea5d5;

architecture structural of fir_core_entity_9dfb5ea5d5 is
  signal bram_data_out_net_x1: std_logic_vector(7 downto 0);
  signal ce_1_sg_x18: std_logic;
  signal clk_1_sg_x18: std_logic;
  signal concat_y_net_x1: std_logic_vector(33 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(16 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(16 downto 0);
  signal data_delay_q_net_x2: std_logic_vector(7 downto 0);
  signal dout_delay_q_net_x0: std_logic_vector(7 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(7 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(7 downto 0);
  signal mem_data_net_x4: std_logic_vector(8 downto 0);
  signal mult_p_net_x0: std_logic_vector(16 downto 0);
  signal mult_p_net_x1: std_logic_vector(16 downto 0);
  signal sync_delay_q_net_x1: std_logic;
  signal sync_delay_q_net_x2: std_logic;

begin
  ce_1_sg_x18 <= ce_1;
  clk_1_sg_x18 <= clk_1;
  mem_data_net_x4 <= coef;
  data_delay_q_net_x2 <= data_in;
  sync_delay_q_net_x1 <= sync_in;
  data_out <= bram_data_out_net_x1;
  sum_out <= concat_y_net_x1;
  sync_out <= sync_delay_q_net_x2;

  c_to_ri_d_f9c71271a8: entity work.c_to_ri_d_entity_f9c71271a8
    port map (
      c => data_delay_q_net_x2,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  convert_im: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 15,
      din_width => 17,
      dout_arith => 2,
      dout_bin_pt => 15,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => mult_p_net_x0,
      dout => convert_im_dout_net_x0
    );

  convert_re: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 15,
      din_width => 17,
      dout_arith => 2,
      dout_bin_pt => 15,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => mult_p_net_x1,
      dout => convert_re_dout_net_x0
    );

  dout_delay: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x18,
      clk => clk_1_sg_x18,
      d => data_delay_q_net_x2,
      en => '1',
      q => dout_delay_q_net_x0
    );

  mult_add_im_27fd95e9cc: entity work.mult_add_im_entity_27fd95e9cc
    port map (
      a => force_im_output_port_net_x1,
      b => mem_data_net_x4,
      ce_1 => ce_1_sg_x18,
      clk_1 => clk_1_sg_x18,
      out_x0 => mult_p_net_x0
    );

  mult_add_re_1a49ae095c: entity work.mult_add_im_entity_27fd95e9cc
    port map (
      a => force_re_output_port_net_x1,
      b => mem_data_net_x4,
      ce_1 => ce_1_sg_x18,
      clk_1 => clk_1_sg_x18,
      out_x0 => mult_p_net_x1
    );

  ri_to_c_007b667efe: entity work.ri_to_c_entity_007b667efe
    port map (
      im => convert_im_dout_net_x0,
      re => convert_re_dout_net_x0,
      c => concat_y_net_x1
    );

  sync_delay: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x18,
      clk => clk_1_sg_x18,
      d(0) => sync_delay_q_net_x1,
      en => '1',
      q(0) => sync_delay_q_net_x2
    );

  tap_delay_8b0b4ca2e5: entity work.tap_delay_entity_8b0b4ca2e5
    port map (
      ce_1 => ce_1_sg_x18,
      clk_1 => clk_1_sg_x18,
      in_x0 => dout_delay_q_net_x0,
      out_x0 => bram_data_out_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_1"

entity fir_tap_1_entity_b409832013 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(7 downto 0); 
    sync_in: in std_logic; 
    data_out: out std_logic_vector(7 downto 0); 
    sum_out: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end fir_tap_1_entity_b409832013;

architecture structural of fir_tap_1_entity_b409832013 is
  signal bram_data_out_net_x2: std_logic_vector(7 downto 0);
  signal ce_1_sg_x19: std_logic;
  signal clk_1_sg_x19: std_logic;
  signal concat_y_net_x2: std_logic_vector(33 downto 0);
  signal data_delay_q_net_x2: std_logic_vector(7 downto 0);
  signal delay7_q_net_x2: std_logic;
  signal delay_q_net_x1: std_logic_vector(7 downto 0);
  signal mem_data_net_x4: std_logic_vector(8 downto 0);
  signal sync_delay_q_net_x1: std_logic;
  signal sync_delay_q_net_x3: std_logic;

begin
  ce_1_sg_x19 <= ce_1;
  clk_1_sg_x19 <= clk_1;
  delay_q_net_x1 <= data_in;
  delay7_q_net_x2 <= sync_in;
  data_out <= bram_data_out_net_x2;
  sum_out <= concat_y_net_x2;
  sync_out <= sync_delay_q_net_x3;

  fir_coef_8b710ddd57: entity work.fir_coef_entity_8b710ddd57
    port map (
      ce_1 => ce_1_sg_x19,
      clk_1 => clk_1_sg_x19,
      data_in => delay_q_net_x1,
      sync_in => delay7_q_net_x2,
      coef => mem_data_net_x4,
      data_out => data_delay_q_net_x2,
      sync_out => sync_delay_q_net_x1
    );

  fir_core_9dfb5ea5d5: entity work.fir_core_entity_9dfb5ea5d5
    port map (
      ce_1 => ce_1_sg_x19,
      clk_1 => clk_1_sg_x19,
      coef => mem_data_net_x4,
      data_in => data_delay_q_net_x2,
      sync_in => sync_delay_q_net_x1,
      data_out => bram_data_out_net_x2,
      sum_out => concat_y_net_x2,
      sync_out => sync_delay_q_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_2/fir_coef/c_gen"

entity c_gen_entity_148c3edefd is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    coef_out: out std_logic_vector(8 downto 0)
  );
end c_gen_entity_148c3edefd;

architecture structural of c_gen_entity_148c3edefd is
  signal addr_sel_y_net: std_logic_vector(9 downto 0);
  signal ce_1_sg_x20: std_logic;
  signal clk_1_sg_x20: std_logic;
  signal counter_op_net: std_logic_vector(9 downto 0);
  signal mem_data_net_x0: std_logic_vector(8 downto 0);
  signal sync_delay_q_net_x4: std_logic;

begin
  ce_1_sg_x20 <= ce_1;
  clk_1_sg_x20 <= clk_1;
  sync_delay_q_net_x4 <= sync_in;
  coef_out <= mem_data_net_x0;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 9,
      x_width => 10,
      y_width => 10
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_limit
    generic map (
      cnt_15_0 => 1023,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "binary_counter_virtex5_10_0_1ee993c8ed57b9ce",
      count_limited => 0,
      op_arith => xlUnsigned,
      op_width => 10
    )
    port map (
      ce => ce_1_sg_x20,
      clk => clk_1_sg_x20,
      clr => '0',
      en => "1",
      rst(0) => sync_delay_q_net_x4,
      op => counter_op_net
    );

  mem: entity work.xlsprom
    generic map (
      c_address_width => 10,
      c_width => 9,
      core_name0 => "bmg_24_vx5_17f5cef47a567d97",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x20,
      clk => clk_1_sg_x20,
      en => "1",
      rst => "0",
      data => mem_data_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_2/fir_coef"

entity fir_coef_entity_8033da333b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(7 downto 0); 
    sum_in: in std_logic_vector(33 downto 0); 
    sync_in: in std_logic; 
    coef: out std_logic_vector(8 downto 0); 
    data_out: out std_logic_vector(7 downto 0); 
    sum_out: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end fir_coef_entity_8033da333b;

architecture structural of fir_coef_entity_8033da333b is
  signal bram_data_out_net_x3: std_logic_vector(7 downto 0);
  signal ce_1_sg_x21: std_logic;
  signal clk_1_sg_x21: std_logic;
  signal concat_y_net_x3: std_logic_vector(33 downto 0);
  signal data_delay_q_net_x0: std_logic_vector(7 downto 0);
  signal mem_data_net_x1: std_logic_vector(8 downto 0);
  signal sum_delay_q_net_x0: std_logic_vector(33 downto 0);
  signal sync_delay_q_net_x0: std_logic;
  signal sync_delay_q_net_x5: std_logic;

begin
  ce_1_sg_x21 <= ce_1;
  clk_1_sg_x21 <= clk_1;
  bram_data_out_net_x3 <= data_in;
  concat_y_net_x3 <= sum_in;
  sync_delay_q_net_x5 <= sync_in;
  coef <= mem_data_net_x1;
  data_out <= data_delay_q_net_x0;
  sum_out <= sum_delay_q_net_x0;
  sync_out <= sync_delay_q_net_x0;

  c_gen_148c3edefd: entity work.c_gen_entity_148c3edefd
    port map (
      ce_1 => ce_1_sg_x21,
      clk_1 => clk_1_sg_x21,
      sync_in => sync_delay_q_net_x5,
      coef_out => mem_data_net_x1
    );

  data_delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x21,
      clk => clk_1_sg_x21,
      d => bram_data_out_net_x3,
      en => '1',
      q => data_delay_q_net_x0
    );

  sum_delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 34
    )
    port map (
      ce => ce_1_sg_x21,
      clk => clk_1_sg_x21,
      d => concat_y_net_x3,
      en => '1',
      q => sum_delay_q_net_x0
    );

  sync_delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x21,
      clk => clk_1_sg_x21,
      d(0) => sync_delay_q_net_x5,
      en => '1',
      q(0) => sync_delay_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_2/fir_core/mult_add_im"

entity mult_add_im_entity_5625f0db12 is
  port (
    a: in std_logic_vector(7 downto 0); 
    b: in std_logic_vector(8 downto 0); 
    c: in std_logic_vector(16 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    out_x0: out std_logic_vector(17 downto 0)
  );
end mult_add_im_entity_5625f0db12;

architecture structural of mult_add_im_entity_5625f0db12 is
  signal add_s_net_x0: std_logic_vector(17 downto 0);
  signal ce_1_sg_x22: std_logic;
  signal clk_1_sg_x22: std_logic;
  signal delay_q_net: std_logic_vector(16 downto 0);
  signal force_im_output_port_net_x2: std_logic_vector(7 downto 0);
  signal force_im_output_port_net_x3: std_logic_vector(16 downto 0);
  signal mem_data_net_x2: std_logic_vector(8 downto 0);
  signal mult_p_net: std_logic_vector(16 downto 0);

begin
  force_im_output_port_net_x2 <= a;
  mem_data_net_x2 <= b;
  force_im_output_port_net_x3 <= c;
  ce_1_sg_x22 <= ce_1;
  clk_1_sg_x22 <= clk_1;
  out_x0 <= add_s_net_x0;

  add: entity work.addsub_bfd97cd167
    port map (
      a => mult_p_net,
      b => delay_q_net,
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      clr => '0',
      s => add_s_net_x0
    );

  delay: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      width => 17
    )
    port map (
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      d => force_im_output_port_net_x3,
      en => '1',
      q => delay_q_net
    );

  mult: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 8,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 8,
      c_output_width => 17,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_2f77ace24e40581e",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 15,
      p_width => 17,
      quantization => 1
    )
    port map (
      a => force_im_output_port_net_x2,
      b => mem_data_net_x2,
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      clr => '0',
      core_ce => ce_1_sg_x22,
      core_clk => clk_1_sg_x22,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult_p_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_2/fir_core"

entity fir_core_entity_3b628b72bc is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    coef: in std_logic_vector(8 downto 0); 
    data_in: in std_logic_vector(7 downto 0); 
    sum_in: in std_logic_vector(33 downto 0); 
    sync_in: in std_logic; 
    data_out: out std_logic_vector(7 downto 0); 
    sum_out: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end fir_core_entity_3b628b72bc;

architecture structural of fir_core_entity_3b628b72bc is
  signal add_s_net_x0: std_logic_vector(17 downto 0);
  signal add_s_net_x1: std_logic_vector(17 downto 0);
  signal bram_data_out_net_x1: std_logic_vector(7 downto 0);
  signal ce_1_sg_x25: std_logic;
  signal clk_1_sg_x25: std_logic;
  signal concat_y_net_x1: std_logic_vector(33 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(16 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(16 downto 0);
  signal data_delay_q_net_x2: std_logic_vector(7 downto 0);
  signal dout_delay_q_net_x0: std_logic_vector(7 downto 0);
  signal force_im_output_port_net_x2: std_logic_vector(7 downto 0);
  signal force_im_output_port_net_x3: std_logic_vector(16 downto 0);
  signal force_re_output_port_net_x2: std_logic_vector(7 downto 0);
  signal force_re_output_port_net_x3: std_logic_vector(16 downto 0);
  signal mem_data_net_x4: std_logic_vector(8 downto 0);
  signal sum_delay_q_net_x2: std_logic_vector(33 downto 0);
  signal sync_delay_q_net_x1: std_logic;
  signal sync_delay_q_net_x2: std_logic;

begin
  ce_1_sg_x25 <= ce_1;
  clk_1_sg_x25 <= clk_1;
  mem_data_net_x4 <= coef;
  data_delay_q_net_x2 <= data_in;
  sum_delay_q_net_x2 <= sum_in;
  sync_delay_q_net_x1 <= sync_in;
  data_out <= bram_data_out_net_x1;
  sum_out <= concat_y_net_x1;
  sync_out <= sync_delay_q_net_x2;

  c_to_ri_d_53a93a8a6e: entity work.c_to_ri_d_entity_f9c71271a8
    port map (
      c => data_delay_q_net_x2,
      im => force_im_output_port_net_x2,
      re => force_re_output_port_net_x2
    );

  c_to_ri_s_0b69c9b0e2: entity work.c_to_ri_entity_fe9d761bb1
    port map (
      c => sum_delay_q_net_x2,
      im => force_im_output_port_net_x3,
      re => force_re_output_port_net_x3
    );

  convert_im: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 15,
      din_width => 18,
      dout_arith => 2,
      dout_bin_pt => 15,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => add_s_net_x0,
      dout => convert_im_dout_net_x0
    );

  convert_re: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 15,
      din_width => 18,
      dout_arith => 2,
      dout_bin_pt => 15,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => add_s_net_x1,
      dout => convert_re_dout_net_x0
    );

  dout_delay: entity work.xldelay
    generic map (
      latency => 4,
      reg_retiming => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      d => data_delay_q_net_x2,
      en => '1',
      q => dout_delay_q_net_x0
    );

  mult_add_im_5625f0db12: entity work.mult_add_im_entity_5625f0db12
    port map (
      a => force_im_output_port_net_x2,
      b => mem_data_net_x4,
      c => force_im_output_port_net_x3,
      ce_1 => ce_1_sg_x25,
      clk_1 => clk_1_sg_x25,
      out_x0 => add_s_net_x0
    );

  mult_add_re_eea8d71dee: entity work.mult_add_im_entity_5625f0db12
    port map (
      a => force_re_output_port_net_x2,
      b => mem_data_net_x4,
      c => force_re_output_port_net_x3,
      ce_1 => ce_1_sg_x25,
      clk_1 => clk_1_sg_x25,
      out_x0 => add_s_net_x1
    );

  ri_to_c_59e827f4c1: entity work.ri_to_c_entity_007b667efe
    port map (
      im => convert_im_dout_net_x0,
      re => convert_re_dout_net_x0,
      c => concat_y_net_x1
    );

  sync_delay: entity work.xldelay
    generic map (
      latency => 4,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      d(0) => sync_delay_q_net_x1,
      en => '1',
      q(0) => sync_delay_q_net_x2
    );

  tap_delay_9ce863f294: entity work.tap_delay_entity_8b0b4ca2e5
    port map (
      ce_1 => ce_1_sg_x25,
      clk_1 => clk_1_sg_x25,
      in_x0 => dout_delay_q_net_x0,
      out_x0 => bram_data_out_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_2"

entity fir_tap_2_entity_de2966bf5b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(7 downto 0); 
    sum_in: in std_logic_vector(33 downto 0); 
    sync_in: in std_logic; 
    data_out: out std_logic_vector(7 downto 0); 
    sum_out: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end fir_tap_2_entity_de2966bf5b;

architecture structural of fir_tap_2_entity_de2966bf5b is
  signal bram_data_out_net_x4: std_logic_vector(7 downto 0);
  signal bram_data_out_net_x5: std_logic_vector(7 downto 0);
  signal ce_1_sg_x26: std_logic;
  signal clk_1_sg_x26: std_logic;
  signal concat_y_net_x4: std_logic_vector(33 downto 0);
  signal concat_y_net_x5: std_logic_vector(33 downto 0);
  signal data_delay_q_net_x2: std_logic_vector(7 downto 0);
  signal mem_data_net_x4: std_logic_vector(8 downto 0);
  signal sum_delay_q_net_x2: std_logic_vector(33 downto 0);
  signal sync_delay_q_net_x1: std_logic;
  signal sync_delay_q_net_x6: std_logic;
  signal sync_delay_q_net_x7: std_logic;

begin
  ce_1_sg_x26 <= ce_1;
  clk_1_sg_x26 <= clk_1;
  bram_data_out_net_x4 <= data_in;
  concat_y_net_x4 <= sum_in;
  sync_delay_q_net_x6 <= sync_in;
  data_out <= bram_data_out_net_x5;
  sum_out <= concat_y_net_x5;
  sync_out <= sync_delay_q_net_x7;

  fir_coef_8033da333b: entity work.fir_coef_entity_8033da333b
    port map (
      ce_1 => ce_1_sg_x26,
      clk_1 => clk_1_sg_x26,
      data_in => bram_data_out_net_x4,
      sum_in => concat_y_net_x4,
      sync_in => sync_delay_q_net_x6,
      coef => mem_data_net_x4,
      data_out => data_delay_q_net_x2,
      sum_out => sum_delay_q_net_x2,
      sync_out => sync_delay_q_net_x1
    );

  fir_core_3b628b72bc: entity work.fir_core_entity_3b628b72bc
    port map (
      ce_1 => ce_1_sg_x26,
      clk_1 => clk_1_sg_x26,
      coef => mem_data_net_x4,
      data_in => data_delay_q_net_x2,
      sum_in => sum_delay_q_net_x2,
      sync_in => sync_delay_q_net_x1,
      data_out => bram_data_out_net_x5,
      sum_out => concat_y_net_x5,
      sync_out => sync_delay_q_net_x7
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_3/fir_coef/c_gen"

entity c_gen_entity_6b8ad9a4f8 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    coef_out: out std_logic_vector(8 downto 0)
  );
end c_gen_entity_6b8ad9a4f8;

architecture structural of c_gen_entity_6b8ad9a4f8 is
  signal addr_sel_y_net: std_logic_vector(9 downto 0);
  signal ce_1_sg_x27: std_logic;
  signal clk_1_sg_x27: std_logic;
  signal counter_op_net: std_logic_vector(9 downto 0);
  signal mem_data_net_x0: std_logic_vector(8 downto 0);
  signal sync_delay_q_net_x8: std_logic;

begin
  ce_1_sg_x27 <= ce_1;
  clk_1_sg_x27 <= clk_1;
  sync_delay_q_net_x8 <= sync_in;
  coef_out <= mem_data_net_x0;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 9,
      x_width => 10,
      y_width => 10
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_limit
    generic map (
      cnt_15_0 => 1023,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "binary_counter_virtex5_10_0_1ee993c8ed57b9ce",
      count_limited => 0,
      op_arith => xlUnsigned,
      op_width => 10
    )
    port map (
      ce => ce_1_sg_x27,
      clk => clk_1_sg_x27,
      clr => '0',
      en => "1",
      rst(0) => sync_delay_q_net_x8,
      op => counter_op_net
    );

  mem: entity work.xlsprom
    generic map (
      c_address_width => 10,
      c_width => 9,
      core_name0 => "bmg_24_vx5_22468d6827fd0e85",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x27,
      clk => clk_1_sg_x27,
      en => "1",
      rst => "0",
      data => mem_data_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_3/fir_coef"

entity fir_coef_entity_5e5fcf201a is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(7 downto 0); 
    sum_in: in std_logic_vector(33 downto 0); 
    sync_in: in std_logic; 
    coef: out std_logic_vector(8 downto 0); 
    data_out: out std_logic_vector(7 downto 0); 
    sum_out: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end fir_coef_entity_5e5fcf201a;

architecture structural of fir_coef_entity_5e5fcf201a is
  signal bram_data_out_net_x6: std_logic_vector(7 downto 0);
  signal ce_1_sg_x28: std_logic;
  signal clk_1_sg_x28: std_logic;
  signal concat_y_net_x6: std_logic_vector(33 downto 0);
  signal data_delay_q_net_x0: std_logic_vector(7 downto 0);
  signal mem_data_net_x1: std_logic_vector(8 downto 0);
  signal sum_delay_q_net_x0: std_logic_vector(33 downto 0);
  signal sync_delay_q_net_x0: std_logic;
  signal sync_delay_q_net_x9: std_logic;

begin
  ce_1_sg_x28 <= ce_1;
  clk_1_sg_x28 <= clk_1;
  bram_data_out_net_x6 <= data_in;
  concat_y_net_x6 <= sum_in;
  sync_delay_q_net_x9 <= sync_in;
  coef <= mem_data_net_x1;
  data_out <= data_delay_q_net_x0;
  sum_out <= sum_delay_q_net_x0;
  sync_out <= sync_delay_q_net_x0;

  c_gen_6b8ad9a4f8: entity work.c_gen_entity_6b8ad9a4f8
    port map (
      ce_1 => ce_1_sg_x28,
      clk_1 => clk_1_sg_x28,
      sync_in => sync_delay_q_net_x9,
      coef_out => mem_data_net_x1
    );

  data_delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x28,
      clk => clk_1_sg_x28,
      d => bram_data_out_net_x6,
      en => '1',
      q => data_delay_q_net_x0
    );

  sum_delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 34
    )
    port map (
      ce => ce_1_sg_x28,
      clk => clk_1_sg_x28,
      d => concat_y_net_x6,
      en => '1',
      q => sum_delay_q_net_x0
    );

  sync_delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x28,
      clk => clk_1_sg_x28,
      d(0) => sync_delay_q_net_x9,
      en => '1',
      q(0) => sync_delay_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_3"

entity fir_tap_3_entity_1db532ecda is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(7 downto 0); 
    sum_in: in std_logic_vector(33 downto 0); 
    sync_in: in std_logic; 
    data_out: out std_logic_vector(7 downto 0); 
    sum_out: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end fir_tap_3_entity_1db532ecda;

architecture structural of fir_tap_3_entity_1db532ecda is
  signal bram_data_out_net_x2: std_logic_vector(7 downto 0);
  signal bram_data_out_net_x7: std_logic_vector(7 downto 0);
  signal ce_1_sg_x33: std_logic;
  signal clk_1_sg_x33: std_logic;
  signal concat_y_net_x2: std_logic_vector(33 downto 0);
  signal concat_y_net_x7: std_logic_vector(33 downto 0);
  signal data_delay_q_net_x2: std_logic_vector(7 downto 0);
  signal mem_data_net_x4: std_logic_vector(8 downto 0);
  signal sum_delay_q_net_x2: std_logic_vector(33 downto 0);
  signal sync_delay_q_net_x1: std_logic;
  signal sync_delay_q_net_x10: std_logic;
  signal sync_delay_q_net_x11: std_logic;

begin
  ce_1_sg_x33 <= ce_1;
  clk_1_sg_x33 <= clk_1;
  bram_data_out_net_x7 <= data_in;
  concat_y_net_x7 <= sum_in;
  sync_delay_q_net_x10 <= sync_in;
  data_out <= bram_data_out_net_x2;
  sum_out <= concat_y_net_x2;
  sync_out <= sync_delay_q_net_x11;

  fir_coef_5e5fcf201a: entity work.fir_coef_entity_5e5fcf201a
    port map (
      ce_1 => ce_1_sg_x33,
      clk_1 => clk_1_sg_x33,
      data_in => bram_data_out_net_x7,
      sum_in => concat_y_net_x7,
      sync_in => sync_delay_q_net_x10,
      coef => mem_data_net_x4,
      data_out => data_delay_q_net_x2,
      sum_out => sum_delay_q_net_x2,
      sync_out => sync_delay_q_net_x1
    );

  fir_core_57f2bc8a56: entity work.fir_core_entity_3b628b72bc
    port map (
      ce_1 => ce_1_sg_x33,
      clk_1 => clk_1_sg_x33,
      coef => mem_data_net_x4,
      data_in => data_delay_q_net_x2,
      sum_in => sum_delay_q_net_x2,
      sync_in => sync_delay_q_net_x1,
      data_out => bram_data_out_net_x2,
      sum_out => concat_y_net_x2,
      sync_out => sync_delay_q_net_x11
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_4/fir_coef/c_gen"

entity c_gen_entity_bfed56ba73 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    coef_out: out std_logic_vector(8 downto 0)
  );
end c_gen_entity_bfed56ba73;

architecture structural of c_gen_entity_bfed56ba73 is
  signal addr_sel_y_net: std_logic_vector(9 downto 0);
  signal ce_1_sg_x34: std_logic;
  signal clk_1_sg_x34: std_logic;
  signal counter_op_net: std_logic_vector(9 downto 0);
  signal mem_data_net_x0: std_logic_vector(8 downto 0);
  signal sync_delay_q_net_x12: std_logic;

begin
  ce_1_sg_x34 <= ce_1;
  clk_1_sg_x34 <= clk_1;
  sync_delay_q_net_x12 <= sync_in;
  coef_out <= mem_data_net_x0;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 9,
      x_width => 10,
      y_width => 10
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_limit
    generic map (
      cnt_15_0 => 1023,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "binary_counter_virtex5_10_0_1ee993c8ed57b9ce",
      count_limited => 0,
      op_arith => xlUnsigned,
      op_width => 10
    )
    port map (
      ce => ce_1_sg_x34,
      clk => clk_1_sg_x34,
      clr => '0',
      en => "1",
      rst(0) => sync_delay_q_net_x12,
      op => counter_op_net
    );

  mem: entity work.xlsprom
    generic map (
      c_address_width => 10,
      c_width => 9,
      core_name0 => "bmg_24_vx5_2c89c45c28fef7b6",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x34,
      clk => clk_1_sg_x34,
      en => "1",
      rst => "0",
      data => mem_data_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_4/fir_coef"

entity fir_coef_entity_cd9df4bc76 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(7 downto 0); 
    sum_in: in std_logic_vector(33 downto 0); 
    sync_in: in std_logic; 
    coef: out std_logic_vector(8 downto 0); 
    data_out: out std_logic_vector(7 downto 0); 
    sum_out: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end fir_coef_entity_cd9df4bc76;

architecture structural of fir_coef_entity_cd9df4bc76 is
  signal bram_data_out_net_x3: std_logic_vector(7 downto 0);
  signal ce_1_sg_x35: std_logic;
  signal clk_1_sg_x35: std_logic;
  signal concat_y_net_x3: std_logic_vector(33 downto 0);
  signal data_delay_q_net_x0: std_logic_vector(7 downto 0);
  signal mem_data_net_x1: std_logic_vector(8 downto 0);
  signal sum_delay_q_net_x0: std_logic_vector(33 downto 0);
  signal sync_delay_q_net_x0: std_logic;
  signal sync_delay_q_net_x13: std_logic;

begin
  ce_1_sg_x35 <= ce_1;
  clk_1_sg_x35 <= clk_1;
  bram_data_out_net_x3 <= data_in;
  concat_y_net_x3 <= sum_in;
  sync_delay_q_net_x13 <= sync_in;
  coef <= mem_data_net_x1;
  data_out <= data_delay_q_net_x0;
  sum_out <= sum_delay_q_net_x0;
  sync_out <= sync_delay_q_net_x0;

  c_gen_bfed56ba73: entity work.c_gen_entity_bfed56ba73
    port map (
      ce_1 => ce_1_sg_x35,
      clk_1 => clk_1_sg_x35,
      sync_in => sync_delay_q_net_x13,
      coef_out => mem_data_net_x1
    );

  data_delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x35,
      clk => clk_1_sg_x35,
      d => bram_data_out_net_x3,
      en => '1',
      q => data_delay_q_net_x0
    );

  sum_delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 34
    )
    port map (
      ce => ce_1_sg_x35,
      clk => clk_1_sg_x35,
      d => concat_y_net_x3,
      en => '1',
      q => sum_delay_q_net_x0
    );

  sync_delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x35,
      clk => clk_1_sg_x35,
      d(0) => sync_delay_q_net_x13,
      en => '1',
      q(0) => sync_delay_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_4"

entity fir_tap_4_entity_7c430193f8 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(7 downto 0); 
    sum_in: in std_logic_vector(33 downto 0); 
    sync_in: in std_logic; 
    data_out: out std_logic_vector(7 downto 0); 
    sum_out: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end fir_tap_4_entity_7c430193f8;

architecture structural of fir_tap_4_entity_7c430193f8 is
  signal bram_data_out_net_x4: std_logic_vector(7 downto 0);
  signal bram_data_out_net_x5: std_logic_vector(7 downto 0);
  signal ce_1_sg_x40: std_logic;
  signal clk_1_sg_x40: std_logic;
  signal concat_y_net_x4: std_logic_vector(33 downto 0);
  signal concat_y_net_x5: std_logic_vector(33 downto 0);
  signal data_delay_q_net_x2: std_logic_vector(7 downto 0);
  signal mem_data_net_x4: std_logic_vector(8 downto 0);
  signal sum_delay_q_net_x2: std_logic_vector(33 downto 0);
  signal sync_delay_q_net_x1: std_logic;
  signal sync_delay_q_net_x14: std_logic;
  signal sync_delay_q_net_x3: std_logic;

begin
  ce_1_sg_x40 <= ce_1;
  clk_1_sg_x40 <= clk_1;
  bram_data_out_net_x4 <= data_in;
  concat_y_net_x4 <= sum_in;
  sync_delay_q_net_x14 <= sync_in;
  data_out <= bram_data_out_net_x5;
  sum_out <= concat_y_net_x5;
  sync_out <= sync_delay_q_net_x3;

  fir_coef_cd9df4bc76: entity work.fir_coef_entity_cd9df4bc76
    port map (
      ce_1 => ce_1_sg_x40,
      clk_1 => clk_1_sg_x40,
      data_in => bram_data_out_net_x4,
      sum_in => concat_y_net_x4,
      sync_in => sync_delay_q_net_x14,
      coef => mem_data_net_x4,
      data_out => data_delay_q_net_x2,
      sum_out => sum_delay_q_net_x2,
      sync_out => sync_delay_q_net_x1
    );

  fir_core_e6a7632a34: entity work.fir_core_entity_3b628b72bc
    port map (
      ce_1 => ce_1_sg_x40,
      clk_1 => clk_1_sg_x40,
      coef => mem_data_net_x4,
      data_in => data_delay_q_net_x2,
      sum_in => sum_delay_q_net_x2,
      sync_in => sync_delay_q_net_x1,
      data_out => bram_data_out_net_x5,
      sum_out => concat_y_net_x5,
      sync_out => sync_delay_q_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_5/fir_coef/c_gen"

entity c_gen_entity_33087564cb is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    coef_out: out std_logic_vector(8 downto 0)
  );
end c_gen_entity_33087564cb;

architecture structural of c_gen_entity_33087564cb is
  signal addr_sel_y_net: std_logic_vector(9 downto 0);
  signal ce_1_sg_x41: std_logic;
  signal clk_1_sg_x41: std_logic;
  signal counter_op_net: std_logic_vector(9 downto 0);
  signal mem_data_net_x0: std_logic_vector(8 downto 0);
  signal sync_delay_q_net_x4: std_logic;

begin
  ce_1_sg_x41 <= ce_1;
  clk_1_sg_x41 <= clk_1;
  sync_delay_q_net_x4 <= sync_in;
  coef_out <= mem_data_net_x0;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 9,
      x_width => 10,
      y_width => 10
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_limit
    generic map (
      cnt_15_0 => 1023,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "binary_counter_virtex5_10_0_1ee993c8ed57b9ce",
      count_limited => 0,
      op_arith => xlUnsigned,
      op_width => 10
    )
    port map (
      ce => ce_1_sg_x41,
      clk => clk_1_sg_x41,
      clr => '0',
      en => "1",
      rst(0) => sync_delay_q_net_x4,
      op => counter_op_net
    );

  mem: entity work.xlsprom
    generic map (
      c_address_width => 10,
      c_width => 9,
      core_name0 => "bmg_24_vx5_7bc1e03f2e4955ca",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x41,
      clk => clk_1_sg_x41,
      en => "1",
      rst => "0",
      data => mem_data_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_5/fir_coef"

entity fir_coef_entity_74e36d4821 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(7 downto 0); 
    sum_in: in std_logic_vector(33 downto 0); 
    sync_in: in std_logic; 
    coef: out std_logic_vector(8 downto 0); 
    data_out: out std_logic_vector(7 downto 0); 
    sum_out: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end fir_coef_entity_74e36d4821;

architecture structural of fir_coef_entity_74e36d4821 is
  signal bram_data_out_net_x6: std_logic_vector(7 downto 0);
  signal ce_1_sg_x42: std_logic;
  signal clk_1_sg_x42: std_logic;
  signal concat_y_net_x6: std_logic_vector(33 downto 0);
  signal data_delay_q_net_x0: std_logic_vector(7 downto 0);
  signal mem_data_net_x1: std_logic_vector(8 downto 0);
  signal sum_delay_q_net_x0: std_logic_vector(33 downto 0);
  signal sync_delay_q_net_x0: std_logic;
  signal sync_delay_q_net_x5: std_logic;

begin
  ce_1_sg_x42 <= ce_1;
  clk_1_sg_x42 <= clk_1;
  bram_data_out_net_x6 <= data_in;
  concat_y_net_x6 <= sum_in;
  sync_delay_q_net_x5 <= sync_in;
  coef <= mem_data_net_x1;
  data_out <= data_delay_q_net_x0;
  sum_out <= sum_delay_q_net_x0;
  sync_out <= sync_delay_q_net_x0;

  c_gen_33087564cb: entity work.c_gen_entity_33087564cb
    port map (
      ce_1 => ce_1_sg_x42,
      clk_1 => clk_1_sg_x42,
      sync_in => sync_delay_q_net_x5,
      coef_out => mem_data_net_x1
    );

  data_delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x42,
      clk => clk_1_sg_x42,
      d => bram_data_out_net_x6,
      en => '1',
      q => data_delay_q_net_x0
    );

  sum_delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 34
    )
    port map (
      ce => ce_1_sg_x42,
      clk => clk_1_sg_x42,
      d => concat_y_net_x6,
      en => '1',
      q => sum_delay_q_net_x0
    );

  sync_delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x42,
      clk => clk_1_sg_x42,
      d(0) => sync_delay_q_net_x5,
      en => '1',
      q(0) => sync_delay_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_5"

entity fir_tap_5_entity_32d697476e is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(7 downto 0); 
    sum_in: in std_logic_vector(33 downto 0); 
    sync_in: in std_logic; 
    data_out: out std_logic_vector(7 downto 0); 
    sum_out: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end fir_tap_5_entity_32d697476e;

architecture structural of fir_tap_5_entity_32d697476e is
  signal bram_data_out_net_x2: std_logic_vector(7 downto 0);
  signal bram_data_out_net_x7: std_logic_vector(7 downto 0);
  signal ce_1_sg_x47: std_logic;
  signal clk_1_sg_x47: std_logic;
  signal concat_y_net_x2: std_logic_vector(33 downto 0);
  signal concat_y_net_x7: std_logic_vector(33 downto 0);
  signal data_delay_q_net_x2: std_logic_vector(7 downto 0);
  signal mem_data_net_x4: std_logic_vector(8 downto 0);
  signal sum_delay_q_net_x2: std_logic_vector(33 downto 0);
  signal sync_delay_q_net_x1: std_logic;
  signal sync_delay_q_net_x6: std_logic;
  signal sync_delay_q_net_x7: std_logic;

begin
  ce_1_sg_x47 <= ce_1;
  clk_1_sg_x47 <= clk_1;
  bram_data_out_net_x7 <= data_in;
  concat_y_net_x7 <= sum_in;
  sync_delay_q_net_x6 <= sync_in;
  data_out <= bram_data_out_net_x2;
  sum_out <= concat_y_net_x2;
  sync_out <= sync_delay_q_net_x7;

  fir_coef_74e36d4821: entity work.fir_coef_entity_74e36d4821
    port map (
      ce_1 => ce_1_sg_x47,
      clk_1 => clk_1_sg_x47,
      data_in => bram_data_out_net_x7,
      sum_in => concat_y_net_x7,
      sync_in => sync_delay_q_net_x6,
      coef => mem_data_net_x4,
      data_out => data_delay_q_net_x2,
      sum_out => sum_delay_q_net_x2,
      sync_out => sync_delay_q_net_x1
    );

  fir_core_64a4b01cfe: entity work.fir_core_entity_3b628b72bc
    port map (
      ce_1 => ce_1_sg_x47,
      clk_1 => clk_1_sg_x47,
      coef => mem_data_net_x4,
      data_in => data_delay_q_net_x2,
      sum_in => sum_delay_q_net_x2,
      sync_in => sync_delay_q_net_x1,
      data_out => bram_data_out_net_x2,
      sum_out => concat_y_net_x2,
      sync_out => sync_delay_q_net_x7
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_6/fir_coef/c_gen"

entity c_gen_entity_6a3e648c8e is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    coef_out: out std_logic_vector(8 downto 0)
  );
end c_gen_entity_6a3e648c8e;

architecture structural of c_gen_entity_6a3e648c8e is
  signal addr_sel_y_net: std_logic_vector(9 downto 0);
  signal ce_1_sg_x48: std_logic;
  signal clk_1_sg_x48: std_logic;
  signal counter_op_net: std_logic_vector(9 downto 0);
  signal mem_data_net_x0: std_logic_vector(8 downto 0);
  signal sync_delay_q_net_x8: std_logic;

begin
  ce_1_sg_x48 <= ce_1;
  clk_1_sg_x48 <= clk_1;
  sync_delay_q_net_x8 <= sync_in;
  coef_out <= mem_data_net_x0;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 9,
      x_width => 10,
      y_width => 10
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_limit
    generic map (
      cnt_15_0 => 1023,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "binary_counter_virtex5_10_0_1ee993c8ed57b9ce",
      count_limited => 0,
      op_arith => xlUnsigned,
      op_width => 10
    )
    port map (
      ce => ce_1_sg_x48,
      clk => clk_1_sg_x48,
      clr => '0',
      en => "1",
      rst(0) => sync_delay_q_net_x8,
      op => counter_op_net
    );

  mem: entity work.xlsprom
    generic map (
      c_address_width => 10,
      c_width => 9,
      core_name0 => "bmg_24_vx5_8259598782c619da",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x48,
      clk => clk_1_sg_x48,
      en => "1",
      rst => "0",
      data => mem_data_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_6/fir_coef"

entity fir_coef_entity_6398eb6f71 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(7 downto 0); 
    sum_in: in std_logic_vector(33 downto 0); 
    sync_in: in std_logic; 
    coef: out std_logic_vector(8 downto 0); 
    data_out: out std_logic_vector(7 downto 0); 
    sum_out: out std_logic_vector(33 downto 0)
  );
end fir_coef_entity_6398eb6f71;

architecture structural of fir_coef_entity_6398eb6f71 is
  signal bram_data_out_net_x3: std_logic_vector(7 downto 0);
  signal ce_1_sg_x49: std_logic;
  signal clk_1_sg_x49: std_logic;
  signal concat_y_net_x3: std_logic_vector(33 downto 0);
  signal data_delay_q_net_x0: std_logic_vector(7 downto 0);
  signal mem_data_net_x1: std_logic_vector(8 downto 0);
  signal sum_delay_q_net_x0: std_logic_vector(33 downto 0);
  signal sync_delay_q_net_x9: std_logic;

begin
  ce_1_sg_x49 <= ce_1;
  clk_1_sg_x49 <= clk_1;
  bram_data_out_net_x3 <= data_in;
  concat_y_net_x3 <= sum_in;
  sync_delay_q_net_x9 <= sync_in;
  coef <= mem_data_net_x1;
  data_out <= data_delay_q_net_x0;
  sum_out <= sum_delay_q_net_x0;

  c_gen_6a3e648c8e: entity work.c_gen_entity_6a3e648c8e
    port map (
      ce_1 => ce_1_sg_x49,
      clk_1 => clk_1_sg_x49,
      sync_in => sync_delay_q_net_x9,
      coef_out => mem_data_net_x1
    );

  data_delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x49,
      clk => clk_1_sg_x49,
      d => bram_data_out_net_x3,
      en => '1',
      q => data_delay_q_net_x0
    );

  sum_delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 34
    )
    port map (
      ce => ce_1_sg_x49,
      clk => clk_1_sg_x49,
      d => concat_y_net_x3,
      en => '1',
      q => sum_delay_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_6/fir_core"

entity fir_core_entity_eb17f90b1c is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    coef: in std_logic_vector(8 downto 0); 
    data_in: in std_logic_vector(7 downto 0); 
    sum_in: in std_logic_vector(33 downto 0); 
    sum_out: out std_logic_vector(33 downto 0)
  );
end fir_core_entity_eb17f90b1c;

architecture structural of fir_core_entity_eb17f90b1c is
  signal add_s_net_x0: std_logic_vector(17 downto 0);
  signal add_s_net_x1: std_logic_vector(17 downto 0);
  signal ce_1_sg_x52: std_logic;
  signal clk_1_sg_x52: std_logic;
  signal concat_y_net_x4: std_logic_vector(33 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(16 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(16 downto 0);
  signal data_delay_q_net_x2: std_logic_vector(7 downto 0);
  signal force_im_output_port_net_x2: std_logic_vector(7 downto 0);
  signal force_im_output_port_net_x3: std_logic_vector(16 downto 0);
  signal force_re_output_port_net_x2: std_logic_vector(7 downto 0);
  signal force_re_output_port_net_x3: std_logic_vector(16 downto 0);
  signal mem_data_net_x4: std_logic_vector(8 downto 0);
  signal sum_delay_q_net_x2: std_logic_vector(33 downto 0);

begin
  ce_1_sg_x52 <= ce_1;
  clk_1_sg_x52 <= clk_1;
  mem_data_net_x4 <= coef;
  data_delay_q_net_x2 <= data_in;
  sum_delay_q_net_x2 <= sum_in;
  sum_out <= concat_y_net_x4;

  c_to_ri_d_cdb310ecd6: entity work.c_to_ri_d_entity_f9c71271a8
    port map (
      c => data_delay_q_net_x2,
      im => force_im_output_port_net_x2,
      re => force_re_output_port_net_x2
    );

  c_to_ri_s_22c3200508: entity work.c_to_ri_entity_fe9d761bb1
    port map (
      c => sum_delay_q_net_x2,
      im => force_im_output_port_net_x3,
      re => force_re_output_port_net_x3
    );

  convert_im: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 15,
      din_width => 18,
      dout_arith => 2,
      dout_bin_pt => 15,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => add_s_net_x0,
      dout => convert_im_dout_net_x0
    );

  convert_re: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 15,
      din_width => 18,
      dout_arith => 2,
      dout_bin_pt => 15,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => add_s_net_x1,
      dout => convert_re_dout_net_x0
    );

  mult_add_im_7c0a9a8853: entity work.mult_add_im_entity_5625f0db12
    port map (
      a => force_im_output_port_net_x2,
      b => mem_data_net_x4,
      c => force_im_output_port_net_x3,
      ce_1 => ce_1_sg_x52,
      clk_1 => clk_1_sg_x52,
      out_x0 => add_s_net_x0
    );

  mult_add_re_796b7a7782: entity work.mult_add_im_entity_5625f0db12
    port map (
      a => force_re_output_port_net_x2,
      b => mem_data_net_x4,
      c => force_re_output_port_net_x3,
      ce_1 => ce_1_sg_x52,
      clk_1 => clk_1_sg_x52,
      out_x0 => add_s_net_x1
    );

  ri_to_c_5e718f628d: entity work.ri_to_c_entity_007b667efe
    port map (
      im => convert_im_dout_net_x0,
      re => convert_re_dout_net_x0,
      c => concat_y_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1/fir_tap_6"

entity fir_tap_6_entity_8984997cb1 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(7 downto 0); 
    sum_in: in std_logic_vector(33 downto 0); 
    sync_in: in std_logic; 
    sum_out: out std_logic_vector(33 downto 0)
  );
end fir_tap_6_entity_8984997cb1;

architecture structural of fir_tap_6_entity_8984997cb1 is
  signal bram_data_out_net_x4: std_logic_vector(7 downto 0);
  signal ce_1_sg_x53: std_logic;
  signal clk_1_sg_x53: std_logic;
  signal concat_y_net_x5: std_logic_vector(33 downto 0);
  signal concat_y_net_x6: std_logic_vector(33 downto 0);
  signal data_delay_q_net_x2: std_logic_vector(7 downto 0);
  signal mem_data_net_x4: std_logic_vector(8 downto 0);
  signal sum_delay_q_net_x2: std_logic_vector(33 downto 0);
  signal sync_delay_q_net_x10: std_logic;

begin
  ce_1_sg_x53 <= ce_1;
  clk_1_sg_x53 <= clk_1;
  bram_data_out_net_x4 <= data_in;
  concat_y_net_x5 <= sum_in;
  sync_delay_q_net_x10 <= sync_in;
  sum_out <= concat_y_net_x6;

  fir_coef_6398eb6f71: entity work.fir_coef_entity_6398eb6f71
    port map (
      ce_1 => ce_1_sg_x53,
      clk_1 => clk_1_sg_x53,
      data_in => bram_data_out_net_x4,
      sum_in => concat_y_net_x5,
      sync_in => sync_delay_q_net_x10,
      coef => mem_data_net_x4,
      data_out => data_delay_q_net_x2,
      sum_out => sum_delay_q_net_x2
    );

  fir_core_eb17f90b1c: entity work.fir_core_entity_eb17f90b1c
    port map (
      ce_1 => ce_1_sg_x53,
      clk_1 => clk_1_sg_x53,
      coef => mem_data_net_x4,
      data_in => data_delay_q_net_x2,
      sum_in => sum_delay_q_net_x2,
      sum_out => concat_y_net_x6
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_1"

entity fir_1_entity_d77345f031 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(7 downto 0); 
    sync_in: in std_logic; 
    out_x0: out std_logic_vector(17 downto 0)
  );
end fir_1_entity_d77345f031;

architecture structural of fir_1_entity_d77345f031 is
  signal bram_data_out_net_x10: std_logic_vector(7 downto 0);
  signal bram_data_out_net_x4: std_logic_vector(7 downto 0);
  signal bram_data_out_net_x7: std_logic_vector(7 downto 0);
  signal bram_data_out_net_x8: std_logic_vector(7 downto 0);
  signal bram_data_out_net_x9: std_logic_vector(7 downto 0);
  signal ce_1_sg_x54: std_logic;
  signal clk_1_sg_x54: std_logic;
  signal concat_y_net_x10: std_logic_vector(17 downto 0);
  signal concat_y_net_x4: std_logic_vector(33 downto 0);
  signal concat_y_net_x5: std_logic_vector(33 downto 0);
  signal concat_y_net_x6: std_logic_vector(33 downto 0);
  signal concat_y_net_x7: std_logic_vector(33 downto 0);
  signal concat_y_net_x8: std_logic_vector(33 downto 0);
  signal concat_y_net_x9: std_logic_vector(33 downto 0);
  signal delay7_q_net_x3: std_logic;
  signal delay_q_net_x2: std_logic_vector(7 downto 0);
  signal sync_delay_q_net_x10: std_logic;
  signal sync_delay_q_net_x11: std_logic;
  signal sync_delay_q_net_x14: std_logic;
  signal sync_delay_q_net_x6: std_logic;
  signal sync_delay_q_net_x7: std_logic;

begin
  ce_1_sg_x54 <= ce_1;
  clk_1_sg_x54 <= clk_1;
  delay_q_net_x2 <= in_x0;
  delay7_q_net_x3 <= sync_in;
  out_x0 <= concat_y_net_x10;

  fir_quantize_159d90c3b8: entity work.fir_quantize_entity_159d90c3b8
    port map (
      ce_1 => ce_1_sg_x54,
      clk_1 => clk_1_sg_x54,
      sum_in => concat_y_net_x6,
      sum_out => concat_y_net_x10
    );

  fir_tap_1_b409832013: entity work.fir_tap_1_entity_b409832013
    port map (
      ce_1 => ce_1_sg_x54,
      clk_1 => clk_1_sg_x54,
      data_in => delay_q_net_x2,
      sync_in => delay7_q_net_x3,
      data_out => bram_data_out_net_x4,
      sum_out => concat_y_net_x4,
      sync_out => sync_delay_q_net_x6
    );

  fir_tap_2_de2966bf5b: entity work.fir_tap_2_entity_de2966bf5b
    port map (
      ce_1 => ce_1_sg_x54,
      clk_1 => clk_1_sg_x54,
      data_in => bram_data_out_net_x4,
      sum_in => concat_y_net_x4,
      sync_in => sync_delay_q_net_x6,
      data_out => bram_data_out_net_x7,
      sum_out => concat_y_net_x7,
      sync_out => sync_delay_q_net_x10
    );

  fir_tap_3_1db532ecda: entity work.fir_tap_3_entity_1db532ecda
    port map (
      ce_1 => ce_1_sg_x54,
      clk_1 => clk_1_sg_x54,
      data_in => bram_data_out_net_x7,
      sum_in => concat_y_net_x7,
      sync_in => sync_delay_q_net_x10,
      data_out => bram_data_out_net_x8,
      sum_out => concat_y_net_x8,
      sync_out => sync_delay_q_net_x14
    );

  fir_tap_4_7c430193f8: entity work.fir_tap_4_entity_7c430193f8
    port map (
      ce_1 => ce_1_sg_x54,
      clk_1 => clk_1_sg_x54,
      data_in => bram_data_out_net_x8,
      sum_in => concat_y_net_x8,
      sync_in => sync_delay_q_net_x14,
      data_out => bram_data_out_net_x9,
      sum_out => concat_y_net_x9,
      sync_out => sync_delay_q_net_x7
    );

  fir_tap_5_32d697476e: entity work.fir_tap_5_entity_32d697476e
    port map (
      ce_1 => ce_1_sg_x54,
      clk_1 => clk_1_sg_x54,
      data_in => bram_data_out_net_x9,
      sum_in => concat_y_net_x9,
      sync_in => sync_delay_q_net_x7,
      data_out => bram_data_out_net_x10,
      sum_out => concat_y_net_x5,
      sync_out => sync_delay_q_net_x11
    );

  fir_tap_6_8984997cb1: entity work.fir_tap_6_entity_8984997cb1
    port map (
      ce_1 => ce_1_sg_x54,
      clk_1 => clk_1_sg_x54,
      data_in => bram_data_out_net_x10,
      sum_in => concat_y_net_x5,
      sync_in => sync_delay_q_net_x11,
      sum_out => concat_y_net_x6
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_4/fir_quantize"

entity fir_quantize_entity_0872b1c19f is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    sync_out: out std_logic
  );
end fir_quantize_entity_0872b1c19f;

architecture structural of fir_quantize_entity_0872b1c19f is
  signal ce_1_sg_x98: std_logic;
  signal clk_1_sg_x98: std_logic;
  signal delay_q_net_x0: std_logic;
  signal sync_delay_q_net_x0: std_logic;

begin
  ce_1_sg_x98 <= ce_1;
  clk_1_sg_x98 <= clk_1;
  sync_delay_q_net_x0 <= sync_in;
  sync_out <= delay_q_net_x0;

  delay: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x98,
      clk => clk_1_sg_x98,
      d(0) => sync_delay_q_net_x0,
      en => '1',
      q(0) => delay_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_4/fir_tap_1/fir_coef"

entity fir_coef_entity_fa8d0a6424 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    sync_out: out std_logic
  );
end fir_coef_entity_fa8d0a6424;

architecture structural of fir_coef_entity_fa8d0a6424 is
  signal ce_1_sg_x99: std_logic;
  signal clk_1_sg_x99: std_logic;
  signal delay7_q_net_x8: std_logic;
  signal sync_delay_q_net_x0: std_logic;

begin
  ce_1_sg_x99 <= ce_1;
  clk_1_sg_x99 <= clk_1;
  delay7_q_net_x8 <= sync_in;
  sync_out <= sync_delay_q_net_x0;

  sync_delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x99,
      clk => clk_1_sg_x99,
      d(0) => delay7_q_net_x8,
      en => '1',
      q(0) => sync_delay_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_4/fir_tap_1"

entity fir_tap_1_entity_b54d787092 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    sync_out: out std_logic
  );
end fir_tap_1_entity_b54d787092;

architecture structural of fir_tap_1_entity_b54d787092 is
  signal ce_1_sg_x101: std_logic;
  signal clk_1_sg_x101: std_logic;
  signal delay7_q_net_x9: std_logic;
  signal sync_delay_q_net_x1: std_logic;
  signal sync_delay_q_net_x3: std_logic;

begin
  ce_1_sg_x101 <= ce_1;
  clk_1_sg_x101 <= clk_1;
  delay7_q_net_x9 <= sync_in;
  sync_out <= sync_delay_q_net_x3;

  fir_coef_fa8d0a6424: entity work.fir_coef_entity_fa8d0a6424
    port map (
      ce_1 => ce_1_sg_x101,
      clk_1 => clk_1_sg_x101,
      sync_in => delay7_q_net_x9,
      sync_out => sync_delay_q_net_x1
    );

  fir_core_6cc879cea3: entity work.fir_quantize_entity_0872b1c19f
    port map (
      ce_1 => ce_1_sg_x101,
      clk_1 => clk_1_sg_x101,
      sync_in => sync_delay_q_net_x1,
      sync_out => sync_delay_q_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_4/fir_tap_2/fir_core"

entity fir_core_entity_eb3608837d is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    sync_out: out std_logic
  );
end fir_core_entity_eb3608837d;

architecture structural of fir_core_entity_eb3608837d is
  signal ce_1_sg_x103: std_logic;
  signal clk_1_sg_x103: std_logic;
  signal sync_delay_q_net_x1: std_logic;
  signal sync_delay_q_net_x2: std_logic;

begin
  ce_1_sg_x103 <= ce_1;
  clk_1_sg_x103 <= clk_1;
  sync_delay_q_net_x1 <= sync_in;
  sync_out <= sync_delay_q_net_x2;

  sync_delay: entity work.xldelay
    generic map (
      latency => 4,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x103,
      clk => clk_1_sg_x103,
      d(0) => sync_delay_q_net_x1,
      en => '1',
      q(0) => sync_delay_q_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_4/fir_tap_2"

entity fir_tap_2_entity_001db5d752 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    sync_out: out std_logic
  );
end fir_tap_2_entity_001db5d752;

architecture structural of fir_tap_2_entity_001db5d752 is
  signal ce_1_sg_x104: std_logic;
  signal clk_1_sg_x104: std_logic;
  signal sync_delay_q_net_x1: std_logic;
  signal sync_delay_q_net_x5: std_logic;
  signal sync_delay_q_net_x6: std_logic;

begin
  ce_1_sg_x104 <= ce_1;
  clk_1_sg_x104 <= clk_1;
  sync_delay_q_net_x5 <= sync_in;
  sync_out <= sync_delay_q_net_x6;

  fir_coef_cb402f0fd9: entity work.fir_coef_entity_fa8d0a6424
    port map (
      ce_1 => ce_1_sg_x104,
      clk_1 => clk_1_sg_x104,
      sync_in => sync_delay_q_net_x5,
      sync_out => sync_delay_q_net_x1
    );

  fir_core_eb3608837d: entity work.fir_core_entity_eb3608837d
    port map (
      ce_1 => ce_1_sg_x104,
      clk_1 => clk_1_sg_x104,
      sync_in => sync_delay_q_net_x1,
      sync_out => sync_delay_q_net_x6
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/fir_4"

entity fir_4_entity_9067c135e4 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    sync_out: out std_logic
  );
end fir_4_entity_9067c135e4;

architecture structural of fir_4_entity_9067c135e4 is
  signal ce_1_sg_x117: std_logic;
  signal clk_1_sg_x117: std_logic;
  signal delay7_q_net_x10: std_logic;
  signal delay_q_net_x1: std_logic;
  signal sync_delay_q_net_x10: std_logic;
  signal sync_delay_q_net_x11: std_logic;
  signal sync_delay_q_net_x5: std_logic;
  signal sync_delay_q_net_x6: std_logic;
  signal sync_delay_q_net_x8: std_logic;
  signal sync_delay_q_net_x9: std_logic;

begin
  ce_1_sg_x117 <= ce_1;
  clk_1_sg_x117 <= clk_1;
  delay7_q_net_x10 <= sync_in;
  sync_out <= delay_q_net_x1;

  fir_quantize_0872b1c19f: entity work.fir_quantize_entity_0872b1c19f
    port map (
      ce_1 => ce_1_sg_x117,
      clk_1 => clk_1_sg_x117,
      sync_in => sync_delay_q_net_x6,
      sync_out => delay_q_net_x1
    );

  fir_tap_1_b54d787092: entity work.fir_tap_1_entity_b54d787092
    port map (
      ce_1 => ce_1_sg_x117,
      clk_1 => clk_1_sg_x117,
      sync_in => delay7_q_net_x10,
      sync_out => sync_delay_q_net_x5
    );

  fir_tap_2_001db5d752: entity work.fir_tap_2_entity_001db5d752
    port map (
      ce_1 => ce_1_sg_x117,
      clk_1 => clk_1_sg_x117,
      sync_in => sync_delay_q_net_x5,
      sync_out => sync_delay_q_net_x8
    );

  fir_tap_3_fde9457b54: entity work.fir_tap_2_entity_001db5d752
    port map (
      ce_1 => ce_1_sg_x117,
      clk_1 => clk_1_sg_x117,
      sync_in => sync_delay_q_net_x8,
      sync_out => sync_delay_q_net_x9
    );

  fir_tap_4_6165b30b68: entity work.fir_tap_2_entity_001db5d752
    port map (
      ce_1 => ce_1_sg_x117,
      clk_1 => clk_1_sg_x117,
      sync_in => sync_delay_q_net_x9,
      sync_out => sync_delay_q_net_x10
    );

  fir_tap_5_0285c5000f: entity work.fir_tap_2_entity_001db5d752
    port map (
      ce_1 => ce_1_sg_x117,
      clk_1 => clk_1_sg_x117,
      sync_in => sync_delay_q_net_x10,
      sync_out => sync_delay_q_net_x11
    );

  fir_tap_6_5154ca09df: entity work.fir_tap_2_entity_001db5d752
    port map (
      ce_1 => ce_1_sg_x117,
      clk_1 => clk_1_sg_x117,
      sync_in => sync_delay_q_net_x11,
      sync_out => sync_delay_q_net_x6
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/led0_sync"

entity led0_sync_entity_f85f7d5b7c is
  port (
    gpio_out: in std_logic; 
    convert_x0: out std_logic
  );
end led0_sync_entity_f85f7d5b7c;

architecture structural of led0_sync_entity_f85f7d5b7c is
  signal convert_dout_net_x0: std_logic;
  signal relational5_op_net_x0: std_logic;

begin
  relational5_op_net_x0 <= gpio_out;
  convert_x0 <= convert_dout_net_x0;

  convert: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din(0) => relational5_op_net_x0,
      dout(0) => convert_dout_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/pulse_ext1"

entity pulse_ext1_entity_4051a15797 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end pulse_ext1_entity_4051a15797;

architecture structural of pulse_ext1_entity_4051a15797 is
  signal ce_1_sg_x206: std_logic;
  signal clk_1_sg_x206: std_logic;
  signal constant5_op_net: std_logic_vector(24 downto 0);
  signal counter3_op_net: std_logic_vector(24 downto 0);
  signal logical_y_net_x2: std_logic;
  signal logical_y_net_x3: std_logic;
  signal relational5_op_net_x1: std_logic;

begin
  ce_1_sg_x206 <= ce_1;
  clk_1_sg_x206 <= clk_1;
  logical_y_net_x3 <= in_x0;
  out_x0 <= relational5_op_net_x1;

  constant5: entity work.constant_2ae71e3b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant5_op_net
    );

  counter3: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_092422ed79c7db12",
      op_arith => xlUnsigned,
      op_width => 25
    )
    port map (
      ce => ce_1_sg_x206,
      clk => clk_1_sg_x206,
      clr => '0',
      en(0) => relational5_op_net_x1,
      rst(0) => logical_y_net_x2,
      op => counter3_op_net
    );

  posedge_aed9b95747: entity work.posedge1_entity_d70b7fecd6
    port map (
      ce_1 => ce_1_sg_x206,
      clk_1 => clk_1_sg_x206,
      in_x0 => logical_y_net_x3,
      out_x0 => logical_y_net_x2
    );

  relational5: entity work.relational_487ac75be9
    port map (
      a => counter3_op_net,
      b => constant5_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational5_op_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/quadplex_bitrev/biplex_bitrev0/bit_reverse"

entity bit_reverse_entity_7a73fb4074 is
  port (
    in_x0: in std_logic_vector(7 downto 0); 
    out_x0: out std_logic_vector(7 downto 0)
  );
end bit_reverse_entity_7a73fb4074;

architecture structural of bit_reverse_entity_7a73fb4074 is
  signal bit0_y_net: std_logic;
  signal bit1_y_net: std_logic;
  signal bit2_y_net: std_logic;
  signal bit3_y_net: std_logic;
  signal bit4_y_net: std_logic;
  signal bit5_y_net: std_logic;
  signal bit6_y_net: std_logic;
  signal bit7_y_net: std_logic;
  signal concat_y_net_x0: std_logic_vector(7 downto 0);
  signal counter_op_net_x0: std_logic_vector(7 downto 0);

begin
  counter_op_net_x0 <= in_x0;
  out_x0 <= concat_y_net_x0;

  bit0: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => counter_op_net_x0,
      y(0) => bit0_y_net
    );

  bit1: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => counter_op_net_x0,
      y(0) => bit1_y_net
    );

  bit2: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => counter_op_net_x0,
      y(0) => bit2_y_net
    );

  bit3: entity work.xlslice
    generic map (
      new_lsb => 3,
      new_msb => 3,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => counter_op_net_x0,
      y(0) => bit3_y_net
    );

  bit4: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 4,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => counter_op_net_x0,
      y(0) => bit4_y_net
    );

  bit5: entity work.xlslice
    generic map (
      new_lsb => 5,
      new_msb => 5,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => counter_op_net_x0,
      y(0) => bit5_y_net
    );

  bit6: entity work.xlslice
    generic map (
      new_lsb => 6,
      new_msb => 6,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => counter_op_net_x0,
      y(0) => bit6_y_net
    );

  bit7: entity work.xlslice
    generic map (
      new_lsb => 7,
      new_msb => 7,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => counter_op_net_x0,
      y(0) => bit7_y_net
    );

  concat: entity work.concat_7673b9b993
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0(0) => bit0_y_net,
      in1(0) => bit1_y_net,
      in2(0) => bit2_y_net,
      in3(0) => bit3_y_net,
      in4(0) => bit4_y_net,
      in5(0) => bit5_y_net,
      in6(0) => bit6_y_net,
      in7(0) => bit7_y_net,
      y => concat_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/quadplex_bitrev/biplex_bitrev0/c_to_ri"

entity c_to_ri_entity_77af6c8b3b is
  port (
    c: in std_logic_vector(37 downto 0); 
    im: out std_logic_vector(18 downto 0); 
    re: out std_logic_vector(18 downto 0)
  );
end c_to_ri_entity_77af6c8b3b;

architecture structural of c_to_ri_entity_77af6c8b3b is
  signal delay2_q_net_x0: std_logic_vector(37 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(18 downto 0);
  signal slice_im_y_net: std_logic_vector(18 downto 0);
  signal slice_re_y_net: std_logic_vector(18 downto 0);

begin
  delay2_q_net_x0 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 18,
      x_width => 38,
      y_width => 19
    )
    port map (
      x => delay2_q_net_x0,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 19,
      new_msb => 37,
      x_width => 38,
      y_width => 19
    )
    port map (
      x => delay2_q_net_x0,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/quadplex_bitrev/biplex_bitrev0/ri_to_c"

entity ri_to_c_entity_b3a6a3c041 is
  port (
    im: in std_logic_vector(18 downto 0); 
    re: in std_logic_vector(18 downto 0); 
    c: out std_logic_vector(37 downto 0)
  );
end ri_to_c_entity_b3a6a3c041;

architecture structural of ri_to_c_entity_b3a6a3c041 is
  signal concat_y_net_x0: std_logic_vector(37 downto 0);
  signal force_im_output_port_net: std_logic_vector(18 downto 0);
  signal force_re_output_port_net: std_logic_vector(18 downto 0);
  signal ram_a_im_data_out_net_x0: std_logic_vector(18 downto 0);
  signal ram_a_re_data_out_net_x0: std_logic_vector(18 downto 0);

begin
  ram_a_im_data_out_net_x0 <= im;
  ram_a_re_data_out_net_x0 <= re;
  c <= concat_y_net_x0;

  concat: entity work.concat_5a12f8f9be
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x0
    );

  force_im: entity work.reinterpret_bc4405cd1e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => ram_a_im_data_out_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_bc4405cd1e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => ram_a_re_data_out_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/quadplex_bitrev/biplex_bitrev0"

entity biplex_bitrev0_entity_30ef78a279 is
  port (
    a_in: in std_logic_vector(37 downto 0); 
    b_in: in std_logic_vector(37 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    a_out: out std_logic_vector(37 downto 0); 
    b_out: out std_logic_vector(37 downto 0)
  );
end biplex_bitrev0_entity_30ef78a279;

architecture structural of biplex_bitrev0_entity_30ef78a279 is
  signal ce_1_sg_x209: std_logic;
  signal clk_1_sg_x209: std_logic;
  signal concat_y_net_x0: std_logic_vector(7 downto 0);
  signal concat_y_net_x3: std_logic_vector(37 downto 0);
  signal concat_y_net_x4: std_logic_vector(37 downto 0);
  signal concat_y_net_x5: std_logic_vector(37 downto 0);
  signal constant1_op_net: std_logic;
  signal constant2_op_net: std_logic;
  signal constant4_op_net: std_logic;
  signal constant6_op_net: std_logic;
  signal constant_op_net: std_logic;
  signal counter1_op_net: std_logic;
  signal counter_op_net_x0: std_logic_vector(7 downto 0);
  signal delay1_q_net_x0: std_logic_vector(37 downto 0);
  signal delay2_q_net_x0: std_logic_vector(37 downto 0);
  signal delay_q_net_x0: std_logic;
  signal force_im_output_port_net_x0: std_logic_vector(18 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(18 downto 0);
  signal mux1_y_net_x0: std_logic_vector(37 downto 0);
  signal mux_y_net: std_logic_vector(7 downto 0);
  signal ram_a_im_data_out_net_x0: std_logic_vector(18 downto 0);
  signal ram_a_re_data_out_net_x0: std_logic_vector(18 downto 0);
  signal ram_b_im_data_out_net_x0: std_logic_vector(18 downto 0);
  signal ram_b_re_data_out_net_x0: std_logic_vector(18 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(7 downto 0);
  signal relational_op_net: std_logic;

begin
  concat_y_net_x3 <= a_in;
  mux1_y_net_x0 <= b_in;
  ce_1_sg_x209 <= ce_1;
  clk_1_sg_x209 <= clk_1;
  delay_q_net_x0 <= sync_in;
  a_out <= concat_y_net_x4;
  b_out <= concat_y_net_x5;

  bit_reverse_7a73fb4074: entity work.bit_reverse_entity_7a73fb4074
    port map (
      in_x0 => counter_op_net_x0,
      out_x0 => concat_y_net_x0
    );

  c_to_ri1_cdafe29a1b: entity work.c_to_ri_entity_77af6c8b3b
    port map (
      c => delay1_q_net_x0,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_77af6c8b3b: entity work.c_to_ri_entity_77af6c8b3b
    port map (
      c => delay2_q_net_x0,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  constant1: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant1_op_net
    );

  constant2: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net
    );

  constant4: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant4_op_net
    );

  constant6: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant6_op_net
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_01e34ae12479a5e1",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x209,
      clk => clk_1_sg_x209,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x0,
      op => counter_op_net_x0
    );

  counter1: entity work.counter_2943023fcf
    port map (
      ce => ce_1_sg_x209,
      clk => clk_1_sg_x209,
      clr => '0',
      en(0) => relational_op_net,
      op(0) => counter1_op_net
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 38
    )
    port map (
      ce => ce_1_sg_x209,
      clk => clk_1_sg_x209,
      d => mux1_y_net_x0,
      en => '1',
      q => delay1_q_net_x0
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 38
    )
    port map (
      ce => ce_1_sg_x209,
      clk => clk_1_sg_x209,
      d => concat_y_net_x3,
      en => '1',
      q => delay2_q_net_x0
    );

  mux: entity work.mux_7f6b7da686
    port map (
      ce => ce_1_sg_x209,
      clk => clk_1_sg_x209,
      clr => '0',
      d0 => counter_op_net_x0,
      d1 => concat_y_net_x0,
      sel(0) => counter1_op_net,
      y => mux_y_net
    );

  ram_a_im: entity work.xlspram
    generic map (
      c_address_width => 8,
      c_width => 19,
      core_name0 => "bmg_24_vx5_cd3584ee10cade7e",
      latency => 1
    )
    port map (
      addr => mux_y_net,
      ce => ce_1_sg_x209,
      clk => clk_1_sg_x209,
      data_in => force_im_output_port_net_x0,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => ram_a_im_data_out_net_x0
    );

  ram_a_re: entity work.xlspram
    generic map (
      c_address_width => 8,
      c_width => 19,
      core_name0 => "bmg_24_vx5_cd3584ee10cade7e",
      latency => 1
    )
    port map (
      addr => mux_y_net,
      ce => ce_1_sg_x209,
      clk => clk_1_sg_x209,
      data_in => force_re_output_port_net_x0,
      en => "1",
      rst => "0",
      we(0) => constant2_op_net,
      data_out => ram_a_re_data_out_net_x0
    );

  ram_b_im: entity work.xlspram
    generic map (
      c_address_width => 8,
      c_width => 19,
      core_name0 => "bmg_24_vx5_cd3584ee10cade7e",
      latency => 1
    )
    port map (
      addr => mux_y_net,
      ce => ce_1_sg_x209,
      clk => clk_1_sg_x209,
      data_in => force_im_output_port_net_x1,
      en => "1",
      rst => "0",
      we(0) => constant4_op_net,
      data_out => ram_b_im_data_out_net_x0
    );

  ram_b_re: entity work.xlspram
    generic map (
      c_address_width => 8,
      c_width => 19,
      core_name0 => "bmg_24_vx5_cd3584ee10cade7e",
      latency => 1
    )
    port map (
      addr => mux_y_net,
      ce => ce_1_sg_x209,
      clk => clk_1_sg_x209,
      data_in => force_re_output_port_net_x1,
      en => "1",
      rst => "0",
      we(0) => constant6_op_net,
      data_out => ram_b_re_data_out_net_x0
    );

  reinterpret: entity work.reinterpret_4389dc89bf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => counter_op_net_x0,
      output_port => reinterpret_output_port_net
    );

  relational: entity work.relational_53c93d0689
    port map (
      a(0) => constant1_op_net,
      b => reinterpret_output_port_net,
      ce => ce_1_sg_x209,
      clk => clk_1_sg_x209,
      clr => '0',
      op(0) => relational_op_net
    );

  ri_to_c1_a52cb52ab5: entity work.ri_to_c_entity_b3a6a3c041
    port map (
      im => ram_b_im_data_out_net_x0,
      re => ram_b_re_data_out_net_x0,
      c => concat_y_net_x5
    );

  ri_to_c_b3a6a3c041: entity work.ri_to_c_entity_b3a6a3c041
    port map (
      im => ram_a_im_data_out_net_x0,
      re => ram_a_re_data_out_net_x0,
      c => concat_y_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/quadplex_bitrev"

entity quadplex_bitrev_entity_660273096d is
  port (
    a_in: in std_logic_vector(37 downto 0); 
    b_in: in std_logic_vector(37 downto 0); 
    c_in: in std_logic_vector(37 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d_in: in std_logic_vector(37 downto 0); 
    sync_in: in std_logic; 
    a_out: out std_logic_vector(37 downto 0); 
    b_out: out std_logic_vector(37 downto 0); 
    c_out: out std_logic_vector(37 downto 0); 
    d_out: out std_logic_vector(37 downto 0)
  );
end quadplex_bitrev_entity_660273096d;

architecture structural of quadplex_bitrev_entity_660273096d is
  signal ce_1_sg_x211: std_logic;
  signal clk_1_sg_x211: std_logic;
  signal concat_y_net_x10: std_logic_vector(37 downto 0);
  signal concat_y_net_x11: std_logic_vector(37 downto 0);
  signal concat_y_net_x12: std_logic_vector(37 downto 0);
  signal concat_y_net_x13: std_logic_vector(37 downto 0);
  signal concat_y_net_x14: std_logic_vector(37 downto 0);
  signal concat_y_net_x9: std_logic_vector(37 downto 0);
  signal delay_q_net_x2: std_logic;
  signal mux1_y_net_x2: std_logic_vector(37 downto 0);
  signal mux1_y_net_x3: std_logic_vector(37 downto 0);

begin
  concat_y_net_x9 <= a_in;
  mux1_y_net_x2 <= b_in;
  concat_y_net_x10 <= c_in;
  ce_1_sg_x211 <= ce_1;
  clk_1_sg_x211 <= clk_1;
  mux1_y_net_x3 <= d_in;
  delay_q_net_x2 <= sync_in;
  a_out <= concat_y_net_x11;
  b_out <= concat_y_net_x12;
  c_out <= concat_y_net_x13;
  d_out <= concat_y_net_x14;

  biplex_bitrev0_30ef78a279: entity work.biplex_bitrev0_entity_30ef78a279
    port map (
      a_in => concat_y_net_x9,
      b_in => mux1_y_net_x2,
      ce_1 => ce_1_sg_x211,
      clk_1 => clk_1_sg_x211,
      sync_in => delay_q_net_x2,
      a_out => concat_y_net_x11,
      b_out => concat_y_net_x12
    );

  biplex_bitrev1_268cc4f4b1: entity work.biplex_bitrev0_entity_30ef78a279
    port map (
      a_in => concat_y_net_x10,
      b_in => mux1_y_net_x3,
      ce_1 => ce_1_sg_x211,
      clk_1 => clk_1_sg_x211,
      sync_in => delay_q_net_x2,
      a_out => concat_y_net_x13,
      b_out => concat_y_net_x14
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/quadplex_commutator/biplex_commutator_01/delay_b/delay_im"

entity delay_im_entity_5e0a651975 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(18 downto 0); 
    out_x0: out std_logic_vector(18 downto 0)
  );
end delay_im_entity_5e0a651975;

architecture structural of delay_im_entity_5e0a651975 is
  signal bram_data_out_net_x0: std_logic_vector(18 downto 0);
  signal ce_1_sg_x212: std_logic;
  signal clk_1_sg_x212: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(18 downto 0);

begin
  ce_1_sg_x212 <= ce_1;
  clk_1_sg_x212 <= clk_1;
  force_im_output_port_net_x1 <= in_x0;
  out_x0 <= bram_data_out_net_x0;

  bram: entity work.xlspram
    generic map (
      c_address_width => 8,
      c_width => 19,
      core_name0 => "bmg_24_vx5_cd3584ee10cade7e",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      data_in => force_im_output_port_net_x1,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => bram_data_out_net_x0
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit
    generic map (
      cnt_15_0 => 254,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "binary_counter_virtex5_10_0_01e34ae12479a5e1",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/quadplex_commutator/biplex_commutator_01/delay_b"

entity delay_b_entity_47aee85e44 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(37 downto 0); 
    out_x0: out std_logic_vector(37 downto 0)
  );
end delay_b_entity_47aee85e44;

architecture structural of delay_b_entity_47aee85e44 is
  signal bram_data_out_net_x2: std_logic_vector(18 downto 0);
  signal bram_data_out_net_x3: std_logic_vector(18 downto 0);
  signal ce_1_sg_x214: std_logic;
  signal clk_1_sg_x214: std_logic;
  signal concat_y_net_x2: std_logic_vector(37 downto 0);
  signal concat_y_net_x3: std_logic_vector(37 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(18 downto 0);

begin
  ce_1_sg_x214 <= ce_1;
  clk_1_sg_x214 <= clk_1;
  concat_y_net_x2 <= in_x0;
  out_x0 <= concat_y_net_x3;

  c_to_ri_e4859baa03: entity work.c_to_ri_entity_77af6c8b3b
    port map (
      c => concat_y_net_x2,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  delay_im_5e0a651975: entity work.delay_im_entity_5e0a651975
    port map (
      ce_1 => ce_1_sg_x214,
      clk_1 => clk_1_sg_x214,
      in_x0 => force_im_output_port_net_x1,
      out_x0 => bram_data_out_net_x2
    );

  delay_re_ce48dacb4d: entity work.delay_im_entity_5e0a651975
    port map (
      ce_1 => ce_1_sg_x214,
      clk_1 => clk_1_sg_x214,
      in_x0 => force_re_output_port_net_x1,
      out_x0 => bram_data_out_net_x3
    );

  ri_to_c_bed8318d26: entity work.ri_to_c_entity_b3a6a3c041
    port map (
      im => bram_data_out_net_x2,
      re => bram_data_out_net_x3,
      c => concat_y_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/quadplex_commutator/biplex_commutator_01"

entity biplex_commutator_01_entity_6a76e43a40 is
  port (
    aloahi: in std_logic_vector(37 downto 0); 
    blobhi: in std_logic_vector(37 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(37 downto 0); 
    aloblo: out std_logic_vector(37 downto 0)
  );
end biplex_commutator_01_entity_6a76e43a40;

architecture structural of biplex_commutator_01_entity_6a76e43a40 is
  signal ce_1_sg_x218: std_logic;
  signal clk_1_sg_x218: std_logic;
  signal concat_y_net_x0: std_logic_vector(37 downto 0);
  signal concat_y_net_x12: std_logic_vector(37 downto 0);
  signal concat_y_net_x3: std_logic_vector(37 downto 0);
  signal concat_y_net_x4: std_logic_vector(37 downto 0);
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal delay_q_net_x0: std_logic;
  signal mux1_y_net_x3: std_logic_vector(37 downto 0);
  signal mux_y_net_x1: std_logic_vector(37 downto 0);
  signal top_bit_y_net: std_logic;

begin
  concat_y_net_x0 <= aloahi;
  concat_y_net_x4 <= blobhi;
  ce_1_sg_x218 <= ce_1;
  clk_1_sg_x218 <= clk_1;
  delay_q_net_x0 <= sync_in;
  ahibhi <= mux1_y_net_x3;
  aloblo <= concat_y_net_x12;

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_1c25d2b550c5fffc",
      op_arith => xlUnsigned,
      op_width => 9
    )
    port map (
      ce => ce_1_sg_x218,
      clk => clk_1_sg_x218,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x0,
      op => counter_op_net
    );

  delay_b_47aee85e44: entity work.delay_b_entity_47aee85e44
    port map (
      ce_1 => ce_1_sg_x218,
      clk_1 => clk_1_sg_x218,
      in_x0 => concat_y_net_x4,
      out_x0 => concat_y_net_x3
    );

  delay_lo_f5010121d5: entity work.delay_b_entity_47aee85e44
    port map (
      ce_1 => ce_1_sg_x218,
      clk_1 => clk_1_sg_x218,
      in_x0 => mux_y_net_x1,
      out_x0 => concat_y_net_x12
    );

  mux: entity work.mux_79b7e15c26
    port map (
      ce => ce_1_sg_x218,
      clk => clk_1_sg_x218,
      clr => '0',
      d0 => concat_y_net_x0,
      d1 => concat_y_net_x3,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x1
    );

  mux1: entity work.mux_79b7e15c26
    port map (
      ce => ce_1_sg_x218,
      clk => clk_1_sg_x218,
      clr => '0',
      d0 => concat_y_net_x3,
      d1 => concat_y_net_x0,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x3
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 8,
      x_width => 9,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/quadplex_commutator/biplex_commutator_23"

entity biplex_commutator_23_entity_50a787a430 is
  port (
    aloahi: in std_logic_vector(37 downto 0); 
    blobhi: in std_logic_vector(37 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(37 downto 0); 
    aloblo: out std_logic_vector(37 downto 0); 
    sync_out: out std_logic
  );
end biplex_commutator_23_entity_50a787a430;

architecture structural of biplex_commutator_23_entity_50a787a430 is
  signal ce_1_sg_x225: std_logic;
  signal clk_1_sg_x225: std_logic;
  signal concat_y_net_x1: std_logic_vector(37 downto 0);
  signal concat_y_net_x13: std_logic_vector(37 downto 0);
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal delay_q_net_x0: std_logic;
  signal delay_q_net_x3: std_logic;
  signal mux1_y_net_x0: std_logic_vector(37 downto 0);
  signal mux1_y_net_x2: std_logic_vector(37 downto 0);
  signal mux1_y_net_x4: std_logic_vector(37 downto 0);
  signal mux_y_net_x1: std_logic_vector(37 downto 0);
  signal top_bit_y_net: std_logic;

begin
  mux1_y_net_x0 <= aloahi;
  mux1_y_net_x2 <= blobhi;
  ce_1_sg_x225 <= ce_1;
  clk_1_sg_x225 <= clk_1;
  delay_q_net_x0 <= sync_in;
  ahibhi <= mux1_y_net_x4;
  aloblo <= concat_y_net_x13;
  sync_out <= delay_q_net_x3;

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_1c25d2b550c5fffc",
      op_arith => xlUnsigned,
      op_width => 9
    )
    port map (
      ce => ce_1_sg_x225,
      clk => clk_1_sg_x225,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x0,
      op => counter_op_net
    );

  delay: entity work.xldelay
    generic map (
      latency => 257,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x225,
      clk => clk_1_sg_x225,
      d(0) => delay_q_net_x0,
      en => '1',
      q(0) => delay_q_net_x3
    );

  delay_b_7e3bcc561d: entity work.delay_b_entity_47aee85e44
    port map (
      ce_1 => ce_1_sg_x225,
      clk_1 => clk_1_sg_x225,
      in_x0 => mux1_y_net_x2,
      out_x0 => concat_y_net_x1
    );

  delay_lo_bb75bbbe28: entity work.delay_b_entity_47aee85e44
    port map (
      ce_1 => ce_1_sg_x225,
      clk_1 => clk_1_sg_x225,
      in_x0 => mux_y_net_x1,
      out_x0 => concat_y_net_x13
    );

  mux: entity work.mux_79b7e15c26
    port map (
      ce => ce_1_sg_x225,
      clk => clk_1_sg_x225,
      clr => '0',
      d0 => mux1_y_net_x0,
      d1 => concat_y_net_x1,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x1
    );

  mux1: entity work.mux_79b7e15c26
    port map (
      ce => ce_1_sg_x225,
      clk => clk_1_sg_x225,
      clr => '0',
      d0 => concat_y_net_x1,
      d1 => mux1_y_net_x0,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x4
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 8,
      x_width => 9,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/quadplex_commutator/biplex_commutator_ac/delay_b/delay_im"

entity delay_im_entity_1878a3b82b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(18 downto 0); 
    out_x0: out std_logic_vector(18 downto 0)
  );
end delay_im_entity_1878a3b82b;

architecture structural of delay_im_entity_1878a3b82b is
  signal bram_data_out_net_x0: std_logic_vector(18 downto 0);
  signal ce_1_sg_x226: std_logic;
  signal clk_1_sg_x226: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(18 downto 0);

begin
  ce_1_sg_x226 <= ce_1;
  clk_1_sg_x226 <= clk_1;
  force_im_output_port_net_x1 <= in_x0;
  out_x0 <= bram_data_out_net_x0;

  bram: entity work.xlspram
    generic map (
      c_address_width => 9,
      c_width => 19,
      core_name0 => "bmg_24_vx5_941504d2ced01311",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x226,
      clk => clk_1_sg_x226,
      data_in => force_im_output_port_net_x1,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => bram_data_out_net_x0
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit
    generic map (
      cnt_15_0 => 510,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "binary_counter_virtex5_10_0_1c25d2b550c5fffc",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 9
    )
    port map (
      ce => ce_1_sg_x226,
      clk => clk_1_sg_x226,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/quadplex_commutator/biplex_commutator_ac/delay_b"

entity delay_b_entity_54d4e68371 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(37 downto 0); 
    out_x0: out std_logic_vector(37 downto 0)
  );
end delay_b_entity_54d4e68371;

architecture structural of delay_b_entity_54d4e68371 is
  signal bram_data_out_net_x2: std_logic_vector(18 downto 0);
  signal bram_data_out_net_x3: std_logic_vector(18 downto 0);
  signal ce_1_sg_x228: std_logic;
  signal clk_1_sg_x228: std_logic;
  signal concat_y_net_x2: std_logic_vector(37 downto 0);
  signal concat_y_net_x3: std_logic_vector(37 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(18 downto 0);

begin
  ce_1_sg_x228 <= ce_1;
  clk_1_sg_x228 <= clk_1;
  concat_y_net_x2 <= in_x0;
  out_x0 <= concat_y_net_x3;

  c_to_ri_3703676f4a: entity work.c_to_ri_entity_77af6c8b3b
    port map (
      c => concat_y_net_x2,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  delay_im_1878a3b82b: entity work.delay_im_entity_1878a3b82b
    port map (
      ce_1 => ce_1_sg_x228,
      clk_1 => clk_1_sg_x228,
      in_x0 => force_im_output_port_net_x1,
      out_x0 => bram_data_out_net_x2
    );

  delay_re_ce0daf323e: entity work.delay_im_entity_1878a3b82b
    port map (
      ce_1 => ce_1_sg_x228,
      clk_1 => clk_1_sg_x228,
      in_x0 => force_re_output_port_net_x1,
      out_x0 => bram_data_out_net_x3
    );

  ri_to_c_62586d10a1: entity work.ri_to_c_entity_b3a6a3c041
    port map (
      im => bram_data_out_net_x2,
      re => bram_data_out_net_x3,
      c => concat_y_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/quadplex_commutator/biplex_commutator_ac"

entity biplex_commutator_ac_entity_2c3cadb7c6 is
  port (
    aloahi: in std_logic_vector(37 downto 0); 
    blobhi: in std_logic_vector(37 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(37 downto 0); 
    aloblo: out std_logic_vector(37 downto 0); 
    sync_out: out std_logic
  );
end biplex_commutator_ac_entity_2c3cadb7c6;

architecture structural of biplex_commutator_ac_entity_2c3cadb7c6 is
  signal ce_1_sg_x232: std_logic;
  signal clk_1_sg_x232: std_logic;
  signal concat_y_net_x0: std_logic_vector(37 downto 0);
  signal concat_y_net_x3: std_logic_vector(37 downto 0);
  signal concat_y_net_x5: std_logic_vector(37 downto 0);
  signal concat_y_net_x6: std_logic_vector(37 downto 0);
  signal counter_op_net: std_logic_vector(9 downto 0);
  signal delay_q_net_x1: std_logic;
  signal delay_q_net_x2: std_logic;
  signal mux1_y_net_x1: std_logic_vector(37 downto 0);
  signal mux_y_net_x1: std_logic_vector(37 downto 0);
  signal top_bit_y_net: std_logic;

begin
  concat_y_net_x0 <= aloahi;
  concat_y_net_x5 <= blobhi;
  ce_1_sg_x232 <= ce_1;
  clk_1_sg_x232 <= clk_1;
  delay_q_net_x1 <= sync_in;
  ahibhi <= mux1_y_net_x1;
  aloblo <= concat_y_net_x6;
  sync_out <= delay_q_net_x2;

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_1ee993c8ed57b9ce",
      op_arith => xlUnsigned,
      op_width => 10
    )
    port map (
      ce => ce_1_sg_x232,
      clk => clk_1_sg_x232,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x1,
      op => counter_op_net
    );

  delay: entity work.xldelay
    generic map (
      latency => 513,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x232,
      clk => clk_1_sg_x232,
      d(0) => delay_q_net_x1,
      en => '1',
      q(0) => delay_q_net_x2
    );

  delay_b_54d4e68371: entity work.delay_b_entity_54d4e68371
    port map (
      ce_1 => ce_1_sg_x232,
      clk_1 => clk_1_sg_x232,
      in_x0 => concat_y_net_x5,
      out_x0 => concat_y_net_x3
    );

  delay_lo_ccbbb5b7e6: entity work.delay_b_entity_54d4e68371
    port map (
      ce_1 => ce_1_sg_x232,
      clk_1 => clk_1_sg_x232,
      in_x0 => mux_y_net_x1,
      out_x0 => concat_y_net_x6
    );

  mux: entity work.mux_79b7e15c26
    port map (
      ce => ce_1_sg_x232,
      clk => clk_1_sg_x232,
      clr => '0',
      d0 => concat_y_net_x0,
      d1 => concat_y_net_x3,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x1
    );

  mux1: entity work.mux_79b7e15c26
    port map (
      ce => ce_1_sg_x232,
      clk => clk_1_sg_x232,
      clr => '0',
      d0 => concat_y_net_x3,
      d1 => concat_y_net_x0,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x1
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 9,
      new_msb => 9,
      x_width => 10,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/quadplex_commutator"

entity quadplex_commutator_entity_24b23ba26e is
  port (
    a: in std_logic_vector(37 downto 0); 
    b: in std_logic_vector(37 downto 0); 
    c: in std_logic_vector(37 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(37 downto 0); 
    sync_in: in std_logic; 
    abcd0: out std_logic_vector(37 downto 0); 
    abcd1: out std_logic_vector(37 downto 0); 
    abcd2: out std_logic_vector(37 downto 0); 
    abcd3: out std_logic_vector(37 downto 0); 
    sync_out: out std_logic
  );
end quadplex_commutator_entity_24b23ba26e;

architecture structural of quadplex_commutator_entity_24b23ba26e is
  signal ce_1_sg_x240: std_logic;
  signal clk_1_sg_x240: std_logic;
  signal concat_y_net_x10: std_logic_vector(37 downto 0);
  signal concat_y_net_x11: std_logic_vector(37 downto 0);
  signal concat_y_net_x14: std_logic_vector(37 downto 0);
  signal concat_y_net_x15: std_logic_vector(37 downto 0);
  signal concat_y_net_x16: std_logic_vector(37 downto 0);
  signal concat_y_net_x6: std_logic_vector(37 downto 0);
  signal concat_y_net_x7: std_logic_vector(37 downto 0);
  signal concat_y_net_x9: std_logic_vector(37 downto 0);
  signal delay_q_net_x2: std_logic;
  signal delay_q_net_x4: std_logic;
  signal delay_q_net_x6: std_logic;
  signal delay_q_net_x7: std_logic;
  signal mux1_y_net_x1: std_logic_vector(37 downto 0);
  signal mux1_y_net_x5: std_logic_vector(37 downto 0);
  signal mux1_y_net_x6: std_logic_vector(37 downto 0);
  signal mux1_y_net_x7: std_logic_vector(37 downto 0);

begin
  concat_y_net_x9 <= a;
  concat_y_net_x10 <= b;
  concat_y_net_x14 <= c;
  ce_1_sg_x240 <= ce_1;
  clk_1_sg_x240 <= clk_1;
  concat_y_net_x11 <= d;
  delay_q_net_x6 <= sync_in;
  abcd0 <= concat_y_net_x15;
  abcd1 <= mux1_y_net_x6;
  abcd2 <= concat_y_net_x16;
  abcd3 <= mux1_y_net_x7;
  sync_out <= delay_q_net_x7;

  biplex_commutator_01_6a76e43a40: entity work.biplex_commutator_01_entity_6a76e43a40
    port map (
      aloahi => concat_y_net_x6,
      blobhi => concat_y_net_x7,
      ce_1 => ce_1_sg_x240,
      clk_1 => clk_1_sg_x240,
      sync_in => delay_q_net_x2,
      ahibhi => mux1_y_net_x6,
      aloblo => concat_y_net_x15
    );

  biplex_commutator_23_50a787a430: entity work.biplex_commutator_23_entity_50a787a430
    port map (
      aloahi => mux1_y_net_x1,
      blobhi => mux1_y_net_x5,
      ce_1 => ce_1_sg_x240,
      clk_1 => clk_1_sg_x240,
      sync_in => delay_q_net_x4,
      ahibhi => mux1_y_net_x7,
      aloblo => concat_y_net_x16,
      sync_out => delay_q_net_x7
    );

  biplex_commutator_ac_2c3cadb7c6: entity work.biplex_commutator_ac_entity_2c3cadb7c6
    port map (
      aloahi => concat_y_net_x9,
      blobhi => concat_y_net_x14,
      ce_1 => ce_1_sg_x240,
      clk_1 => clk_1_sg_x240,
      sync_in => delay_q_net_x6,
      ahibhi => mux1_y_net_x1,
      aloblo => concat_y_net_x6,
      sync_out => delay_q_net_x2
    );

  biplex_commutator_bd_c91f287100: entity work.biplex_commutator_ac_entity_2c3cadb7c6
    port map (
      aloahi => concat_y_net_x10,
      blobhi => concat_y_net_x11,
      ce_1 => ce_1_sg_x240,
      clk_1 => clk_1_sg_x240,
      sync_in => delay_q_net_x6,
      ahibhi => mux1_y_net_x5,
      aloblo => concat_y_net_x7,
      sync_out => delay_q_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_1/quadplex_commutator/biplex_commutator_01/delay_b"

entity delay_b_entity_54fc59f010 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(17 downto 0); 
    out_x0: out std_logic_vector(17 downto 0)
  );
end delay_b_entity_54fc59f010;

architecture structural of delay_b_entity_54fc59f010 is
  signal bram_data_out_net_x1: std_logic_vector(17 downto 0);
  signal bram_data_out_net_x2: std_logic_vector(17 downto 0);
  signal ce_1_sg_x241: std_logic;
  signal clk_1_sg_x241: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x241 <= ce_1;
  clk_1_sg_x241 <= clk_1;
  bram_data_out_net_x1 <= in_x0;
  out_x0 <= bram_data_out_net_x2;

  bram: entity work.xlspram
    generic map (
      c_address_width => 8,
      c_width => 18,
      core_name0 => "bmg_24_vx5_b56a7cdaabc490ac",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x241,
      clk => clk_1_sg_x241,
      data_in => bram_data_out_net_x1,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => bram_data_out_net_x2
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit
    generic map (
      cnt_15_0 => 254,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "binary_counter_virtex5_10_0_01e34ae12479a5e1",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x241,
      clk => clk_1_sg_x241,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_1/quadplex_commutator/biplex_commutator_01"

entity biplex_commutator_01_entity_62d41deb8e is
  port (
    aloahi: in std_logic_vector(17 downto 0); 
    blobhi: in std_logic_vector(17 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(17 downto 0); 
    aloblo: out std_logic_vector(17 downto 0)
  );
end biplex_commutator_01_entity_62d41deb8e;

architecture structural of biplex_commutator_01_entity_62d41deb8e is
  signal bram_data_out_net_x2: std_logic_vector(17 downto 0);
  signal bram_data_out_net_x3: std_logic_vector(17 downto 0);
  signal bram_data_out_net_x4: std_logic_vector(17 downto 0);
  signal bram_data_out_net_x5: std_logic_vector(17 downto 0);
  signal ce_1_sg_x243: std_logic;
  signal clk_1_sg_x243: std_logic;
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal delay_q_net_x0: std_logic;
  signal mux1_y_net_x0: std_logic_vector(17 downto 0);
  signal mux_y_net_x0: std_logic_vector(17 downto 0);
  signal top_bit_y_net: std_logic;

begin
  bram_data_out_net_x3 <= aloahi;
  bram_data_out_net_x4 <= blobhi;
  ce_1_sg_x243 <= ce_1;
  clk_1_sg_x243 <= clk_1;
  delay_q_net_x0 <= sync_in;
  ahibhi <= mux1_y_net_x0;
  aloblo <= bram_data_out_net_x5;

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_1c25d2b550c5fffc",
      op_arith => xlUnsigned,
      op_width => 9
    )
    port map (
      ce => ce_1_sg_x243,
      clk => clk_1_sg_x243,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x0,
      op => counter_op_net
    );

  delay_b_54fc59f010: entity work.delay_b_entity_54fc59f010
    port map (
      ce_1 => ce_1_sg_x243,
      clk_1 => clk_1_sg_x243,
      in_x0 => bram_data_out_net_x4,
      out_x0 => bram_data_out_net_x2
    );

  delay_lo_26c550428d: entity work.delay_b_entity_54fc59f010
    port map (
      ce_1 => ce_1_sg_x243,
      clk_1 => clk_1_sg_x243,
      in_x0 => mux_y_net_x0,
      out_x0 => bram_data_out_net_x5
    );

  mux: entity work.mux_181e58d842
    port map (
      ce => ce_1_sg_x243,
      clk => clk_1_sg_x243,
      clr => '0',
      d0 => bram_data_out_net_x3,
      d1 => bram_data_out_net_x2,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x0
    );

  mux1: entity work.mux_181e58d842
    port map (
      ce => ce_1_sg_x243,
      clk => clk_1_sg_x243,
      clr => '0',
      d0 => bram_data_out_net_x2,
      d1 => bram_data_out_net_x3,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x0
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 8,
      x_width => 9,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_1/quadplex_commutator/biplex_commutator_23"

entity biplex_commutator_23_entity_f2ff46cb20 is
  port (
    aloahi: in std_logic_vector(17 downto 0); 
    blobhi: in std_logic_vector(17 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(17 downto 0); 
    aloblo: out std_logic_vector(17 downto 0); 
    sync_out: out std_logic
  );
end biplex_commutator_23_entity_f2ff46cb20;

architecture structural of biplex_commutator_23_entity_f2ff46cb20 is
  signal bram_data_out_net_x0: std_logic_vector(17 downto 0);
  signal bram_data_out_net_x2: std_logic_vector(17 downto 0);
  signal ce_1_sg_x246: std_logic;
  signal clk_1_sg_x246: std_logic;
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal delay_q_net_x1: std_logic;
  signal delay_q_net_x2: std_logic;
  signal mux1_y_net_x2: std_logic_vector(17 downto 0);
  signal mux1_y_net_x3: std_logic_vector(17 downto 0);
  signal mux1_y_net_x4: std_logic_vector(17 downto 0);
  signal mux_y_net_x0: std_logic_vector(17 downto 0);
  signal top_bit_y_net: std_logic;

begin
  mux1_y_net_x2 <= aloahi;
  mux1_y_net_x3 <= blobhi;
  ce_1_sg_x246 <= ce_1;
  clk_1_sg_x246 <= clk_1;
  delay_q_net_x1 <= sync_in;
  ahibhi <= mux1_y_net_x4;
  aloblo <= bram_data_out_net_x2;
  sync_out <= delay_q_net_x2;

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_1c25d2b550c5fffc",
      op_arith => xlUnsigned,
      op_width => 9
    )
    port map (
      ce => ce_1_sg_x246,
      clk => clk_1_sg_x246,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x1,
      op => counter_op_net
    );

  delay: entity work.xldelay
    generic map (
      latency => 257,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x246,
      clk => clk_1_sg_x246,
      d(0) => delay_q_net_x1,
      en => '1',
      q(0) => delay_q_net_x2
    );

  delay_b_e76cf0c343: entity work.delay_b_entity_54fc59f010
    port map (
      ce_1 => ce_1_sg_x246,
      clk_1 => clk_1_sg_x246,
      in_x0 => mux1_y_net_x3,
      out_x0 => bram_data_out_net_x0
    );

  delay_lo_6d81c4800a: entity work.delay_b_entity_54fc59f010
    port map (
      ce_1 => ce_1_sg_x246,
      clk_1 => clk_1_sg_x246,
      in_x0 => mux_y_net_x0,
      out_x0 => bram_data_out_net_x2
    );

  mux: entity work.mux_181e58d842
    port map (
      ce => ce_1_sg_x246,
      clk => clk_1_sg_x246,
      clr => '0',
      d0 => mux1_y_net_x2,
      d1 => bram_data_out_net_x0,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x0
    );

  mux1: entity work.mux_181e58d842
    port map (
      ce => ce_1_sg_x246,
      clk => clk_1_sg_x246,
      clr => '0',
      d0 => bram_data_out_net_x0,
      d1 => mux1_y_net_x2,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x4
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 8,
      x_width => 9,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_1/quadplex_commutator/biplex_commutator_ac/delay_b"

entity delay_b_entity_fc95f0b354 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(17 downto 0); 
    out_x0: out std_logic_vector(17 downto 0)
  );
end delay_b_entity_fc95f0b354;

architecture structural of delay_b_entity_fc95f0b354 is
  signal bram_data_out_net_x0: std_logic_vector(17 downto 0);
  signal ce_1_sg_x247: std_logic;
  signal clk_1_sg_x247: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal shift4_op_net_x0: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x247 <= ce_1;
  clk_1_sg_x247 <= clk_1;
  shift4_op_net_x0 <= in_x0;
  out_x0 <= bram_data_out_net_x0;

  bram: entity work.xlspram
    generic map (
      c_address_width => 9,
      c_width => 18,
      core_name0 => "bmg_24_vx5_0206823b131149d8",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x247,
      clk => clk_1_sg_x247,
      data_in => shift4_op_net_x0,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => bram_data_out_net_x0
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit
    generic map (
      cnt_15_0 => 510,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "binary_counter_virtex5_10_0_1c25d2b550c5fffc",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 9
    )
    port map (
      ce => ce_1_sg_x247,
      clk => clk_1_sg_x247,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_1/quadplex_commutator/biplex_commutator_ac"

entity biplex_commutator_ac_entity_2ca5bf992f is
  port (
    aloahi: in std_logic_vector(17 downto 0); 
    blobhi: in std_logic_vector(17 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(17 downto 0); 
    aloblo: out std_logic_vector(17 downto 0); 
    sync_out: out std_logic
  );
end biplex_commutator_ac_entity_2ca5bf992f;

architecture structural of biplex_commutator_ac_entity_2ca5bf992f is
  signal bram_data_out_net_x0: std_logic_vector(17 downto 0);
  signal bram_data_out_net_x5: std_logic_vector(17 downto 0);
  signal ce_1_sg_x249: std_logic;
  signal clk_1_sg_x249: std_logic;
  signal counter_op_net: std_logic_vector(9 downto 0);
  signal delay_q_net_x2: std_logic;
  signal delay_q_net_x3: std_logic;
  signal mux1_y_net_x3: std_logic_vector(17 downto 0);
  signal mux_y_net_x0: std_logic_vector(17 downto 0);
  signal shift4_op_net_x1: std_logic_vector(17 downto 0);
  signal shift_op_net_x0: std_logic_vector(17 downto 0);
  signal top_bit_y_net: std_logic;

begin
  shift_op_net_x0 <= aloahi;
  shift4_op_net_x1 <= blobhi;
  ce_1_sg_x249 <= ce_1;
  clk_1_sg_x249 <= clk_1;
  delay_q_net_x2 <= sync_in;
  ahibhi <= mux1_y_net_x3;
  aloblo <= bram_data_out_net_x5;
  sync_out <= delay_q_net_x3;

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_1ee993c8ed57b9ce",
      op_arith => xlUnsigned,
      op_width => 10
    )
    port map (
      ce => ce_1_sg_x249,
      clk => clk_1_sg_x249,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x2,
      op => counter_op_net
    );

  delay: entity work.xldelay
    generic map (
      latency => 513,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x249,
      clk => clk_1_sg_x249,
      d(0) => delay_q_net_x2,
      en => '1',
      q(0) => delay_q_net_x3
    );

  delay_b_fc95f0b354: entity work.delay_b_entity_fc95f0b354
    port map (
      ce_1 => ce_1_sg_x249,
      clk_1 => clk_1_sg_x249,
      in_x0 => shift4_op_net_x1,
      out_x0 => bram_data_out_net_x0
    );

  delay_lo_77987b84e8: entity work.delay_b_entity_fc95f0b354
    port map (
      ce_1 => ce_1_sg_x249,
      clk_1 => clk_1_sg_x249,
      in_x0 => mux_y_net_x0,
      out_x0 => bram_data_out_net_x5
    );

  mux: entity work.mux_181e58d842
    port map (
      ce => ce_1_sg_x249,
      clk => clk_1_sg_x249,
      clr => '0',
      d0 => shift_op_net_x0,
      d1 => bram_data_out_net_x0,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x0
    );

  mux1: entity work.mux_181e58d842
    port map (
      ce => ce_1_sg_x249,
      clk => clk_1_sg_x249,
      clr => '0',
      d0 => bram_data_out_net_x0,
      d1 => shift_op_net_x0,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x3
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 9,
      new_msb => 9,
      x_width => 10,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_1/quadplex_commutator"

entity quadplex_commutator_entity_262766872e is
  port (
    a: in std_logic_vector(17 downto 0); 
    b: in std_logic_vector(17 downto 0); 
    c: in std_logic_vector(17 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(17 downto 0); 
    sync_in: in std_logic; 
    abcd0: out std_logic_vector(17 downto 0); 
    abcd1: out std_logic_vector(17 downto 0); 
    abcd2: out std_logic_vector(17 downto 0); 
    abcd3: out std_logic_vector(17 downto 0); 
    sync_out: out std_logic
  );
end quadplex_commutator_entity_262766872e;

architecture structural of quadplex_commutator_entity_262766872e is
  signal bram_data_out_net_x6: std_logic_vector(17 downto 0);
  signal bram_data_out_net_x7: std_logic_vector(17 downto 0);
  signal bram_data_out_net_x8: std_logic_vector(17 downto 0);
  signal bram_data_out_net_x9: std_logic_vector(17 downto 0);
  signal ce_1_sg_x253: std_logic;
  signal clk_1_sg_x253: std_logic;
  signal delay_q_net_x4: std_logic;
  signal delay_q_net_x5: std_logic;
  signal delay_q_net_x6: std_logic;
  signal delay_q_net_x7: std_logic;
  signal mux1_y_net_x3: std_logic_vector(17 downto 0);
  signal mux1_y_net_x5: std_logic_vector(17 downto 0);
  signal mux1_y_net_x6: std_logic_vector(17 downto 0);
  signal mux1_y_net_x7: std_logic_vector(17 downto 0);
  signal shift1_op_net_x1: std_logic_vector(17 downto 0);
  signal shift4_op_net_x2: std_logic_vector(17 downto 0);
  signal shift5_op_net_x2: std_logic_vector(17 downto 0);
  signal shift_op_net_x1: std_logic_vector(17 downto 0);

begin
  shift_op_net_x1 <= a;
  shift1_op_net_x1 <= b;
  shift4_op_net_x2 <= c;
  ce_1_sg_x253 <= ce_1;
  clk_1_sg_x253 <= clk_1;
  shift5_op_net_x2 <= d;
  delay_q_net_x6 <= sync_in;
  abcd0 <= bram_data_out_net_x8;
  abcd1 <= mux1_y_net_x6;
  abcd2 <= bram_data_out_net_x9;
  abcd3 <= mux1_y_net_x7;
  sync_out <= delay_q_net_x7;

  biplex_commutator_01_62d41deb8e: entity work.biplex_commutator_01_entity_62d41deb8e
    port map (
      aloahi => bram_data_out_net_x6,
      blobhi => bram_data_out_net_x7,
      ce_1 => ce_1_sg_x253,
      clk_1 => clk_1_sg_x253,
      sync_in => delay_q_net_x4,
      ahibhi => mux1_y_net_x6,
      aloblo => bram_data_out_net_x8
    );

  biplex_commutator_23_f2ff46cb20: entity work.biplex_commutator_23_entity_f2ff46cb20
    port map (
      aloahi => mux1_y_net_x3,
      blobhi => mux1_y_net_x5,
      ce_1 => ce_1_sg_x253,
      clk_1 => clk_1_sg_x253,
      sync_in => delay_q_net_x5,
      ahibhi => mux1_y_net_x7,
      aloblo => bram_data_out_net_x9,
      sync_out => delay_q_net_x7
    );

  biplex_commutator_ac_2ca5bf992f: entity work.biplex_commutator_ac_entity_2ca5bf992f
    port map (
      aloahi => shift_op_net_x1,
      blobhi => shift4_op_net_x2,
      ce_1 => ce_1_sg_x253,
      clk_1 => clk_1_sg_x253,
      sync_in => delay_q_net_x6,
      ahibhi => mux1_y_net_x3,
      aloblo => bram_data_out_net_x6,
      sync_out => delay_q_net_x4
    );

  biplex_commutator_bd_3eb9bf3106: entity work.biplex_commutator_ac_entity_2ca5bf992f
    port map (
      aloahi => shift1_op_net_x1,
      blobhi => shift5_op_net_x2,
      ce_1 => ce_1_sg_x253,
      clk_1 => clk_1_sg_x253,
      sync_in => delay_q_net_x6,
      ahibhi => mux1_y_net_x5,
      aloblo => bram_data_out_net_x7,
      sync_out => delay_q_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_1/r4_butterfly/butterfly0/c_to_ri"

entity c_to_ri_entity_cb1e791740 is
  port (
    c: in std_logic_vector(17 downto 0); 
    im: out std_logic_vector(8 downto 0); 
    re: out std_logic_vector(8 downto 0)
  );
end c_to_ri_entity_cb1e791740;

architecture structural of c_to_ri_entity_cb1e791740 is
  signal bram_data_out_net_x9: std_logic_vector(17 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(8 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(8 downto 0);
  signal slice_im_y_net: std_logic_vector(8 downto 0);
  signal slice_re_y_net: std_logic_vector(8 downto 0);

begin
  bram_data_out_net_x9 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_ceef4fc23d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_ceef4fc23d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 8,
      x_width => 18,
      y_width => 9
    )
    port map (
      x => bram_data_out_net_x9,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 9,
      new_msb => 17,
      x_width => 18,
      y_width => 9
    )
    port map (
      x => bram_data_out_net_x9,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_1/r4_butterfly/butterfly0/ri_to_c"

entity ri_to_c_entity_18e0c52f45 is
  port (
    im: in std_logic_vector(9 downto 0); 
    re: in std_logic_vector(9 downto 0); 
    c: out std_logic_vector(19 downto 0)
  );
end ri_to_c_entity_18e0c52f45;

architecture structural of ri_to_c_entity_18e0c52f45 is
  signal concat_y_net_x0: std_logic_vector(19 downto 0);
  signal force_im_output_port_net: std_logic_vector(9 downto 0);
  signal force_re_output_port_net: std_logic_vector(9 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(9 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(9 downto 0);

begin
  requant1_dout_net_x0 <= im;
  requant0_dout_net_x0 <= re;
  c <= concat_y_net_x0;

  concat: entity work.concat_9d608cd669
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x0
    );

  force_im: entity work.reinterpret_e2e786e1ed
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant1_dout_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_e2e786e1ed
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant0_dout_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_1/r4_butterfly/butterfly0"

entity butterfly0_entity_6f5feb3631 is
  port (
    a: in std_logic_vector(17 downto 0); 
    b: in std_logic_vector(17 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    a_b: out std_logic_vector(19 downto 0); 
    a_b_x0: out std_logic_vector(19 downto 0)
  );
end butterfly0_entity_6f5feb3631;

architecture structural of butterfly0_entity_6f5feb3631 is
  signal add_im_s_net: std_logic_vector(9 downto 0);
  signal add_re_s_net: std_logic_vector(9 downto 0);
  signal bram_data_out_net_x11: std_logic_vector(17 downto 0);
  signal bram_data_out_net_x12: std_logic_vector(17 downto 0);
  signal ce_1_sg_x254: std_logic;
  signal clk_1_sg_x254: std_logic;
  signal concat_y_net_x2: std_logic_vector(19 downto 0);
  signal concat_y_net_x3: std_logic_vector(19 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(8 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(8 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(8 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(8 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(9 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(9 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(9 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(9 downto 0);
  signal shift0_op_net: std_logic_vector(9 downto 0);
  signal shift1_op_net: std_logic_vector(9 downto 0);
  signal shift2_op_net: std_logic_vector(9 downto 0);
  signal shift3_op_net: std_logic_vector(9 downto 0);
  signal sub_im_s_net: std_logic_vector(9 downto 0);
  signal sub_re_s_net: std_logic_vector(9 downto 0);

begin
  bram_data_out_net_x11 <= a;
  bram_data_out_net_x12 <= b;
  ce_1_sg_x254 <= ce_1;
  clk_1_sg_x254 <= clk_1;
  a_b <= concat_y_net_x2;
  a_b_x0 <= concat_y_net_x3;

  add_im: entity work.addsub_793ae25d23
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x254,
      clk => clk_1_sg_x254,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_793ae25d23
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x254,
      clk => clk_1_sg_x254,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_f07a23f884: entity work.c_to_ri_entity_cb1e791740
    port map (
      c => bram_data_out_net_x12,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_cb1e791740: entity work.c_to_ri_entity_cb1e791740
    port map (
      c => bram_data_out_net_x11,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_57e1a75f03: entity work.ri_to_c_entity_18e0c52f45
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x3
    );

  ri_to_c_18e0c52f45: entity work.ri_to_c_entity_18e0c52f45
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x2
    );

  shift0: entity work.scale_6d627f2811
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_6d627f2811
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_6d627f2811
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_6d627f2811
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_3700bc31ba
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x254,
      clk => clk_1_sg_x254,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_3700bc31ba
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x254,
      clk => clk_1_sg_x254,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_1/r4_butterfly/butterfly1"

entity butterfly1_entity_7fd0666490 is
  port (
    a: in std_logic_vector(17 downto 0); 
    b: in std_logic_vector(17 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    a_b: out std_logic_vector(19 downto 0); 
    a_b_x0: out std_logic_vector(19 downto 0); 
    sync_out: out std_logic
  );
end butterfly1_entity_7fd0666490;

architecture structural of butterfly1_entity_7fd0666490 is
  signal add_im_s_net: std_logic_vector(9 downto 0);
  signal add_re_s_net: std_logic_vector(9 downto 0);
  signal ce_1_sg_x255: std_logic;
  signal clk_1_sg_x255: std_logic;
  signal concat_y_net_x2: std_logic_vector(19 downto 0);
  signal concat_y_net_x3: std_logic_vector(19 downto 0);
  signal delay_q_net_x0: std_logic;
  signal delay_q_net_x8: std_logic;
  signal force_im_output_port_net_x0: std_logic_vector(8 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(8 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(8 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(8 downto 0);
  signal mux1_y_net_x10: std_logic_vector(17 downto 0);
  signal mux1_y_net_x9: std_logic_vector(17 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(9 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(9 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(9 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(9 downto 0);
  signal shift0_op_net: std_logic_vector(9 downto 0);
  signal shift1_op_net: std_logic_vector(9 downto 0);
  signal shift2_op_net: std_logic_vector(9 downto 0);
  signal shift3_op_net: std_logic_vector(9 downto 0);
  signal sub_im_s_net: std_logic_vector(9 downto 0);
  signal sub_re_s_net: std_logic_vector(9 downto 0);

begin
  mux1_y_net_x9 <= a;
  mux1_y_net_x10 <= b;
  ce_1_sg_x255 <= ce_1;
  clk_1_sg_x255 <= clk_1;
  delay_q_net_x8 <= sync_in;
  a_b <= concat_y_net_x2;
  a_b_x0 <= concat_y_net_x3;
  sync_out <= delay_q_net_x0;

  add_im: entity work.addsub_793ae25d23
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x255,
      clk => clk_1_sg_x255,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_793ae25d23
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x255,
      clk => clk_1_sg_x255,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_4599a85df0: entity work.c_to_ri_entity_cb1e791740
    port map (
      c => mux1_y_net_x10,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_1cf93c6c0b: entity work.c_to_ri_entity_cb1e791740
    port map (
      c => mux1_y_net_x9,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x255,
      clk => clk_1_sg_x255,
      d(0) => delay_q_net_x8,
      en => '1',
      q(0) => delay_q_net_x0
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_c69716f085: entity work.ri_to_c_entity_18e0c52f45
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x3
    );

  ri_to_c_b25d0ed627: entity work.ri_to_c_entity_18e0c52f45
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x2
    );

  shift0: entity work.scale_6d627f2811
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_6d627f2811
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_6d627f2811
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_6d627f2811
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_3700bc31ba
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x255,
      clk => clk_1_sg_x255,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_3700bc31ba
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x255,
      clk => clk_1_sg_x255,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_1/r4_butterfly/butterfly2/c_to_ri"

entity c_to_ri_entity_b676585c3d is
  port (
    c: in std_logic_vector(19 downto 0); 
    im: out std_logic_vector(9 downto 0); 
    re: out std_logic_vector(9 downto 0)
  );
end c_to_ri_entity_b676585c3d;

architecture structural of c_to_ri_entity_b676585c3d is
  signal concat_y_net_x3: std_logic_vector(19 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(9 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(9 downto 0);
  signal slice_im_y_net: std_logic_vector(9 downto 0);
  signal slice_re_y_net: std_logic_vector(9 downto 0);

begin
  concat_y_net_x3 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_a5a2f0dd62
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_a5a2f0dd62
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 9,
      x_width => 20,
      y_width => 10
    )
    port map (
      x => concat_y_net_x3,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 10,
      new_msb => 19,
      x_width => 20,
      y_width => 10
    )
    port map (
      x => concat_y_net_x3,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_1/r4_butterfly/butterfly2/ri_to_c"

entity ri_to_c_entity_1aa6ecbd54 is
  port (
    im: in std_logic_vector(10 downto 0); 
    re: in std_logic_vector(10 downto 0); 
    c: out std_logic_vector(21 downto 0)
  );
end ri_to_c_entity_1aa6ecbd54;

architecture structural of ri_to_c_entity_1aa6ecbd54 is
  signal concat_y_net_x0: std_logic_vector(21 downto 0);
  signal force_im_output_port_net: std_logic_vector(10 downto 0);
  signal force_re_output_port_net: std_logic_vector(10 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(10 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(10 downto 0);

begin
  requant1_dout_net_x0 <= im;
  requant0_dout_net_x0 <= re;
  c <= concat_y_net_x0;

  concat: entity work.concat_a9f0cfc482
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x0
    );

  force_im: entity work.reinterpret_d517af3309
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant1_dout_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_d517af3309
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant0_dout_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_1/r4_butterfly/butterfly2"

entity butterfly2_entity_3774d12e04 is
  port (
    a: in std_logic_vector(19 downto 0); 
    b: in std_logic_vector(19 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    a_b: out std_logic_vector(21 downto 0); 
    a_b_x0: out std_logic_vector(21 downto 0)
  );
end butterfly2_entity_3774d12e04;

architecture structural of butterfly2_entity_3774d12e04 is
  signal add_im_s_net: std_logic_vector(10 downto 0);
  signal add_re_s_net: std_logic_vector(10 downto 0);
  signal ce_1_sg_x256: std_logic;
  signal clk_1_sg_x256: std_logic;
  signal concat_y_net_x6: std_logic_vector(19 downto 0);
  signal concat_y_net_x7: std_logic_vector(19 downto 0);
  signal concat_y_net_x8: std_logic_vector(21 downto 0);
  signal concat_y_net_x9: std_logic_vector(21 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(9 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(9 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(9 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(9 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(10 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(10 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(10 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(10 downto 0);
  signal shift0_op_net: std_logic_vector(10 downto 0);
  signal shift1_op_net: std_logic_vector(10 downto 0);
  signal shift2_op_net: std_logic_vector(10 downto 0);
  signal shift3_op_net: std_logic_vector(10 downto 0);
  signal sub_im_s_net: std_logic_vector(10 downto 0);
  signal sub_re_s_net: std_logic_vector(10 downto 0);

begin
  concat_y_net_x6 <= a;
  concat_y_net_x7 <= b;
  ce_1_sg_x256 <= ce_1;
  clk_1_sg_x256 <= clk_1;
  a_b <= concat_y_net_x8;
  a_b_x0 <= concat_y_net_x9;

  add_im: entity work.addsub_74b65e93f7
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x256,
      clk => clk_1_sg_x256,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_74b65e93f7
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x256,
      clk => clk_1_sg_x256,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_58aaad2094: entity work.c_to_ri_entity_b676585c3d
    port map (
      c => concat_y_net_x7,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_b676585c3d: entity work.c_to_ri_entity_b676585c3d
    port map (
      c => concat_y_net_x6,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 11,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 11,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 11,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 11,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 11,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 11,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 11,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 11,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_eecb7aeb5f: entity work.ri_to_c_entity_1aa6ecbd54
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x9
    );

  ri_to_c_1aa6ecbd54: entity work.ri_to_c_entity_1aa6ecbd54
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x8
    );

  shift0: entity work.scale_1a387a5a22
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_1a387a5a22
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_1a387a5a22
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_1a387a5a22
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_89c5949a28
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x256,
      clk => clk_1_sg_x256,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_89c5949a28
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x256,
      clk => clk_1_sg_x256,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_1/r4_butterfly/butterfly3j"

entity butterfly3j_entity_857f216018 is
  port (
    a: in std_logic_vector(19 downto 0); 
    b: in std_logic_vector(19 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    a_b: out std_logic_vector(21 downto 0); 
    a_b_x0: out std_logic_vector(21 downto 0); 
    sync_out: out std_logic
  );
end butterfly3j_entity_857f216018;

architecture structural of butterfly3j_entity_857f216018 is
  signal add_im_s_net: std_logic_vector(10 downto 0);
  signal add_re_s_net: std_logic_vector(10 downto 0);
  signal ce_1_sg_x257: std_logic;
  signal clk_1_sg_x257: std_logic;
  signal concat_y_net_x6: std_logic_vector(19 downto 0);
  signal concat_y_net_x7: std_logic_vector(19 downto 0);
  signal concat_y_net_x8: std_logic_vector(21 downto 0);
  signal concat_y_net_x9: std_logic_vector(21 downto 0);
  signal delay_q_net_x1: std_logic;
  signal delay_q_net_x2: std_logic;
  signal force_im_output_port_net_x0: std_logic_vector(9 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(9 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(9 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(9 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(10 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(10 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(10 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(10 downto 0);
  signal shift0_op_net: std_logic_vector(10 downto 0);
  signal shift1_op_net: std_logic_vector(10 downto 0);
  signal shift2_op_net: std_logic_vector(10 downto 0);
  signal shift3_op_net: std_logic_vector(10 downto 0);
  signal sub_im_s_net: std_logic_vector(10 downto 0);
  signal sub_re_s_net: std_logic_vector(10 downto 0);

begin
  concat_y_net_x6 <= a;
  concat_y_net_x7 <= b;
  ce_1_sg_x257 <= ce_1;
  clk_1_sg_x257 <= clk_1;
  delay_q_net_x1 <= sync_in;
  a_b <= concat_y_net_x8;
  a_b_x0 <= concat_y_net_x9;
  sync_out <= delay_q_net_x2;

  add_im: entity work.addsub_89c5949a28
    port map (
      a => force_im_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x257,
      clk => clk_1_sg_x257,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_74b65e93f7
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x257,
      clk => clk_1_sg_x257,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_69e708c3e7: entity work.c_to_ri_entity_b676585c3d
    port map (
      c => concat_y_net_x7,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_db16e284a9: entity work.c_to_ri_entity_b676585c3d
    port map (
      c => concat_y_net_x6,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x257,
      clk => clk_1_sg_x257,
      d(0) => delay_q_net_x1,
      en => '1',
      q(0) => delay_q_net_x2
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 11,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 11,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 11,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 11,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 11,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 11,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 11,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 11,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_fe8298d8b0: entity work.ri_to_c_entity_1aa6ecbd54
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x9
    );

  ri_to_c_99000b22b8: entity work.ri_to_c_entity_1aa6ecbd54
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x8
    );

  shift0: entity work.scale_1a387a5a22
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_1a387a5a22
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_1a387a5a22
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_1a387a5a22
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_74b65e93f7
    port map (
      a => force_im_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x257,
      clk => clk_1_sg_x257,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_89c5949a28
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x257,
      clk => clk_1_sg_x257,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_1/r4_butterfly"

entity r4_butterfly_entity_bb1510c086 is
  port (
    a_in: in std_logic_vector(17 downto 0); 
    b_in: in std_logic_vector(17 downto 0); 
    c_in: in std_logic_vector(17 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d_in: in std_logic_vector(17 downto 0); 
    sync_in: in std_logic; 
    a_out: out std_logic_vector(21 downto 0); 
    b_out: out std_logic_vector(21 downto 0); 
    c_out: out std_logic_vector(21 downto 0); 
    d_out: out std_logic_vector(21 downto 0); 
    sync_out: out std_logic
  );
end r4_butterfly_entity_bb1510c086;

architecture structural of r4_butterfly_entity_bb1510c086 is
  signal bram_data_out_net_x13: std_logic_vector(17 downto 0);
  signal bram_data_out_net_x14: std_logic_vector(17 downto 0);
  signal ce_1_sg_x258: std_logic;
  signal clk_1_sg_x258: std_logic;
  signal concat_y_net_x14: std_logic_vector(21 downto 0);
  signal concat_y_net_x15: std_logic_vector(21 downto 0);
  signal concat_y_net_x16: std_logic_vector(21 downto 0);
  signal concat_y_net_x17: std_logic_vector(21 downto 0);
  signal concat_y_net_x6: std_logic_vector(19 downto 0);
  signal concat_y_net_x7: std_logic_vector(19 downto 0);
  signal concat_y_net_x8: std_logic_vector(19 downto 0);
  signal concat_y_net_x9: std_logic_vector(19 downto 0);
  signal delay_q_net_x1: std_logic;
  signal delay_q_net_x10: std_logic;
  signal delay_q_net_x9: std_logic;
  signal mux1_y_net_x11: std_logic_vector(17 downto 0);
  signal mux1_y_net_x12: std_logic_vector(17 downto 0);

begin
  bram_data_out_net_x13 <= a_in;
  mux1_y_net_x11 <= b_in;
  bram_data_out_net_x14 <= c_in;
  ce_1_sg_x258 <= ce_1;
  clk_1_sg_x258 <= clk_1;
  mux1_y_net_x12 <= d_in;
  delay_q_net_x9 <= sync_in;
  a_out <= concat_y_net_x14;
  b_out <= concat_y_net_x15;
  c_out <= concat_y_net_x16;
  d_out <= concat_y_net_x17;
  sync_out <= delay_q_net_x10;

  butterfly0_6f5feb3631: entity work.butterfly0_entity_6f5feb3631
    port map (
      a => bram_data_out_net_x13,
      b => bram_data_out_net_x14,
      ce_1 => ce_1_sg_x258,
      clk_1 => clk_1_sg_x258,
      a_b => concat_y_net_x6,
      a_b_x0 => concat_y_net_x7
    );

  butterfly1_7fd0666490: entity work.butterfly1_entity_7fd0666490
    port map (
      a => mux1_y_net_x11,
      b => mux1_y_net_x12,
      ce_1 => ce_1_sg_x258,
      clk_1 => clk_1_sg_x258,
      sync_in => delay_q_net_x9,
      a_b => concat_y_net_x8,
      a_b_x0 => concat_y_net_x9,
      sync_out => delay_q_net_x1
    );

  butterfly2_3774d12e04: entity work.butterfly2_entity_3774d12e04
    port map (
      a => concat_y_net_x6,
      b => concat_y_net_x8,
      ce_1 => ce_1_sg_x258,
      clk_1 => clk_1_sg_x258,
      a_b => concat_y_net_x14,
      a_b_x0 => concat_y_net_x15
    );

  butterfly3j_857f216018: entity work.butterfly3j_entity_857f216018
    port map (
      a => concat_y_net_x7,
      b => concat_y_net_x9,
      ce_1 => ce_1_sg_x258,
      clk_1 => clk_1_sg_x258,
      sync_in => delay_q_net_x1,
      a_b => concat_y_net_x16,
      a_b_x0 => concat_y_net_x17,
      sync_out => delay_q_net_x10
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_1"

entity r4_dit_stage_1_entity_36070de08f is
  port (
    a_in: in std_logic_vector(17 downto 0); 
    b_in: in std_logic_vector(17 downto 0); 
    c_in: in std_logic_vector(17 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d_in: in std_logic_vector(17 downto 0); 
    sync_in: in std_logic; 
    a_out: out std_logic_vector(21 downto 0); 
    b_out: out std_logic_vector(21 downto 0); 
    c_out: out std_logic_vector(21 downto 0); 
    d_out: out std_logic_vector(21 downto 0); 
    sync_out: out std_logic
  );
end r4_dit_stage_1_entity_36070de08f;

architecture structural of r4_dit_stage_1_entity_36070de08f is
  signal bram_data_out_net_x13: std_logic_vector(17 downto 0);
  signal bram_data_out_net_x14: std_logic_vector(17 downto 0);
  signal ce_1_sg_x259: std_logic;
  signal clk_1_sg_x259: std_logic;
  signal concat_y_net_x18: std_logic_vector(21 downto 0);
  signal concat_y_net_x19: std_logic_vector(21 downto 0);
  signal concat_y_net_x20: std_logic_vector(21 downto 0);
  signal concat_y_net_x21: std_logic_vector(21 downto 0);
  signal delay_q_net_x11: std_logic;
  signal delay_q_net_x12: std_logic;
  signal delay_q_net_x9: std_logic;
  signal mux1_y_net_x11: std_logic_vector(17 downto 0);
  signal mux1_y_net_x12: std_logic_vector(17 downto 0);
  signal shift1_op_net_x2: std_logic_vector(17 downto 0);
  signal shift4_op_net_x3: std_logic_vector(17 downto 0);
  signal shift5_op_net_x3: std_logic_vector(17 downto 0);
  signal shift_op_net_x2: std_logic_vector(17 downto 0);

begin
  shift_op_net_x2 <= a_in;
  shift1_op_net_x2 <= b_in;
  shift4_op_net_x3 <= c_in;
  ce_1_sg_x259 <= ce_1;
  clk_1_sg_x259 <= clk_1;
  shift5_op_net_x3 <= d_in;
  delay_q_net_x11 <= sync_in;
  a_out <= concat_y_net_x18;
  b_out <= concat_y_net_x19;
  c_out <= concat_y_net_x20;
  d_out <= concat_y_net_x21;
  sync_out <= delay_q_net_x12;

  quadplex_commutator_262766872e: entity work.quadplex_commutator_entity_262766872e
    port map (
      a => shift_op_net_x2,
      b => shift1_op_net_x2,
      c => shift4_op_net_x3,
      ce_1 => ce_1_sg_x259,
      clk_1 => clk_1_sg_x259,
      d => shift5_op_net_x3,
      sync_in => delay_q_net_x11,
      abcd0 => bram_data_out_net_x13,
      abcd1 => mux1_y_net_x11,
      abcd2 => bram_data_out_net_x14,
      abcd3 => mux1_y_net_x12,
      sync_out => delay_q_net_x9
    );

  r4_butterfly_bb1510c086: entity work.r4_butterfly_entity_bb1510c086
    port map (
      a_in => bram_data_out_net_x13,
      b_in => mux1_y_net_x11,
      c_in => bram_data_out_net_x14,
      ce_1 => ce_1_sg_x259,
      clk_1 => clk_1_sg_x259,
      d_in => mux1_y_net_x12,
      sync_in => delay_q_net_x9,
      a_out => concat_y_net_x18,
      b_out => concat_y_net_x19,
      c_out => concat_y_net_x20,
      d_out => concat_y_net_x21,
      sync_out => delay_q_net_x12
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/quadplex_commutator/biplex_commutator_01/delay_b/c_to_ri"

entity c_to_ri_entity_e4c3654c70 is
  port (
    c: in std_logic_vector(21 downto 0); 
    im: out std_logic_vector(10 downto 0); 
    re: out std_logic_vector(10 downto 0)
  );
end c_to_ri_entity_e4c3654c70;

architecture structural of c_to_ri_entity_e4c3654c70 is
  signal concat_y_net_x0: std_logic_vector(21 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(10 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(10 downto 0);
  signal slice_im_y_net: std_logic_vector(10 downto 0);
  signal slice_re_y_net: std_logic_vector(10 downto 0);

begin
  concat_y_net_x0 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_41416f6188
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_41416f6188
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 10,
      x_width => 22,
      y_width => 11
    )
    port map (
      x => concat_y_net_x0,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 11,
      new_msb => 21,
      x_width => 22,
      y_width => 11
    )
    port map (
      x => concat_y_net_x0,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/quadplex_commutator/biplex_commutator_01/delay_b/delay_im"

entity delay_im_entity_cc3d63fda2 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(10 downto 0); 
    out_x0: out std_logic_vector(10 downto 0)
  );
end delay_im_entity_cc3d63fda2;

architecture structural of delay_im_entity_cc3d63fda2 is
  signal bram_data_out_net_x0: std_logic_vector(10 downto 0);
  signal ce_1_sg_x260: std_logic;
  signal clk_1_sg_x260: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(5 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(10 downto 0);

begin
  ce_1_sg_x260 <= ce_1;
  clk_1_sg_x260 <= clk_1;
  force_im_output_port_net_x1 <= in_x0;
  out_x0 <= bram_data_out_net_x0;

  bram: entity work.xlspram
    generic map (
      c_address_width => 6,
      c_width => 11,
      core_name0 => "bmg_24_vx5_94232660d90f6688",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x260,
      clk => clk_1_sg_x260,
      data_in => force_im_output_port_net_x1,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => bram_data_out_net_x0
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit
    generic map (
      cnt_15_0 => 62,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "binary_counter_virtex5_10_0_fe346e03af2452eb",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 6
    )
    port map (
      ce => ce_1_sg_x260,
      clk => clk_1_sg_x260,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/quadplex_commutator/biplex_commutator_01/delay_b"

entity delay_b_entity_7978f90115 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(21 downto 0); 
    out_x0: out std_logic_vector(21 downto 0)
  );
end delay_b_entity_7978f90115;

architecture structural of delay_b_entity_7978f90115 is
  signal bram_data_out_net_x2: std_logic_vector(10 downto 0);
  signal bram_data_out_net_x3: std_logic_vector(10 downto 0);
  signal ce_1_sg_x262: std_logic;
  signal clk_1_sg_x262: std_logic;
  signal concat_y_net_x2: std_logic_vector(21 downto 0);
  signal concat_y_net_x3: std_logic_vector(21 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(10 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(10 downto 0);

begin
  ce_1_sg_x262 <= ce_1;
  clk_1_sg_x262 <= clk_1;
  concat_y_net_x2 <= in_x0;
  out_x0 <= concat_y_net_x3;

  c_to_ri_e4c3654c70: entity work.c_to_ri_entity_e4c3654c70
    port map (
      c => concat_y_net_x2,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  delay_im_cc3d63fda2: entity work.delay_im_entity_cc3d63fda2
    port map (
      ce_1 => ce_1_sg_x262,
      clk_1 => clk_1_sg_x262,
      in_x0 => force_im_output_port_net_x1,
      out_x0 => bram_data_out_net_x2
    );

  delay_re_20df67da12: entity work.delay_im_entity_cc3d63fda2
    port map (
      ce_1 => ce_1_sg_x262,
      clk_1 => clk_1_sg_x262,
      in_x0 => force_re_output_port_net_x1,
      out_x0 => bram_data_out_net_x3
    );

  ri_to_c_8b76e8fc8f: entity work.ri_to_c_entity_1aa6ecbd54
    port map (
      im => bram_data_out_net_x2,
      re => bram_data_out_net_x3,
      c => concat_y_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/quadplex_commutator/biplex_commutator_01"

entity biplex_commutator_01_entity_ded833414d is
  port (
    aloahi: in std_logic_vector(21 downto 0); 
    blobhi: in std_logic_vector(21 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(21 downto 0); 
    aloblo: out std_logic_vector(21 downto 0)
  );
end biplex_commutator_01_entity_ded833414d;

architecture structural of biplex_commutator_01_entity_ded833414d is
  signal ce_1_sg_x266: std_logic;
  signal clk_1_sg_x266: std_logic;
  signal concat_y_net_x0: std_logic_vector(21 downto 0);
  signal concat_y_net_x3: std_logic_vector(21 downto 0);
  signal concat_y_net_x4: std_logic_vector(21 downto 0);
  signal concat_y_net_x5: std_logic_vector(21 downto 0);
  signal counter_op_net: std_logic_vector(6 downto 0);
  signal delay_q_net_x0: std_logic;
  signal mux1_y_net_x0: std_logic_vector(21 downto 0);
  signal mux_y_net_x1: std_logic_vector(21 downto 0);
  signal top_bit_y_net: std_logic;

begin
  concat_y_net_x0 <= aloahi;
  concat_y_net_x4 <= blobhi;
  ce_1_sg_x266 <= ce_1;
  clk_1_sg_x266 <= clk_1;
  delay_q_net_x0 <= sync_in;
  ahibhi <= mux1_y_net_x0;
  aloblo <= concat_y_net_x5;

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_722dc5ef3883365e",
      op_arith => xlUnsigned,
      op_width => 7
    )
    port map (
      ce => ce_1_sg_x266,
      clk => clk_1_sg_x266,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x0,
      op => counter_op_net
    );

  delay_b_7978f90115: entity work.delay_b_entity_7978f90115
    port map (
      ce_1 => ce_1_sg_x266,
      clk_1 => clk_1_sg_x266,
      in_x0 => concat_y_net_x4,
      out_x0 => concat_y_net_x3
    );

  delay_lo_ef3b233400: entity work.delay_b_entity_7978f90115
    port map (
      ce_1 => ce_1_sg_x266,
      clk_1 => clk_1_sg_x266,
      in_x0 => mux_y_net_x1,
      out_x0 => concat_y_net_x5
    );

  mux: entity work.mux_c83be1b493
    port map (
      ce => ce_1_sg_x266,
      clk => clk_1_sg_x266,
      clr => '0',
      d0 => concat_y_net_x0,
      d1 => concat_y_net_x3,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x1
    );

  mux1: entity work.mux_c83be1b493
    port map (
      ce => ce_1_sg_x266,
      clk => clk_1_sg_x266,
      clr => '0',
      d0 => concat_y_net_x3,
      d1 => concat_y_net_x0,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x0
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 6,
      new_msb => 6,
      x_width => 7,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/quadplex_commutator/biplex_commutator_23"

entity biplex_commutator_23_entity_4c7f6cebf7 is
  port (
    aloahi: in std_logic_vector(21 downto 0); 
    blobhi: in std_logic_vector(21 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(21 downto 0); 
    aloblo: out std_logic_vector(21 downto 0); 
    sync_out: out std_logic
  );
end biplex_commutator_23_entity_4c7f6cebf7;

architecture structural of biplex_commutator_23_entity_4c7f6cebf7 is
  signal ce_1_sg_x273: std_logic;
  signal clk_1_sg_x273: std_logic;
  signal concat_y_net_x1: std_logic_vector(21 downto 0);
  signal concat_y_net_x3: std_logic_vector(21 downto 0);
  signal counter_op_net: std_logic_vector(6 downto 0);
  signal delay_q_net_x1: std_logic;
  signal delay_q_net_x2: std_logic;
  signal mux1_y_net_x2: std_logic_vector(21 downto 0);
  signal mux1_y_net_x3: std_logic_vector(21 downto 0);
  signal mux1_y_net_x4: std_logic_vector(21 downto 0);
  signal mux_y_net_x1: std_logic_vector(21 downto 0);
  signal top_bit_y_net: std_logic;

begin
  mux1_y_net_x2 <= aloahi;
  mux1_y_net_x3 <= blobhi;
  ce_1_sg_x273 <= ce_1;
  clk_1_sg_x273 <= clk_1;
  delay_q_net_x1 <= sync_in;
  ahibhi <= mux1_y_net_x4;
  aloblo <= concat_y_net_x3;
  sync_out <= delay_q_net_x2;

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_722dc5ef3883365e",
      op_arith => xlUnsigned,
      op_width => 7
    )
    port map (
      ce => ce_1_sg_x273,
      clk => clk_1_sg_x273,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x1,
      op => counter_op_net
    );

  delay: entity work.xldelay
    generic map (
      latency => 65,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x273,
      clk => clk_1_sg_x273,
      d(0) => delay_q_net_x1,
      en => '1',
      q(0) => delay_q_net_x2
    );

  delay_b_86e968c869: entity work.delay_b_entity_7978f90115
    port map (
      ce_1 => ce_1_sg_x273,
      clk_1 => clk_1_sg_x273,
      in_x0 => mux1_y_net_x3,
      out_x0 => concat_y_net_x1
    );

  delay_lo_afbb456070: entity work.delay_b_entity_7978f90115
    port map (
      ce_1 => ce_1_sg_x273,
      clk_1 => clk_1_sg_x273,
      in_x0 => mux_y_net_x1,
      out_x0 => concat_y_net_x3
    );

  mux: entity work.mux_c83be1b493
    port map (
      ce => ce_1_sg_x273,
      clk => clk_1_sg_x273,
      clr => '0',
      d0 => mux1_y_net_x2,
      d1 => concat_y_net_x1,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x1
    );

  mux1: entity work.mux_c83be1b493
    port map (
      ce => ce_1_sg_x273,
      clk => clk_1_sg_x273,
      clr => '0',
      d0 => concat_y_net_x1,
      d1 => mux1_y_net_x2,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x4
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 6,
      new_msb => 6,
      x_width => 7,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/quadplex_commutator/biplex_commutator_ac/delay_b/delay_im"

entity delay_im_entity_4893737a70 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(10 downto 0); 
    out_x0: out std_logic_vector(10 downto 0)
  );
end delay_im_entity_4893737a70;

architecture structural of delay_im_entity_4893737a70 is
  signal bram_data_out_net_x0: std_logic_vector(10 downto 0);
  signal ce_1_sg_x274: std_logic;
  signal clk_1_sg_x274: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(6 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(10 downto 0);

begin
  ce_1_sg_x274 <= ce_1;
  clk_1_sg_x274 <= clk_1;
  force_im_output_port_net_x1 <= in_x0;
  out_x0 <= bram_data_out_net_x0;

  bram: entity work.xlspram
    generic map (
      c_address_width => 7,
      c_width => 11,
      core_name0 => "bmg_24_vx5_491b66ad487fb1cf",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x274,
      clk => clk_1_sg_x274,
      data_in => force_im_output_port_net_x1,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => bram_data_out_net_x0
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit
    generic map (
      cnt_15_0 => 126,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "binary_counter_virtex5_10_0_722dc5ef3883365e",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 7
    )
    port map (
      ce => ce_1_sg_x274,
      clk => clk_1_sg_x274,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/quadplex_commutator/biplex_commutator_ac/delay_b"

entity delay_b_entity_aa403b4208 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(21 downto 0); 
    out_x0: out std_logic_vector(21 downto 0)
  );
end delay_b_entity_aa403b4208;

architecture structural of delay_b_entity_aa403b4208 is
  signal bram_data_out_net_x2: std_logic_vector(10 downto 0);
  signal bram_data_out_net_x3: std_logic_vector(10 downto 0);
  signal ce_1_sg_x276: std_logic;
  signal clk_1_sg_x276: std_logic;
  signal concat_y_net_x1: std_logic_vector(21 downto 0);
  signal concat_y_net_x22: std_logic_vector(21 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(10 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(10 downto 0);

begin
  ce_1_sg_x276 <= ce_1;
  clk_1_sg_x276 <= clk_1;
  concat_y_net_x22 <= in_x0;
  out_x0 <= concat_y_net_x1;

  c_to_ri_aa78964c2c: entity work.c_to_ri_entity_e4c3654c70
    port map (
      c => concat_y_net_x22,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  delay_im_4893737a70: entity work.delay_im_entity_4893737a70
    port map (
      ce_1 => ce_1_sg_x276,
      clk_1 => clk_1_sg_x276,
      in_x0 => force_im_output_port_net_x1,
      out_x0 => bram_data_out_net_x2
    );

  delay_re_748b4c7127: entity work.delay_im_entity_4893737a70
    port map (
      ce_1 => ce_1_sg_x276,
      clk_1 => clk_1_sg_x276,
      in_x0 => force_re_output_port_net_x1,
      out_x0 => bram_data_out_net_x3
    );

  ri_to_c_ce1027d767: entity work.ri_to_c_entity_1aa6ecbd54
    port map (
      im => bram_data_out_net_x2,
      re => bram_data_out_net_x3,
      c => concat_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/quadplex_commutator/biplex_commutator_ac"

entity biplex_commutator_ac_entity_6da9d0762c is
  port (
    aloahi: in std_logic_vector(21 downto 0); 
    blobhi: in std_logic_vector(21 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(21 downto 0); 
    aloblo: out std_logic_vector(21 downto 0); 
    sync_out: out std_logic
  );
end biplex_commutator_ac_entity_6da9d0762c;

architecture structural of biplex_commutator_ac_entity_6da9d0762c is
  signal ce_1_sg_x280: std_logic;
  signal clk_1_sg_x280: std_logic;
  signal concat_y_net_x1: std_logic_vector(21 downto 0);
  signal concat_y_net_x19: std_logic_vector(21 downto 0);
  signal concat_y_net_x23: std_logic_vector(21 downto 0);
  signal concat_y_net_x3: std_logic_vector(21 downto 0);
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay_q_net_x1: std_logic;
  signal delay_q_net_x13: std_logic;
  signal mux1_y_net_x3: std_logic_vector(21 downto 0);
  signal mux_y_net_x1: std_logic_vector(21 downto 0);
  signal top_bit_y_net: std_logic;

begin
  concat_y_net_x19 <= aloahi;
  concat_y_net_x23 <= blobhi;
  ce_1_sg_x280 <= ce_1;
  clk_1_sg_x280 <= clk_1;
  delay_q_net_x13 <= sync_in;
  ahibhi <= mux1_y_net_x3;
  aloblo <= concat_y_net_x3;
  sync_out <= delay_q_net_x1;

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_01e34ae12479a5e1",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x280,
      clk => clk_1_sg_x280,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x13,
      op => counter_op_net
    );

  delay: entity work.xldelay
    generic map (
      latency => 129,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x280,
      clk => clk_1_sg_x280,
      d(0) => delay_q_net_x13,
      en => '1',
      q(0) => delay_q_net_x1
    );

  delay_b_aa403b4208: entity work.delay_b_entity_aa403b4208
    port map (
      ce_1 => ce_1_sg_x280,
      clk_1 => clk_1_sg_x280,
      in_x0 => concat_y_net_x23,
      out_x0 => concat_y_net_x1
    );

  delay_lo_ee502bd1f9: entity work.delay_b_entity_aa403b4208
    port map (
      ce_1 => ce_1_sg_x280,
      clk_1 => clk_1_sg_x280,
      in_x0 => mux_y_net_x1,
      out_x0 => concat_y_net_x3
    );

  mux: entity work.mux_c83be1b493
    port map (
      ce => ce_1_sg_x280,
      clk => clk_1_sg_x280,
      clr => '0',
      d0 => concat_y_net_x19,
      d1 => concat_y_net_x1,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x1
    );

  mux1: entity work.mux_c83be1b493
    port map (
      ce => ce_1_sg_x280,
      clk => clk_1_sg_x280,
      clr => '0',
      d0 => concat_y_net_x1,
      d1 => concat_y_net_x19,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x3
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 7,
      new_msb => 7,
      x_width => 8,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/quadplex_commutator"

entity quadplex_commutator_entity_faeb218c71 is
  port (
    a: in std_logic_vector(21 downto 0); 
    b: in std_logic_vector(21 downto 0); 
    c: in std_logic_vector(21 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(21 downto 0); 
    sync_in: in std_logic; 
    abcd0: out std_logic_vector(21 downto 0); 
    abcd1: out std_logic_vector(21 downto 0); 
    abcd2: out std_logic_vector(21 downto 0); 
    abcd3: out std_logic_vector(21 downto 0); 
    sync_out: out std_logic
  );
end quadplex_commutator_entity_faeb218c71;

architecture structural of quadplex_commutator_entity_faeb218c71 is
  signal ce_1_sg_x288: std_logic;
  signal clk_1_sg_x288: std_logic;
  signal concat_y_net_x21: std_logic_vector(21 downto 0);
  signal concat_y_net_x25: std_logic_vector(21 downto 0);
  signal concat_y_net_x26: std_logic_vector(21 downto 0);
  signal concat_y_net_x27: std_logic_vector(21 downto 0);
  signal concat_y_net_x28: std_logic_vector(21 downto 0);
  signal concat_y_net_x4: std_logic_vector(21 downto 0);
  signal concat_y_net_x6: std_logic_vector(21 downto 0);
  signal concat_y_net_x7: std_logic_vector(21 downto 0);
  signal delay_q_net_x1: std_logic;
  signal delay_q_net_x15: std_logic;
  signal delay_q_net_x3: std_logic;
  signal delay_q_net_x4: std_logic;
  signal mux1_y_net_x3: std_logic_vector(21 downto 0);
  signal mux1_y_net_x5: std_logic_vector(21 downto 0);
  signal mux1_y_net_x6: std_logic_vector(21 downto 0);
  signal mux1_y_net_x7: std_logic_vector(21 downto 0);

begin
  concat_y_net_x21 <= a;
  concat_y_net_x25 <= b;
  concat_y_net_x26 <= c;
  ce_1_sg_x288 <= ce_1;
  clk_1_sg_x288 <= clk_1;
  concat_y_net_x27 <= d;
  delay_q_net_x15 <= sync_in;
  abcd0 <= concat_y_net_x28;
  abcd1 <= mux1_y_net_x6;
  abcd2 <= concat_y_net_x6;
  abcd3 <= mux1_y_net_x7;
  sync_out <= delay_q_net_x4;

  biplex_commutator_01_ded833414d: entity work.biplex_commutator_01_entity_ded833414d
    port map (
      aloahi => concat_y_net_x4,
      blobhi => concat_y_net_x7,
      ce_1 => ce_1_sg_x288,
      clk_1 => clk_1_sg_x288,
      sync_in => delay_q_net_x1,
      ahibhi => mux1_y_net_x6,
      aloblo => concat_y_net_x28
    );

  biplex_commutator_23_4c7f6cebf7: entity work.biplex_commutator_23_entity_4c7f6cebf7
    port map (
      aloahi => mux1_y_net_x3,
      blobhi => mux1_y_net_x5,
      ce_1 => ce_1_sg_x288,
      clk_1 => clk_1_sg_x288,
      sync_in => delay_q_net_x3,
      ahibhi => mux1_y_net_x7,
      aloblo => concat_y_net_x6,
      sync_out => delay_q_net_x4
    );

  biplex_commutator_ac_6da9d0762c: entity work.biplex_commutator_ac_entity_6da9d0762c
    port map (
      aloahi => concat_y_net_x21,
      blobhi => concat_y_net_x26,
      ce_1 => ce_1_sg_x288,
      clk_1 => clk_1_sg_x288,
      sync_in => delay_q_net_x15,
      ahibhi => mux1_y_net_x3,
      aloblo => concat_y_net_x4,
      sync_out => delay_q_net_x1
    );

  biplex_commutator_bd_d268060baa: entity work.biplex_commutator_ac_entity_6da9d0762c
    port map (
      aloahi => concat_y_net_x25,
      blobhi => concat_y_net_x27,
      ce_1 => ce_1_sg_x288,
      clk_1 => clk_1_sg_x288,
      sync_in => delay_q_net_x15,
      ahibhi => mux1_y_net_x5,
      aloblo => concat_y_net_x7,
      sync_out => delay_q_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/r4_butterfly/butterfly0/ri_to_c"

entity ri_to_c_entity_106d69554f is
  port (
    im: in std_logic_vector(11 downto 0); 
    re: in std_logic_vector(11 downto 0); 
    c: out std_logic_vector(23 downto 0)
  );
end ri_to_c_entity_106d69554f;

architecture structural of ri_to_c_entity_106d69554f is
  signal concat_y_net_x0: std_logic_vector(23 downto 0);
  signal force_im_output_port_net: std_logic_vector(11 downto 0);
  signal force_re_output_port_net: std_logic_vector(11 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(11 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(11 downto 0);

begin
  requant1_dout_net_x0 <= im;
  requant0_dout_net_x0 <= re;
  c <= concat_y_net_x0;

  concat: entity work.concat_6188124172
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x0
    );

  force_im: entity work.reinterpret_a106f99236
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant1_dout_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_a106f99236
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant0_dout_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/r4_butterfly/butterfly0"

entity butterfly0_entity_e4ab8e7fb8 is
  port (
    a: in std_logic_vector(21 downto 0); 
    b: in std_logic_vector(21 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    a_b: out std_logic_vector(23 downto 0); 
    a_b_x0: out std_logic_vector(23 downto 0)
  );
end butterfly0_entity_e4ab8e7fb8;

architecture structural of butterfly0_entity_e4ab8e7fb8 is
  signal add_im_s_net: std_logic_vector(11 downto 0);
  signal add_re_s_net: std_logic_vector(11 downto 0);
  signal ce_1_sg_x289: std_logic;
  signal clk_1_sg_x289: std_logic;
  signal concat_y_net_x3: std_logic_vector(21 downto 0);
  signal concat_y_net_x4: std_logic_vector(23 downto 0);
  signal concat_y_net_x5: std_logic_vector(23 downto 0);
  signal delay1_q_net_x1: std_logic_vector(21 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(10 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(10 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(10 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(10 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(11 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(11 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(11 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(11 downto 0);
  signal shift0_op_net: std_logic_vector(11 downto 0);
  signal shift1_op_net: std_logic_vector(11 downto 0);
  signal shift2_op_net: std_logic_vector(11 downto 0);
  signal shift3_op_net: std_logic_vector(11 downto 0);
  signal sub_im_s_net: std_logic_vector(11 downto 0);
  signal sub_re_s_net: std_logic_vector(11 downto 0);

begin
  delay1_q_net_x1 <= a;
  concat_y_net_x3 <= b;
  ce_1_sg_x289 <= ce_1;
  clk_1_sg_x289 <= clk_1;
  a_b <= concat_y_net_x4;
  a_b_x0 <= concat_y_net_x5;

  add_im: entity work.addsub_470ffe01d4
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x289,
      clk => clk_1_sg_x289,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_470ffe01d4
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x289,
      clk => clk_1_sg_x289,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_7a8c2eaa44: entity work.c_to_ri_entity_e4c3654c70
    port map (
      c => concat_y_net_x3,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_69e1c48265: entity work.c_to_ri_entity_e4c3654c70
    port map (
      c => delay1_q_net_x1,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 12,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 12,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 12,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 12,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 12,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 12,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 12,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 12,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_4f34da4f28: entity work.ri_to_c_entity_106d69554f
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x5
    );

  ri_to_c_106d69554f: entity work.ri_to_c_entity_106d69554f
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x4
    );

  shift0: entity work.scale_38e99696aa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_38e99696aa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_38e99696aa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_38e99696aa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_388a97573b
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x289,
      clk => clk_1_sg_x289,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_388a97573b
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x289,
      clk => clk_1_sg_x289,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/r4_butterfly/butterfly1"

entity butterfly1_entity_10e40369d0 is
  port (
    a: in std_logic_vector(21 downto 0); 
    b: in std_logic_vector(21 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    a_b: out std_logic_vector(23 downto 0); 
    a_b_x0: out std_logic_vector(23 downto 0); 
    sync_out: out std_logic
  );
end butterfly1_entity_10e40369d0;

architecture structural of butterfly1_entity_10e40369d0 is
  signal add_im_s_net: std_logic_vector(11 downto 0);
  signal add_re_s_net: std_logic_vector(11 downto 0);
  signal ce_1_sg_x290: std_logic;
  signal clk_1_sg_x290: std_logic;
  signal concat_y_net_x4: std_logic_vector(21 downto 0);
  signal concat_y_net_x5: std_logic_vector(21 downto 0);
  signal concat_y_net_x6: std_logic_vector(23 downto 0);
  signal concat_y_net_x7: std_logic_vector(23 downto 0);
  signal delay_q_net_x1: std_logic;
  signal delay_q_net_x2: std_logic;
  signal force_im_output_port_net_x0: std_logic_vector(10 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(10 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(10 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(10 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(11 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(11 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(11 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(11 downto 0);
  signal shift0_op_net: std_logic_vector(11 downto 0);
  signal shift1_op_net: std_logic_vector(11 downto 0);
  signal shift2_op_net: std_logic_vector(11 downto 0);
  signal shift3_op_net: std_logic_vector(11 downto 0);
  signal sub_im_s_net: std_logic_vector(11 downto 0);
  signal sub_re_s_net: std_logic_vector(11 downto 0);

begin
  concat_y_net_x4 <= a;
  concat_y_net_x5 <= b;
  ce_1_sg_x290 <= ce_1;
  clk_1_sg_x290 <= clk_1;
  delay_q_net_x1 <= sync_in;
  a_b <= concat_y_net_x6;
  a_b_x0 <= concat_y_net_x7;
  sync_out <= delay_q_net_x2;

  add_im: entity work.addsub_470ffe01d4
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x290,
      clk => clk_1_sg_x290,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_470ffe01d4
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x290,
      clk => clk_1_sg_x290,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_9ac75e5e5c: entity work.c_to_ri_entity_e4c3654c70
    port map (
      c => concat_y_net_x5,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_1896a26c45: entity work.c_to_ri_entity_e4c3654c70
    port map (
      c => concat_y_net_x4,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x290,
      clk => clk_1_sg_x290,
      d(0) => delay_q_net_x1,
      en => '1',
      q(0) => delay_q_net_x2
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 12,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 12,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 12,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 12,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 12,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 12,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 12,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 12,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_64518560c6: entity work.ri_to_c_entity_106d69554f
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x7
    );

  ri_to_c_d125536ae8: entity work.ri_to_c_entity_106d69554f
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x6
    );

  shift0: entity work.scale_38e99696aa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_38e99696aa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_38e99696aa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_38e99696aa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_388a97573b
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x290,
      clk => clk_1_sg_x290,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_388a97573b
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x290,
      clk => clk_1_sg_x290,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/r4_butterfly/butterfly2/c_to_ri"

entity c_to_ri_entity_8c773e837f is
  port (
    c: in std_logic_vector(23 downto 0); 
    im: out std_logic_vector(11 downto 0); 
    re: out std_logic_vector(11 downto 0)
  );
end c_to_ri_entity_8c773e837f;

architecture structural of c_to_ri_entity_8c773e837f is
  signal concat_y_net_x5: std_logic_vector(23 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(11 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(11 downto 0);
  signal slice_im_y_net: std_logic_vector(11 downto 0);
  signal slice_re_y_net: std_logic_vector(11 downto 0);

begin
  concat_y_net_x5 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 11,
      x_width => 24,
      y_width => 12
    )
    port map (
      x => concat_y_net_x5,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 12,
      new_msb => 23,
      x_width => 24,
      y_width => 12
    )
    port map (
      x => concat_y_net_x5,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/r4_butterfly/butterfly2/ri_to_c"

entity ri_to_c_entity_b2ea3e0c09 is
  port (
    im: in std_logic_vector(12 downto 0); 
    re: in std_logic_vector(12 downto 0); 
    c: out std_logic_vector(25 downto 0)
  );
end ri_to_c_entity_b2ea3e0c09;

architecture structural of ri_to_c_entity_b2ea3e0c09 is
  signal concat_y_net_x0: std_logic_vector(25 downto 0);
  signal force_im_output_port_net: std_logic_vector(12 downto 0);
  signal force_re_output_port_net: std_logic_vector(12 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(12 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(12 downto 0);

begin
  requant1_dout_net_x0 <= im;
  requant0_dout_net_x0 <= re;
  c <= concat_y_net_x0;

  concat: entity work.concat_4720648850
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x0
    );

  force_im: entity work.reinterpret_18554b6b75
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant1_dout_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_18554b6b75
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant0_dout_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/r4_butterfly/butterfly2"

entity butterfly2_entity_3729a34a52 is
  port (
    a: in std_logic_vector(23 downto 0); 
    b: in std_logic_vector(23 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    a_b: out std_logic_vector(25 downto 0); 
    a_b_x0: out std_logic_vector(25 downto 0)
  );
end butterfly2_entity_3729a34a52;

architecture structural of butterfly2_entity_3729a34a52 is
  signal add_im_s_net: std_logic_vector(12 downto 0);
  signal add_re_s_net: std_logic_vector(12 downto 0);
  signal ce_1_sg_x291: std_logic;
  signal clk_1_sg_x291: std_logic;
  signal concat_y_net_x10: std_logic_vector(23 downto 0);
  signal concat_y_net_x11: std_logic_vector(25 downto 0);
  signal concat_y_net_x12: std_logic_vector(25 downto 0);
  signal concat_y_net_x9: std_logic_vector(23 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(11 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(11 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(11 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(11 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(12 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(12 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(12 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(12 downto 0);
  signal shift0_op_net: std_logic_vector(12 downto 0);
  signal shift1_op_net: std_logic_vector(12 downto 0);
  signal shift2_op_net: std_logic_vector(12 downto 0);
  signal shift3_op_net: std_logic_vector(12 downto 0);
  signal sub_im_s_net: std_logic_vector(12 downto 0);
  signal sub_re_s_net: std_logic_vector(12 downto 0);

begin
  concat_y_net_x9 <= a;
  concat_y_net_x10 <= b;
  ce_1_sg_x291 <= ce_1;
  clk_1_sg_x291 <= clk_1;
  a_b <= concat_y_net_x11;
  a_b_x0 <= concat_y_net_x12;

  add_im: entity work.addsub_ed74d532a0
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x291,
      clk => clk_1_sg_x291,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_ed74d532a0
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x291,
      clk => clk_1_sg_x291,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_f07ffd8787: entity work.c_to_ri_entity_8c773e837f
    port map (
      c => concat_y_net_x10,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_8c773e837f: entity work.c_to_ri_entity_8c773e837f
    port map (
      c => concat_y_net_x9,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 13,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 13,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 13,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 13,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 13,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 13,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 13,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 13,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_b9dea031b0: entity work.ri_to_c_entity_b2ea3e0c09
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x12
    );

  ri_to_c_b2ea3e0c09: entity work.ri_to_c_entity_b2ea3e0c09
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x11
    );

  shift0: entity work.scale_d11c4b5145
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_d11c4b5145
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_d11c4b5145
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_d11c4b5145
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_f11535f968
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x291,
      clk => clk_1_sg_x291,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_f11535f968
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x291,
      clk => clk_1_sg_x291,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/r4_butterfly/butterfly3j"

entity butterfly3j_entity_a66adcb4d9 is
  port (
    a: in std_logic_vector(23 downto 0); 
    b: in std_logic_vector(23 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    a_b: out std_logic_vector(25 downto 0); 
    a_b_x0: out std_logic_vector(25 downto 0); 
    sync_out: out std_logic
  );
end butterfly3j_entity_a66adcb4d9;

architecture structural of butterfly3j_entity_a66adcb4d9 is
  signal add_im_s_net: std_logic_vector(12 downto 0);
  signal add_re_s_net: std_logic_vector(12 downto 0);
  signal ce_1_sg_x292: std_logic;
  signal clk_1_sg_x292: std_logic;
  signal concat_y_net_x10: std_logic_vector(25 downto 0);
  signal concat_y_net_x11: std_logic_vector(25 downto 0);
  signal concat_y_net_x7: std_logic_vector(23 downto 0);
  signal concat_y_net_x9: std_logic_vector(23 downto 0);
  signal delay_q_net_x0: std_logic;
  signal delay_q_net_x3: std_logic;
  signal force_im_output_port_net_x0: std_logic_vector(11 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(11 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(11 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(11 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(12 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(12 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(12 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(12 downto 0);
  signal shift0_op_net: std_logic_vector(12 downto 0);
  signal shift1_op_net: std_logic_vector(12 downto 0);
  signal shift2_op_net: std_logic_vector(12 downto 0);
  signal shift3_op_net: std_logic_vector(12 downto 0);
  signal sub_im_s_net: std_logic_vector(12 downto 0);
  signal sub_re_s_net: std_logic_vector(12 downto 0);

begin
  concat_y_net_x7 <= a;
  concat_y_net_x9 <= b;
  ce_1_sg_x292 <= ce_1;
  clk_1_sg_x292 <= clk_1;
  delay_q_net_x3 <= sync_in;
  a_b <= concat_y_net_x10;
  a_b_x0 <= concat_y_net_x11;
  sync_out <= delay_q_net_x0;

  add_im: entity work.addsub_f11535f968
    port map (
      a => force_im_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x292,
      clk => clk_1_sg_x292,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_ed74d532a0
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x292,
      clk => clk_1_sg_x292,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_b5d99b141c: entity work.c_to_ri_entity_8c773e837f
    port map (
      c => concat_y_net_x9,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_d6dc3c38a6: entity work.c_to_ri_entity_8c773e837f
    port map (
      c => concat_y_net_x7,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x292,
      clk => clk_1_sg_x292,
      d(0) => delay_q_net_x3,
      en => '1',
      q(0) => delay_q_net_x0
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 13,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 13,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 13,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 13,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 13,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 13,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 13,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 13,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_9aa47d2124: entity work.ri_to_c_entity_b2ea3e0c09
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x11
    );

  ri_to_c_d5b9a70513: entity work.ri_to_c_entity_b2ea3e0c09
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x10
    );

  shift0: entity work.scale_d11c4b5145
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_d11c4b5145
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_d11c4b5145
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_d11c4b5145
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_ed74d532a0
    port map (
      a => force_im_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x292,
      clk => clk_1_sg_x292,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_f11535f968
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x292,
      clk => clk_1_sg_x292,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/r4_butterfly"

entity r4_butterfly_entity_d98f53dda4 is
  port (
    a_in: in std_logic_vector(21 downto 0); 
    b_in: in std_logic_vector(21 downto 0); 
    c_in: in std_logic_vector(21 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d_in: in std_logic_vector(21 downto 0); 
    sync_in: in std_logic; 
    a_out: out std_logic_vector(25 downto 0); 
    b_out: out std_logic_vector(25 downto 0); 
    c_out: out std_logic_vector(25 downto 0); 
    d_out: out std_logic_vector(25 downto 0); 
    sync_out: out std_logic
  );
end r4_butterfly_entity_d98f53dda4;

architecture structural of r4_butterfly_entity_d98f53dda4 is
  signal ce_1_sg_x293: std_logic;
  signal clk_1_sg_x293: std_logic;
  signal concat_y_net_x10: std_logic_vector(23 downto 0);
  signal concat_y_net_x11: std_logic_vector(23 downto 0);
  signal concat_y_net_x16: std_logic_vector(21 downto 0);
  signal concat_y_net_x17: std_logic_vector(21 downto 0);
  signal concat_y_net_x18: std_logic_vector(21 downto 0);
  signal concat_y_net_x19: std_logic_vector(25 downto 0);
  signal concat_y_net_x20: std_logic_vector(25 downto 0);
  signal concat_y_net_x21: std_logic_vector(25 downto 0);
  signal concat_y_net_x22: std_logic_vector(25 downto 0);
  signal concat_y_net_x7: std_logic_vector(23 downto 0);
  signal concat_y_net_x9: std_logic_vector(23 downto 0);
  signal delay1_q_net_x2: std_logic_vector(21 downto 0);
  signal delay_q_net_x2: std_logic;
  signal delay_q_net_x3: std_logic;
  signal delay_q_net_x4: std_logic;

begin
  delay1_q_net_x2 <= a_in;
  concat_y_net_x16 <= b_in;
  concat_y_net_x17 <= c_in;
  ce_1_sg_x293 <= ce_1;
  clk_1_sg_x293 <= clk_1;
  concat_y_net_x18 <= d_in;
  delay_q_net_x2 <= sync_in;
  a_out <= concat_y_net_x19;
  b_out <= concat_y_net_x20;
  c_out <= concat_y_net_x21;
  d_out <= concat_y_net_x22;
  sync_out <= delay_q_net_x4;

  butterfly0_e4ab8e7fb8: entity work.butterfly0_entity_e4ab8e7fb8
    port map (
      a => delay1_q_net_x2,
      b => concat_y_net_x17,
      ce_1 => ce_1_sg_x293,
      clk_1 => clk_1_sg_x293,
      a_b => concat_y_net_x9,
      a_b_x0 => concat_y_net_x7
    );

  butterfly1_10e40369d0: entity work.butterfly1_entity_10e40369d0
    port map (
      a => concat_y_net_x16,
      b => concat_y_net_x18,
      ce_1 => ce_1_sg_x293,
      clk_1 => clk_1_sg_x293,
      sync_in => delay_q_net_x2,
      a_b => concat_y_net_x10,
      a_b_x0 => concat_y_net_x11,
      sync_out => delay_q_net_x3
    );

  butterfly2_3729a34a52: entity work.butterfly2_entity_3729a34a52
    port map (
      a => concat_y_net_x9,
      b => concat_y_net_x10,
      ce_1 => ce_1_sg_x293,
      clk_1 => clk_1_sg_x293,
      a_b => concat_y_net_x19,
      a_b_x0 => concat_y_net_x20
    );

  butterfly3j_a66adcb4d9: entity work.butterfly3j_entity_a66adcb4d9
    port map (
      a => concat_y_net_x7,
      b => concat_y_net_x11,
      ce_1 => ce_1_sg_x293,
      clk_1 => clk_1_sg_x293,
      sync_in => delay_q_net_x3,
      a_b => concat_y_net_x21,
      a_b_x0 => concat_y_net_x22,
      sync_out => delay_q_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/r4_twiddle/cmpy1/c_to_ri"

entity c_to_ri_entity_f83de36a99 is
  port (
    c: in std_logic_vector(21 downto 0); 
    im: out std_logic_vector(10 downto 0); 
    re: out std_logic_vector(10 downto 0)
  );
end c_to_ri_entity_f83de36a99;

architecture structural of c_to_ri_entity_f83de36a99 is
  signal delay1_q_net_x0: std_logic_vector(21 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(10 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(10 downto 0);
  signal slice_im_y_net: std_logic_vector(10 downto 0);
  signal slice_re_y_net: std_logic_vector(10 downto 0);

begin
  delay1_q_net_x0 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_41416f6188
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_41416f6188
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 10,
      x_width => 22,
      y_width => 11
    )
    port map (
      x => delay1_q_net_x0,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 11,
      new_msb => 21,
      x_width => 22,
      y_width => 11
    )
    port map (
      x => delay1_q_net_x0,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/r4_twiddle/cmpy1/c_to_ri1"

entity c_to_ri1_entity_7fe674c156 is
  port (
    c: in std_logic_vector(17 downto 0); 
    im: out std_logic_vector(8 downto 0); 
    re: out std_logic_vector(8 downto 0)
  );
end c_to_ri1_entity_7fe674c156;

architecture structural of c_to_ri1_entity_7fe674c156 is
  signal force_im_output_port_net_x0: std_logic_vector(8 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(8 downto 0);
  signal mem_c_data_net_x0: std_logic_vector(17 downto 0);
  signal slice_im_y_net: std_logic_vector(8 downto 0);
  signal slice_re_y_net: std_logic_vector(8 downto 0);

begin
  mem_c_data_net_x0 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_ceef4fc23d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_ceef4fc23d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 8,
      x_width => 18,
      y_width => 9
    )
    port map (
      x => mem_c_data_net_x0,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 9,
      new_msb => 17,
      x_width => 18,
      y_width => 9
    )
    port map (
      x => mem_c_data_net_x0,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/r4_twiddle/cmpy1/ri_to_c"

entity ri_to_c_entity_bf9c2f4755 is
  port (
    im: in std_logic_vector(10 downto 0); 
    re: in std_logic_vector(10 downto 0); 
    c: out std_logic_vector(21 downto 0)
  );
end ri_to_c_entity_bf9c2f4755;

architecture structural of ri_to_c_entity_bf9c2f4755 is
  signal concat_y_net_x17: std_logic_vector(21 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(10 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(10 downto 0);
  signal force_im_output_port_net: std_logic_vector(10 downto 0);
  signal force_re_output_port_net: std_logic_vector(10 downto 0);

begin
  convert_im_dout_net_x0 <= im;
  convert_re_dout_net_x0 <= re;
  c <= concat_y_net_x17;

  concat: entity work.concat_a9f0cfc482
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x17
    );

  force_im: entity work.reinterpret_d517af3309
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert_im_dout_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_d517af3309
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert_re_dout_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/r4_twiddle/cmpy1"

entity cmpy1_entity_c4e84ca371 is
  port (
    a_in: in std_logic_vector(21 downto 0); 
    b: in std_logic_vector(21 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    w: in std_logic_vector(17 downto 0); 
    a_out: out std_logic_vector(21 downto 0); 
    bw: out std_logic_vector(21 downto 0); 
    sync_out: out std_logic
  );
end cmpy1_entity_c4e84ca371;

architecture structural of cmpy1_entity_c4e84ca371 is
  signal br_add_bi_s_net: std_logic_vector(11 downto 0);
  signal ce_1_sg_x294: std_logic;
  signal clk_1_sg_x294: std_logic;
  signal concat_y_net_x18: std_logic_vector(21 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(10 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(10 downto 0);
  signal delay1_q_net_x1: std_logic_vector(21 downto 0);
  signal delay1_q_net_x3: std_logic_vector(21 downto 0);
  signal delay2_q_net_x0: std_logic_vector(21 downto 0);
  signal delay3_q_net_x0: std_logic;
  signal delay_q_net_x3: std_logic;
  signal force_im_output_port_net_x0: std_logic_vector(10 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(8 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(10 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(8 downto 0);
  signal imim_p_net: std_logic_vector(17 downto 0);
  signal mem_c_data_net_x1: std_logic_vector(17 downto 0);
  signal rere_p_net: std_logic_vector(17 downto 0);
  signal rr_add_ii_s_net: std_logic_vector(17 downto 0);
  signal rr_sub_ii_s_net: std_logic_vector(17 downto 0);
  signal ss_sub_rrii_s_net: std_logic_vector(17 downto 0);
  signal sumsum_p_net: std_logic_vector(17 downto 0);
  signal wr_add_wi_s_net: std_logic_vector(9 downto 0);

begin
  delay2_q_net_x0 <= a_in;
  delay1_q_net_x1 <= b;
  ce_1_sg_x294 <= ce_1;
  clk_1_sg_x294 <= clk_1;
  delay3_q_net_x0 <= sync_in;
  mem_c_data_net_x1 <= w;
  a_out <= delay1_q_net_x3;
  bw <= concat_y_net_x18;
  sync_out <= delay_q_net_x3;

  br_add_bi: entity work.addsub_d661929060
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x0,
      ce => ce_1_sg_x294,
      clk => clk_1_sg_x294,
      clr => '0',
      s => br_add_bi_s_net
    );

  c_to_ri1_7fe674c156: entity work.c_to_ri1_entity_7fe674c156
    port map (
      c => mem_c_data_net_x1,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_f83de36a99: entity work.c_to_ri_entity_f83de36a99
    port map (
      c => delay1_q_net_x1,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  convert_im: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 18,
      dout_arith => 2,
      dout_bin_pt => 10,
      dout_width => 11,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x294,
      clk => clk_1_sg_x294,
      clr => '0',
      din => ss_sub_rrii_s_net,
      dout => convert_im_dout_net_x0
    );

  convert_re: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 18,
      dout_arith => 2,
      dout_bin_pt => 10,
      dout_width => 11,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x294,
      clk => clk_1_sg_x294,
      clr => '0',
      din => rr_sub_ii_s_net,
      dout => convert_re_dout_net_x0
    );

  delay: entity work.xldelay
    generic map (
      latency => 8,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x294,
      clk => clk_1_sg_x294,
      d(0) => delay3_q_net_x0,
      en => '1',
      q(0) => delay_q_net_x3
    );

  delay1: entity work.xldelay
    generic map (
      latency => 8,
      reg_retiming => 0,
      width => 22
    )
    port map (
      ce => ce_1_sg_x294,
      clk => clk_1_sg_x294,
      d => delay2_q_net_x0,
      en => '1',
      q => delay1_q_net_x3
    );

  imim: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 10,
      a_width => 11,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 11,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 11,
      c_output_width => 20,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_b0c844385805a270",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 17,
      p_width => 18,
      quantization => 1
    )
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x294,
      clk => clk_1_sg_x294,
      clr => '0',
      core_ce => ce_1_sg_x294,
      core_clk => clk_1_sg_x294,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => imim_p_net
    );

  rere: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 10,
      a_width => 11,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 11,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 11,
      c_output_width => 20,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_b0c844385805a270",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 17,
      p_width => 18,
      quantization => 1
    )
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x294,
      clk => clk_1_sg_x294,
      clr => '0',
      core_ce => ce_1_sg_x294,
      core_clk => clk_1_sg_x294,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => rere_p_net
    );

  ri_to_c_bf9c2f4755: entity work.ri_to_c_entity_bf9c2f4755
    port map (
      im => convert_im_dout_net_x0,
      re => convert_re_dout_net_x0,
      c => concat_y_net_x18
    );

  rr_add_ii: entity work.addsub_c8df442ec4
    port map (
      a => imim_p_net,
      b => rere_p_net,
      ce => ce_1_sg_x294,
      clk => clk_1_sg_x294,
      clr => '0',
      s => rr_add_ii_s_net
    );

  rr_sub_ii: entity work.addsub_6dd6aca36b
    port map (
      a => rere_p_net,
      b => imim_p_net,
      ce => ce_1_sg_x294,
      clk => clk_1_sg_x294,
      clr => '0',
      s => rr_sub_ii_s_net
    );

  ss_sub_rrii: entity work.addsub_21a1218bfe
    port map (
      a => sumsum_p_net,
      b => rr_add_ii_s_net,
      ce => ce_1_sg_x294,
      clk => clk_1_sg_x294,
      clr => '0',
      s => ss_sub_rrii_s_net
    );

  sumsum: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 10,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 10,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 10,
      c_baat => 12,
      c_output_width => 22,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_c90585d1a7e9d3a6",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 17,
      p_width => 18,
      quantization => 1
    )
    port map (
      a => br_add_bi_s_net,
      b => wr_add_wi_s_net,
      ce => ce_1_sg_x294,
      clk => clk_1_sg_x294,
      clr => '0',
      core_ce => ce_1_sg_x294,
      core_clk => clk_1_sg_x294,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => sumsum_p_net
    );

  wr_add_wi: entity work.addsub_bd2bd198b1
    port map (
      a => force_re_output_port_net_x1,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x294,
      clk => clk_1_sg_x294,
      clr => '0',
      s => wr_add_wi_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/r4_twiddle/cmpy2"

entity cmpy2_entity_ec95a7d9de is
  port (
    b: in std_logic_vector(21 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    w: in std_logic_vector(17 downto 0); 
    bw: out std_logic_vector(21 downto 0)
  );
end cmpy2_entity_ec95a7d9de;

architecture structural of cmpy2_entity_ec95a7d9de is
  signal br_add_bi_s_net: std_logic_vector(11 downto 0);
  signal ce_1_sg_x295: std_logic;
  signal clk_1_sg_x295: std_logic;
  signal concat_y_net_x19: std_logic_vector(21 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(10 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(10 downto 0);
  signal delay4_q_net_x1: std_logic_vector(21 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(10 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(8 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(10 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(8 downto 0);
  signal imim_p_net: std_logic_vector(17 downto 0);
  signal mem_c_data_net_x1: std_logic_vector(17 downto 0);
  signal rere_p_net: std_logic_vector(17 downto 0);
  signal rr_add_ii_s_net: std_logic_vector(17 downto 0);
  signal rr_sub_ii_s_net: std_logic_vector(17 downto 0);
  signal ss_sub_rrii_s_net: std_logic_vector(17 downto 0);
  signal sumsum_p_net: std_logic_vector(17 downto 0);
  signal wr_add_wi_s_net: std_logic_vector(9 downto 0);

begin
  delay4_q_net_x1 <= b;
  ce_1_sg_x295 <= ce_1;
  clk_1_sg_x295 <= clk_1;
  mem_c_data_net_x1 <= w;
  bw <= concat_y_net_x19;

  br_add_bi: entity work.addsub_d661929060
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x0,
      ce => ce_1_sg_x295,
      clk => clk_1_sg_x295,
      clr => '0',
      s => br_add_bi_s_net
    );

  c_to_ri1_8d6de131f1: entity work.c_to_ri1_entity_7fe674c156
    port map (
      c => mem_c_data_net_x1,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_210c5f6eb8: entity work.c_to_ri_entity_f83de36a99
    port map (
      c => delay4_q_net_x1,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  convert_im: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 18,
      dout_arith => 2,
      dout_bin_pt => 10,
      dout_width => 11,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x295,
      clk => clk_1_sg_x295,
      clr => '0',
      din => ss_sub_rrii_s_net,
      dout => convert_im_dout_net_x0
    );

  convert_re: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 17,
      din_width => 18,
      dout_arith => 2,
      dout_bin_pt => 10,
      dout_width => 11,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x295,
      clk => clk_1_sg_x295,
      clr => '0',
      din => rr_sub_ii_s_net,
      dout => convert_re_dout_net_x0
    );

  imim: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 10,
      a_width => 11,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 11,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 11,
      c_output_width => 20,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_b0c844385805a270",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 17,
      p_width => 18,
      quantization => 1
    )
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x295,
      clk => clk_1_sg_x295,
      clr => '0',
      core_ce => ce_1_sg_x295,
      core_clk => clk_1_sg_x295,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => imim_p_net
    );

  rere: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 10,
      a_width => 11,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 11,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 11,
      c_output_width => 20,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_b0c844385805a270",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 17,
      p_width => 18,
      quantization => 1
    )
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x295,
      clk => clk_1_sg_x295,
      clr => '0',
      core_ce => ce_1_sg_x295,
      core_clk => clk_1_sg_x295,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => rere_p_net
    );

  ri_to_c_c859a6b798: entity work.ri_to_c_entity_bf9c2f4755
    port map (
      im => convert_im_dout_net_x0,
      re => convert_re_dout_net_x0,
      c => concat_y_net_x19
    );

  rr_add_ii: entity work.addsub_c8df442ec4
    port map (
      a => imim_p_net,
      b => rere_p_net,
      ce => ce_1_sg_x295,
      clk => clk_1_sg_x295,
      clr => '0',
      s => rr_add_ii_s_net
    );

  rr_sub_ii: entity work.addsub_6dd6aca36b
    port map (
      a => rere_p_net,
      b => imim_p_net,
      ce => ce_1_sg_x295,
      clk => clk_1_sg_x295,
      clr => '0',
      s => rr_sub_ii_s_net
    );

  ss_sub_rrii: entity work.addsub_21a1218bfe
    port map (
      a => sumsum_p_net,
      b => rr_add_ii_s_net,
      ce => ce_1_sg_x295,
      clk => clk_1_sg_x295,
      clr => '0',
      s => ss_sub_rrii_s_net
    );

  sumsum: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 10,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 10,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 10,
      c_baat => 12,
      c_output_width => 22,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_c90585d1a7e9d3a6",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 17,
      p_width => 18,
      quantization => 1
    )
    port map (
      a => br_add_bi_s_net,
      b => wr_add_wi_s_net,
      ce => ce_1_sg_x295,
      clk => clk_1_sg_x295,
      clr => '0',
      core_ce => ce_1_sg_x295,
      core_clk => clk_1_sg_x295,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => sumsum_p_net
    );

  wr_add_wi: entity work.addsub_bd2bd198b1
    port map (
      a => force_re_output_port_net_x1,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x295,
      clk => clk_1_sg_x295,
      clr => '0',
      s => wr_add_wi_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/r4_twiddle/twiddle_gen1"

entity twiddle_gen1_entity_4cc7338556 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    w: out std_logic_vector(17 downto 0)
  );
end twiddle_gen1_entity_4cc7338556;

architecture structural of twiddle_gen1_entity_4cc7338556 is
  signal addr_sel_y_net: std_logic_vector(1 downto 0);
  signal ce_1_sg_x297: std_logic;
  signal clk_1_sg_x297: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay_q_net_x5: std_logic;
  signal mem_c_data_net_x2: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x297 <= ce_1;
  clk_1_sg_x297 <= clk_1;
  delay_q_net_x5 <= sync_in;
  w <= mem_c_data_net_x2;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 6,
      new_msb => 7,
      x_width => 8,
      y_width => 2
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_01e34ae12479a5e1",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x297,
      clk => clk_1_sg_x297,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x5,
      op => counter_op_net
    );

  mem_c: entity work.xlsprom_dist
    generic map (
      addr_width => 2,
      c_address_width => 4,
      c_width => 18,
      core_name0 => "dmg_33_vx5_3b5827b9b9c34c2c",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x297,
      clk => clk_1_sg_x297,
      en => "1",
      data => mem_c_data_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/r4_twiddle/twiddle_gen2"

entity twiddle_gen2_entity_6e2acf61e4 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    w: out std_logic_vector(17 downto 0)
  );
end twiddle_gen2_entity_6e2acf61e4;

architecture structural of twiddle_gen2_entity_6e2acf61e4 is
  signal addr_sel_y_net: std_logic_vector(1 downto 0);
  signal ce_1_sg_x298: std_logic;
  signal clk_1_sg_x298: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay_q_net_x6: std_logic;
  signal mem_c_data_net_x2: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x298 <= ce_1;
  clk_1_sg_x298 <= clk_1;
  delay_q_net_x6 <= sync_in;
  w <= mem_c_data_net_x2;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 6,
      new_msb => 7,
      x_width => 8,
      y_width => 2
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_01e34ae12479a5e1",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x298,
      clk => clk_1_sg_x298,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x6,
      op => counter_op_net
    );

  mem_c: entity work.xlsprom_dist
    generic map (
      addr_width => 2,
      c_address_width => 4,
      c_width => 18,
      core_name0 => "dmg_33_vx5_6ab87bec3a8932d3",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x298,
      clk => clk_1_sg_x298,
      en => "1",
      data => mem_c_data_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/r4_twiddle/twiddle_gen3"

entity twiddle_gen3_entity_7dbf20bc5c is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    w: out std_logic_vector(17 downto 0)
  );
end twiddle_gen3_entity_7dbf20bc5c;

architecture structural of twiddle_gen3_entity_7dbf20bc5c is
  signal addr_sel_y_net: std_logic_vector(1 downto 0);
  signal ce_1_sg_x299: std_logic;
  signal clk_1_sg_x299: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay_q_net_x7: std_logic;
  signal mem_c_data_net_x2: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x299 <= ce_1;
  clk_1_sg_x299 <= clk_1;
  delay_q_net_x7 <= sync_in;
  w <= mem_c_data_net_x2;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 6,
      new_msb => 7,
      x_width => 8,
      y_width => 2
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_01e34ae12479a5e1",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x299,
      clk => clk_1_sg_x299,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x7,
      op => counter_op_net
    );

  mem_c: entity work.xlsprom_dist
    generic map (
      addr_width => 2,
      c_address_width => 4,
      c_width => 18,
      core_name0 => "dmg_33_vx5_af86f8a7a0de7d76",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x299,
      clk => clk_1_sg_x299,
      en => "1",
      data => mem_c_data_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2/r4_twiddle"

entity r4_twiddle_entity_509aef3b56 is
  port (
    a_in: in std_logic_vector(21 downto 0); 
    b: in std_logic_vector(21 downto 0); 
    c: in std_logic_vector(21 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(21 downto 0); 
    sync_in: in std_logic; 
    a_out: out std_logic_vector(21 downto 0); 
    bw: out std_logic_vector(21 downto 0); 
    cw: out std_logic_vector(21 downto 0); 
    dw: out std_logic_vector(21 downto 0); 
    sync_out: out std_logic
  );
end r4_twiddle_entity_509aef3b56;

architecture structural of r4_twiddle_entity_509aef3b56 is
  signal ce_1_sg_x300: std_logic;
  signal clk_1_sg_x300: std_logic;
  signal concat_y_net_x21: std_logic_vector(21 downto 0);
  signal concat_y_net_x22: std_logic_vector(21 downto 0);
  signal concat_y_net_x23: std_logic_vector(21 downto 0);
  signal concat_y_net_x29: std_logic_vector(21 downto 0);
  signal concat_y_net_x7: std_logic_vector(21 downto 0);
  signal delay1_q_net_x1: std_logic_vector(21 downto 0);
  signal delay1_q_net_x4: std_logic_vector(21 downto 0);
  signal delay2_q_net_x0: std_logic_vector(21 downto 0);
  signal delay3_q_net_x0: std_logic;
  signal delay4_q_net_x1: std_logic_vector(21 downto 0);
  signal delay5_q_net_x1: std_logic_vector(21 downto 0);
  signal delay_q_net_x4: std_logic;
  signal delay_q_net_x8: std_logic;
  signal mem_c_data_net_x2: std_logic_vector(17 downto 0);
  signal mem_c_data_net_x3: std_logic_vector(17 downto 0);
  signal mem_c_data_net_x4: std_logic_vector(17 downto 0);
  signal mux1_y_net_x8: std_logic_vector(21 downto 0);
  signal mux1_y_net_x9: std_logic_vector(21 downto 0);

begin
  concat_y_net_x29 <= a_in;
  mux1_y_net_x8 <= b;
  concat_y_net_x7 <= c;
  ce_1_sg_x300 <= ce_1;
  clk_1_sg_x300 <= clk_1;
  mux1_y_net_x9 <= d;
  delay_q_net_x8 <= sync_in;
  a_out <= delay1_q_net_x4;
  bw <= concat_y_net_x21;
  cw <= concat_y_net_x22;
  dw <= concat_y_net_x23;
  sync_out <= delay_q_net_x4;

  cmpy1_c4e84ca371: entity work.cmpy1_entity_c4e84ca371
    port map (
      a_in => delay2_q_net_x0,
      b => delay1_q_net_x1,
      ce_1 => ce_1_sg_x300,
      clk_1 => clk_1_sg_x300,
      sync_in => delay3_q_net_x0,
      w => mem_c_data_net_x2,
      a_out => delay1_q_net_x4,
      bw => concat_y_net_x21,
      sync_out => delay_q_net_x4
    );

  cmpy2_ec95a7d9de: entity work.cmpy2_entity_ec95a7d9de
    port map (
      b => delay4_q_net_x1,
      ce_1 => ce_1_sg_x300,
      clk_1 => clk_1_sg_x300,
      w => mem_c_data_net_x3,
      bw => concat_y_net_x22
    );

  cmpy3_c59e6f184c: entity work.cmpy2_entity_ec95a7d9de
    port map (
      b => delay5_q_net_x1,
      ce_1 => ce_1_sg_x300,
      clk_1 => clk_1_sg_x300,
      w => mem_c_data_net_x4,
      bw => concat_y_net_x23
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 22
    )
    port map (
      ce => ce_1_sg_x300,
      clk => clk_1_sg_x300,
      d => mux1_y_net_x8,
      en => '1',
      q => delay1_q_net_x1
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 22
    )
    port map (
      ce => ce_1_sg_x300,
      clk => clk_1_sg_x300,
      d => concat_y_net_x29,
      en => '1',
      q => delay2_q_net_x0
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x300,
      clk => clk_1_sg_x300,
      d(0) => delay_q_net_x8,
      en => '1',
      q(0) => delay3_q_net_x0
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 22
    )
    port map (
      ce => ce_1_sg_x300,
      clk => clk_1_sg_x300,
      d => concat_y_net_x7,
      en => '1',
      q => delay4_q_net_x1
    );

  delay5: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 22
    )
    port map (
      ce => ce_1_sg_x300,
      clk => clk_1_sg_x300,
      d => mux1_y_net_x9,
      en => '1',
      q => delay5_q_net_x1
    );

  twiddle_gen1_4cc7338556: entity work.twiddle_gen1_entity_4cc7338556
    port map (
      ce_1 => ce_1_sg_x300,
      clk_1 => clk_1_sg_x300,
      sync_in => delay_q_net_x8,
      w => mem_c_data_net_x2
    );

  twiddle_gen2_6e2acf61e4: entity work.twiddle_gen2_entity_6e2acf61e4
    port map (
      ce_1 => ce_1_sg_x300,
      clk_1 => clk_1_sg_x300,
      sync_in => delay_q_net_x8,
      w => mem_c_data_net_x3
    );

  twiddle_gen3_7dbf20bc5c: entity work.twiddle_gen3_entity_7dbf20bc5c
    port map (
      ce_1 => ce_1_sg_x300,
      clk_1 => clk_1_sg_x300,
      sync_in => delay_q_net_x8,
      w => mem_c_data_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_2"

entity r4_dit_stage_2_entity_1a9931e6f1 is
  port (
    a_in: in std_logic_vector(21 downto 0); 
    b_in: in std_logic_vector(21 downto 0); 
    c_in: in std_logic_vector(21 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d_in: in std_logic_vector(21 downto 0); 
    sync_in: in std_logic; 
    a_out: out std_logic_vector(25 downto 0); 
    b_out: out std_logic_vector(25 downto 0); 
    c_out: out std_logic_vector(25 downto 0); 
    d_out: out std_logic_vector(25 downto 0); 
    sync_out: out std_logic
  );
end r4_dit_stage_2_entity_1a9931e6f1;

architecture structural of r4_dit_stage_2_entity_1a9931e6f1 is
  signal ce_1_sg_x301: std_logic;
  signal clk_1_sg_x301: std_logic;
  signal concat_y_net_x23: std_logic_vector(21 downto 0);
  signal concat_y_net_x24: std_logic_vector(21 downto 0);
  signal concat_y_net_x29: std_logic_vector(21 downto 0);
  signal concat_y_net_x31: std_logic_vector(21 downto 0);
  signal concat_y_net_x32: std_logic_vector(21 downto 0);
  signal concat_y_net_x33: std_logic_vector(21 downto 0);
  signal concat_y_net_x34: std_logic_vector(21 downto 0);
  signal concat_y_net_x35: std_logic_vector(21 downto 0);
  signal concat_y_net_x36: std_logic_vector(25 downto 0);
  signal concat_y_net_x37: std_logic_vector(25 downto 0);
  signal concat_y_net_x38: std_logic_vector(25 downto 0);
  signal concat_y_net_x39: std_logic_vector(25 downto 0);
  signal concat_y_net_x7: std_logic_vector(21 downto 0);
  signal delay1_q_net_x4: std_logic_vector(21 downto 0);
  signal delay_q_net_x16: std_logic;
  signal delay_q_net_x5: std_logic;
  signal delay_q_net_x6: std_logic;
  signal delay_q_net_x8: std_logic;
  signal mux1_y_net_x8: std_logic_vector(21 downto 0);
  signal mux1_y_net_x9: std_logic_vector(21 downto 0);

begin
  concat_y_net_x24 <= a_in;
  concat_y_net_x33 <= b_in;
  concat_y_net_x34 <= c_in;
  ce_1_sg_x301 <= ce_1;
  clk_1_sg_x301 <= clk_1;
  concat_y_net_x35 <= d_in;
  delay_q_net_x16 <= sync_in;
  a_out <= concat_y_net_x36;
  b_out <= concat_y_net_x37;
  c_out <= concat_y_net_x38;
  d_out <= concat_y_net_x39;
  sync_out <= delay_q_net_x6;

  quadplex_commutator_faeb218c71: entity work.quadplex_commutator_entity_faeb218c71
    port map (
      a => concat_y_net_x24,
      b => concat_y_net_x33,
      c => concat_y_net_x34,
      ce_1 => ce_1_sg_x301,
      clk_1 => clk_1_sg_x301,
      d => concat_y_net_x35,
      sync_in => delay_q_net_x16,
      abcd0 => concat_y_net_x29,
      abcd1 => mux1_y_net_x8,
      abcd2 => concat_y_net_x7,
      abcd3 => mux1_y_net_x9,
      sync_out => delay_q_net_x8
    );

  r4_butterfly_d98f53dda4: entity work.r4_butterfly_entity_d98f53dda4
    port map (
      a_in => delay1_q_net_x4,
      b_in => concat_y_net_x23,
      c_in => concat_y_net_x31,
      ce_1 => ce_1_sg_x301,
      clk_1 => clk_1_sg_x301,
      d_in => concat_y_net_x32,
      sync_in => delay_q_net_x5,
      a_out => concat_y_net_x36,
      b_out => concat_y_net_x37,
      c_out => concat_y_net_x38,
      d_out => concat_y_net_x39,
      sync_out => delay_q_net_x6
    );

  r4_twiddle_509aef3b56: entity work.r4_twiddle_entity_509aef3b56
    port map (
      a_in => concat_y_net_x29,
      b => mux1_y_net_x8,
      c => concat_y_net_x7,
      ce_1 => ce_1_sg_x301,
      clk_1 => clk_1_sg_x301,
      d => mux1_y_net_x9,
      sync_in => delay_q_net_x8,
      a_out => delay1_q_net_x4,
      bw => concat_y_net_x23,
      cw => concat_y_net_x31,
      dw => concat_y_net_x32,
      sync_out => delay_q_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/quadplex_commutator/biplex_commutator_01/delay_b"

entity delay_b_entity_29100ef262 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(25 downto 0); 
    out_x0: out std_logic_vector(25 downto 0)
  );
end delay_b_entity_29100ef262;

architecture structural of delay_b_entity_29100ef262 is
  signal ce_1_sg_x302: std_logic;
  signal clk_1_sg_x302: std_logic;
  signal slr_q_net_x1: std_logic_vector(25 downto 0);
  signal slr_q_net_x2: std_logic_vector(25 downto 0);

begin
  ce_1_sg_x302 <= ce_1;
  clk_1_sg_x302 <= clk_1;
  slr_q_net_x1 <= in_x0;
  out_x0 <= slr_q_net_x2;

  slr: entity work.xldelay
    generic map (
      latency => 16,
      reg_retiming => 0,
      width => 26
    )
    port map (
      ce => ce_1_sg_x302,
      clk => clk_1_sg_x302,
      d => slr_q_net_x1,
      en => '1',
      q => slr_q_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/quadplex_commutator/biplex_commutator_01"

entity biplex_commutator_01_entity_04980bcfcc is
  port (
    aloahi: in std_logic_vector(25 downto 0); 
    blobhi: in std_logic_vector(25 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(25 downto 0); 
    aloblo: out std_logic_vector(25 downto 0)
  );
end biplex_commutator_01_entity_04980bcfcc;

architecture structural of biplex_commutator_01_entity_04980bcfcc is
  signal ce_1_sg_x304: std_logic;
  signal clk_1_sg_x304: std_logic;
  signal counter_op_net: std_logic_vector(4 downto 0);
  signal delay_q_net_x0: std_logic;
  signal mux1_y_net_x0: std_logic_vector(25 downto 0);
  signal mux_y_net_x0: std_logic_vector(25 downto 0);
  signal slr_q_net_x2: std_logic_vector(25 downto 0);
  signal slr_q_net_x3: std_logic_vector(25 downto 0);
  signal slr_q_net_x4: std_logic_vector(25 downto 0);
  signal slr_q_net_x5: std_logic_vector(25 downto 0);
  signal top_bit_y_net: std_logic;

begin
  slr_q_net_x3 <= aloahi;
  slr_q_net_x4 <= blobhi;
  ce_1_sg_x304 <= ce_1;
  clk_1_sg_x304 <= clk_1;
  delay_q_net_x0 <= sync_in;
  ahibhi <= mux1_y_net_x0;
  aloblo <= slr_q_net_x5;

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_ad5bcb1136ed8cf6",
      op_arith => xlUnsigned,
      op_width => 5
    )
    port map (
      ce => ce_1_sg_x304,
      clk => clk_1_sg_x304,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x0,
      op => counter_op_net
    );

  delay_b_29100ef262: entity work.delay_b_entity_29100ef262
    port map (
      ce_1 => ce_1_sg_x304,
      clk_1 => clk_1_sg_x304,
      in_x0 => slr_q_net_x4,
      out_x0 => slr_q_net_x2
    );

  delay_lo_2caa73f32b: entity work.delay_b_entity_29100ef262
    port map (
      ce_1 => ce_1_sg_x304,
      clk_1 => clk_1_sg_x304,
      in_x0 => mux_y_net_x0,
      out_x0 => slr_q_net_x5
    );

  mux: entity work.mux_0eccfc7565
    port map (
      ce => ce_1_sg_x304,
      clk => clk_1_sg_x304,
      clr => '0',
      d0 => slr_q_net_x3,
      d1 => slr_q_net_x2,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x0
    );

  mux1: entity work.mux_0eccfc7565
    port map (
      ce => ce_1_sg_x304,
      clk => clk_1_sg_x304,
      clr => '0',
      d0 => slr_q_net_x2,
      d1 => slr_q_net_x3,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x0
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 4,
      x_width => 5,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/quadplex_commutator/biplex_commutator_23"

entity biplex_commutator_23_entity_e42bb62919 is
  port (
    aloahi: in std_logic_vector(25 downto 0); 
    blobhi: in std_logic_vector(25 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(25 downto 0); 
    aloblo: out std_logic_vector(25 downto 0); 
    sync_out: out std_logic
  );
end biplex_commutator_23_entity_e42bb62919;

architecture structural of biplex_commutator_23_entity_e42bb62919 is
  signal ce_1_sg_x307: std_logic;
  signal clk_1_sg_x307: std_logic;
  signal counter_op_net: std_logic_vector(4 downto 0);
  signal delay_q_net_x1: std_logic;
  signal delay_q_net_x2: std_logic;
  signal mux1_y_net_x2: std_logic_vector(25 downto 0);
  signal mux1_y_net_x3: std_logic_vector(25 downto 0);
  signal mux1_y_net_x4: std_logic_vector(25 downto 0);
  signal mux_y_net_x0: std_logic_vector(25 downto 0);
  signal slr_q_net_x0: std_logic_vector(25 downto 0);
  signal slr_q_net_x2: std_logic_vector(25 downto 0);
  signal top_bit_y_net: std_logic;

begin
  mux1_y_net_x2 <= aloahi;
  mux1_y_net_x3 <= blobhi;
  ce_1_sg_x307 <= ce_1;
  clk_1_sg_x307 <= clk_1;
  delay_q_net_x1 <= sync_in;
  ahibhi <= mux1_y_net_x4;
  aloblo <= slr_q_net_x2;
  sync_out <= delay_q_net_x2;

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_ad5bcb1136ed8cf6",
      op_arith => xlUnsigned,
      op_width => 5
    )
    port map (
      ce => ce_1_sg_x307,
      clk => clk_1_sg_x307,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x1,
      op => counter_op_net
    );

  delay: entity work.xldelay
    generic map (
      latency => 17,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x307,
      clk => clk_1_sg_x307,
      d(0) => delay_q_net_x1,
      en => '1',
      q(0) => delay_q_net_x2
    );

  delay_b_607ae1128b: entity work.delay_b_entity_29100ef262
    port map (
      ce_1 => ce_1_sg_x307,
      clk_1 => clk_1_sg_x307,
      in_x0 => mux1_y_net_x3,
      out_x0 => slr_q_net_x0
    );

  delay_lo_81399f1f9a: entity work.delay_b_entity_29100ef262
    port map (
      ce_1 => ce_1_sg_x307,
      clk_1 => clk_1_sg_x307,
      in_x0 => mux_y_net_x0,
      out_x0 => slr_q_net_x2
    );

  mux: entity work.mux_0eccfc7565
    port map (
      ce => ce_1_sg_x307,
      clk => clk_1_sg_x307,
      clr => '0',
      d0 => mux1_y_net_x2,
      d1 => slr_q_net_x0,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x0
    );

  mux1: entity work.mux_0eccfc7565
    port map (
      ce => ce_1_sg_x307,
      clk => clk_1_sg_x307,
      clr => '0',
      d0 => slr_q_net_x0,
      d1 => mux1_y_net_x2,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x4
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 4,
      x_width => 5,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/quadplex_commutator/biplex_commutator_ac/delay_b"

entity delay_b_entity_d2b33b9d3c is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(25 downto 0); 
    out_x0: out std_logic_vector(25 downto 0)
  );
end delay_b_entity_d2b33b9d3c;

architecture structural of delay_b_entity_d2b33b9d3c is
  signal ce_1_sg_x308: std_logic;
  signal clk_1_sg_x308: std_logic;
  signal concat_y_net_x39: std_logic_vector(25 downto 0);
  signal slr_q_net_x0: std_logic_vector(25 downto 0);

begin
  ce_1_sg_x308 <= ce_1;
  clk_1_sg_x308 <= clk_1;
  concat_y_net_x39 <= in_x0;
  out_x0 <= slr_q_net_x0;

  slr: entity work.xldelay
    generic map (
      latency => 32,
      reg_retiming => 0,
      width => 26
    )
    port map (
      ce => ce_1_sg_x308,
      clk => clk_1_sg_x308,
      d => concat_y_net_x39,
      en => '1',
      q => slr_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/quadplex_commutator/biplex_commutator_ac"

entity biplex_commutator_ac_entity_a42560e7f0 is
  port (
    aloahi: in std_logic_vector(25 downto 0); 
    blobhi: in std_logic_vector(25 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(25 downto 0); 
    aloblo: out std_logic_vector(25 downto 0); 
    sync_out: out std_logic
  );
end biplex_commutator_ac_entity_a42560e7f0;

architecture structural of biplex_commutator_ac_entity_a42560e7f0 is
  signal ce_1_sg_x310: std_logic;
  signal clk_1_sg_x310: std_logic;
  signal concat_y_net_x40: std_logic_vector(25 downto 0);
  signal concat_y_net_x41: std_logic_vector(25 downto 0);
  signal counter_op_net: std_logic_vector(5 downto 0);
  signal delay_q_net_x7: std_logic;
  signal delay_q_net_x8: std_logic;
  signal mux1_y_net_x3: std_logic_vector(25 downto 0);
  signal mux_y_net_x0: std_logic_vector(25 downto 0);
  signal slr_q_net_x0: std_logic_vector(25 downto 0);
  signal slr_q_net_x5: std_logic_vector(25 downto 0);
  signal top_bit_y_net: std_logic;

begin
  concat_y_net_x40 <= aloahi;
  concat_y_net_x41 <= blobhi;
  ce_1_sg_x310 <= ce_1;
  clk_1_sg_x310 <= clk_1;
  delay_q_net_x7 <= sync_in;
  ahibhi <= mux1_y_net_x3;
  aloblo <= slr_q_net_x5;
  sync_out <= delay_q_net_x8;

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_fe346e03af2452eb",
      op_arith => xlUnsigned,
      op_width => 6
    )
    port map (
      ce => ce_1_sg_x310,
      clk => clk_1_sg_x310,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x7,
      op => counter_op_net
    );

  delay: entity work.xldelay
    generic map (
      latency => 33,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x310,
      clk => clk_1_sg_x310,
      d(0) => delay_q_net_x7,
      en => '1',
      q(0) => delay_q_net_x8
    );

  delay_b_d2b33b9d3c: entity work.delay_b_entity_d2b33b9d3c
    port map (
      ce_1 => ce_1_sg_x310,
      clk_1 => clk_1_sg_x310,
      in_x0 => concat_y_net_x41,
      out_x0 => slr_q_net_x0
    );

  delay_lo_370e9a7b18: entity work.delay_b_entity_d2b33b9d3c
    port map (
      ce_1 => ce_1_sg_x310,
      clk_1 => clk_1_sg_x310,
      in_x0 => mux_y_net_x0,
      out_x0 => slr_q_net_x5
    );

  mux: entity work.mux_0eccfc7565
    port map (
      ce => ce_1_sg_x310,
      clk => clk_1_sg_x310,
      clr => '0',
      d0 => concat_y_net_x40,
      d1 => slr_q_net_x0,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x0
    );

  mux1: entity work.mux_0eccfc7565
    port map (
      ce => ce_1_sg_x310,
      clk => clk_1_sg_x310,
      clr => '0',
      d0 => slr_q_net_x0,
      d1 => concat_y_net_x40,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x3
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 5,
      new_msb => 5,
      x_width => 6,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/quadplex_commutator"

entity quadplex_commutator_entity_5766cb42d0 is
  port (
    a: in std_logic_vector(25 downto 0); 
    b: in std_logic_vector(25 downto 0); 
    c: in std_logic_vector(25 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(25 downto 0); 
    sync_in: in std_logic; 
    abcd0: out std_logic_vector(25 downto 0); 
    abcd1: out std_logic_vector(25 downto 0); 
    abcd2: out std_logic_vector(25 downto 0); 
    abcd3: out std_logic_vector(25 downto 0); 
    sync_out: out std_logic
  );
end quadplex_commutator_entity_5766cb42d0;

architecture structural of quadplex_commutator_entity_5766cb42d0 is
  signal ce_1_sg_x314: std_logic;
  signal clk_1_sg_x314: std_logic;
  signal concat_y_net_x44: std_logic_vector(25 downto 0);
  signal concat_y_net_x45: std_logic_vector(25 downto 0);
  signal concat_y_net_x46: std_logic_vector(25 downto 0);
  signal concat_y_net_x47: std_logic_vector(25 downto 0);
  signal delay_q_net_x10: std_logic;
  signal delay_q_net_x11: std_logic;
  signal delay_q_net_x12: std_logic;
  signal delay_q_net_x9: std_logic;
  signal mux1_y_net_x3: std_logic_vector(25 downto 0);
  signal mux1_y_net_x5: std_logic_vector(25 downto 0);
  signal mux1_y_net_x6: std_logic_vector(25 downto 0);
  signal mux1_y_net_x7: std_logic_vector(25 downto 0);
  signal slr_q_net_x6: std_logic_vector(25 downto 0);
  signal slr_q_net_x7: std_logic_vector(25 downto 0);
  signal slr_q_net_x8: std_logic_vector(25 downto 0);
  signal slr_q_net_x9: std_logic_vector(25 downto 0);

begin
  concat_y_net_x44 <= a;
  concat_y_net_x45 <= b;
  concat_y_net_x46 <= c;
  ce_1_sg_x314 <= ce_1;
  clk_1_sg_x314 <= clk_1;
  concat_y_net_x47 <= d;
  delay_q_net_x11 <= sync_in;
  abcd0 <= slr_q_net_x8;
  abcd1 <= mux1_y_net_x6;
  abcd2 <= slr_q_net_x9;
  abcd3 <= mux1_y_net_x7;
  sync_out <= delay_q_net_x12;

  biplex_commutator_01_04980bcfcc: entity work.biplex_commutator_01_entity_04980bcfcc
    port map (
      aloahi => slr_q_net_x6,
      blobhi => slr_q_net_x7,
      ce_1 => ce_1_sg_x314,
      clk_1 => clk_1_sg_x314,
      sync_in => delay_q_net_x9,
      ahibhi => mux1_y_net_x6,
      aloblo => slr_q_net_x8
    );

  biplex_commutator_23_e42bb62919: entity work.biplex_commutator_23_entity_e42bb62919
    port map (
      aloahi => mux1_y_net_x3,
      blobhi => mux1_y_net_x5,
      ce_1 => ce_1_sg_x314,
      clk_1 => clk_1_sg_x314,
      sync_in => delay_q_net_x10,
      ahibhi => mux1_y_net_x7,
      aloblo => slr_q_net_x9,
      sync_out => delay_q_net_x12
    );

  biplex_commutator_ac_a42560e7f0: entity work.biplex_commutator_ac_entity_a42560e7f0
    port map (
      aloahi => concat_y_net_x44,
      blobhi => concat_y_net_x46,
      ce_1 => ce_1_sg_x314,
      clk_1 => clk_1_sg_x314,
      sync_in => delay_q_net_x11,
      ahibhi => mux1_y_net_x3,
      aloblo => slr_q_net_x6,
      sync_out => delay_q_net_x9
    );

  biplex_commutator_bd_3158fb47e8: entity work.biplex_commutator_ac_entity_a42560e7f0
    port map (
      aloahi => concat_y_net_x45,
      blobhi => concat_y_net_x47,
      ce_1 => ce_1_sg_x314,
      clk_1 => clk_1_sg_x314,
      sync_in => delay_q_net_x11,
      ahibhi => mux1_y_net_x5,
      aloblo => slr_q_net_x7,
      sync_out => delay_q_net_x10
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/r4_butterfly/butterfly0/c_to_ri"

entity c_to_ri_entity_4bcfaa67a7 is
  port (
    c: in std_logic_vector(25 downto 0); 
    im: out std_logic_vector(12 downto 0); 
    re: out std_logic_vector(12 downto 0)
  );
end c_to_ri_entity_4bcfaa67a7;

architecture structural of c_to_ri_entity_4bcfaa67a7 is
  signal delay1_q_net_x0: std_logic_vector(25 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(12 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(12 downto 0);
  signal slice_im_y_net: std_logic_vector(12 downto 0);
  signal slice_re_y_net: std_logic_vector(12 downto 0);

begin
  delay1_q_net_x0 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_33580846c4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_33580846c4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 12,
      x_width => 26,
      y_width => 13
    )
    port map (
      x => delay1_q_net_x0,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 13,
      new_msb => 25,
      x_width => 26,
      y_width => 13
    )
    port map (
      x => delay1_q_net_x0,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/r4_butterfly/butterfly0/ri_to_c"

entity ri_to_c_entity_cd5a03d1c5 is
  port (
    im: in std_logic_vector(13 downto 0); 
    re: in std_logic_vector(13 downto 0); 
    c: out std_logic_vector(27 downto 0)
  );
end ri_to_c_entity_cd5a03d1c5;

architecture structural of ri_to_c_entity_cd5a03d1c5 is
  signal concat_y_net_x0: std_logic_vector(27 downto 0);
  signal force_im_output_port_net: std_logic_vector(13 downto 0);
  signal force_re_output_port_net: std_logic_vector(13 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(13 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(13 downto 0);

begin
  requant1_dout_net_x0 <= im;
  requant0_dout_net_x0 <= re;
  c <= concat_y_net_x0;

  concat: entity work.concat_e5ffcbc394
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x0
    );

  force_im: entity work.reinterpret_eb72d4ea08
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant1_dout_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_eb72d4ea08
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant0_dout_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/r4_butterfly/butterfly0"

entity butterfly0_entity_7236742b6e is
  port (
    a: in std_logic_vector(25 downto 0); 
    b: in std_logic_vector(25 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    a_b: out std_logic_vector(27 downto 0); 
    a_b_x0: out std_logic_vector(27 downto 0)
  );
end butterfly0_entity_7236742b6e;

architecture structural of butterfly0_entity_7236742b6e is
  signal add_im_s_net: std_logic_vector(13 downto 0);
  signal add_re_s_net: std_logic_vector(13 downto 0);
  signal ce_1_sg_x315: std_logic;
  signal clk_1_sg_x315: std_logic;
  signal concat_y_net_x3: std_logic_vector(25 downto 0);
  signal concat_y_net_x4: std_logic_vector(27 downto 0);
  signal concat_y_net_x5: std_logic_vector(27 downto 0);
  signal delay1_q_net_x1: std_logic_vector(25 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(12 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(12 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(12 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(12 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(13 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(13 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(13 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(13 downto 0);
  signal shift0_op_net: std_logic_vector(13 downto 0);
  signal shift1_op_net: std_logic_vector(13 downto 0);
  signal shift2_op_net: std_logic_vector(13 downto 0);
  signal shift3_op_net: std_logic_vector(13 downto 0);
  signal sub_im_s_net: std_logic_vector(13 downto 0);
  signal sub_re_s_net: std_logic_vector(13 downto 0);

begin
  delay1_q_net_x1 <= a;
  concat_y_net_x3 <= b;
  ce_1_sg_x315 <= ce_1;
  clk_1_sg_x315 <= clk_1;
  a_b <= concat_y_net_x4;
  a_b_x0 <= concat_y_net_x5;

  add_im: entity work.addsub_4a1b074932
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x315,
      clk => clk_1_sg_x315,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_4a1b074932
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x315,
      clk => clk_1_sg_x315,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_4e0f40d876: entity work.c_to_ri_entity_4bcfaa67a7
    port map (
      c => concat_y_net_x3,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_4bcfaa67a7: entity work.c_to_ri_entity_4bcfaa67a7
    port map (
      c => delay1_q_net_x1,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 14,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 14,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 14,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 14,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 14,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 14,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 14,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 14,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_b5dcdf3c4a: entity work.ri_to_c_entity_cd5a03d1c5
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x5
    );

  ri_to_c_cd5a03d1c5: entity work.ri_to_c_entity_cd5a03d1c5
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x4
    );

  shift0: entity work.scale_a1339d14c7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_a1339d14c7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_a1339d14c7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_a1339d14c7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_f3687289ea
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x315,
      clk => clk_1_sg_x315,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_f3687289ea
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x315,
      clk => clk_1_sg_x315,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/r4_butterfly/butterfly1"

entity butterfly1_entity_a874a48525 is
  port (
    a: in std_logic_vector(25 downto 0); 
    b: in std_logic_vector(25 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    a_b: out std_logic_vector(27 downto 0); 
    a_b_x0: out std_logic_vector(27 downto 0); 
    sync_out: out std_logic
  );
end butterfly1_entity_a874a48525;

architecture structural of butterfly1_entity_a874a48525 is
  signal add_im_s_net: std_logic_vector(13 downto 0);
  signal add_re_s_net: std_logic_vector(13 downto 0);
  signal ce_1_sg_x316: std_logic;
  signal clk_1_sg_x316: std_logic;
  signal concat_y_net_x4: std_logic_vector(25 downto 0);
  signal concat_y_net_x5: std_logic_vector(25 downto 0);
  signal concat_y_net_x6: std_logic_vector(27 downto 0);
  signal concat_y_net_x7: std_logic_vector(27 downto 0);
  signal delay_q_net_x1: std_logic;
  signal delay_q_net_x2: std_logic;
  signal force_im_output_port_net_x0: std_logic_vector(12 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(12 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(12 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(12 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(13 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(13 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(13 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(13 downto 0);
  signal shift0_op_net: std_logic_vector(13 downto 0);
  signal shift1_op_net: std_logic_vector(13 downto 0);
  signal shift2_op_net: std_logic_vector(13 downto 0);
  signal shift3_op_net: std_logic_vector(13 downto 0);
  signal sub_im_s_net: std_logic_vector(13 downto 0);
  signal sub_re_s_net: std_logic_vector(13 downto 0);

begin
  concat_y_net_x4 <= a;
  concat_y_net_x5 <= b;
  ce_1_sg_x316 <= ce_1;
  clk_1_sg_x316 <= clk_1;
  delay_q_net_x1 <= sync_in;
  a_b <= concat_y_net_x6;
  a_b_x0 <= concat_y_net_x7;
  sync_out <= delay_q_net_x2;

  add_im: entity work.addsub_4a1b074932
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x316,
      clk => clk_1_sg_x316,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_4a1b074932
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x316,
      clk => clk_1_sg_x316,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_6ba71ef04a: entity work.c_to_ri_entity_4bcfaa67a7
    port map (
      c => concat_y_net_x5,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_74a02c949d: entity work.c_to_ri_entity_4bcfaa67a7
    port map (
      c => concat_y_net_x4,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x316,
      clk => clk_1_sg_x316,
      d(0) => delay_q_net_x1,
      en => '1',
      q(0) => delay_q_net_x2
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 14,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 14,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 14,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 14,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 14,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 14,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 14,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 14,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_af04f0d72d: entity work.ri_to_c_entity_cd5a03d1c5
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x7
    );

  ri_to_c_8a85c9636d: entity work.ri_to_c_entity_cd5a03d1c5
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x6
    );

  shift0: entity work.scale_a1339d14c7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_a1339d14c7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_a1339d14c7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_a1339d14c7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_f3687289ea
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x316,
      clk => clk_1_sg_x316,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_f3687289ea
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x316,
      clk => clk_1_sg_x316,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/r4_butterfly/butterfly2/c_to_ri"

entity c_to_ri_entity_3b76d00990 is
  port (
    c: in std_logic_vector(27 downto 0); 
    im: out std_logic_vector(13 downto 0); 
    re: out std_logic_vector(13 downto 0)
  );
end c_to_ri_entity_3b76d00990;

architecture structural of c_to_ri_entity_3b76d00990 is
  signal concat_y_net_x5: std_logic_vector(27 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(13 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(13 downto 0);
  signal slice_im_y_net: std_logic_vector(13 downto 0);
  signal slice_re_y_net: std_logic_vector(13 downto 0);

begin
  concat_y_net_x5 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_445612bb74
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_445612bb74
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 13,
      x_width => 28,
      y_width => 14
    )
    port map (
      x => concat_y_net_x5,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 14,
      new_msb => 27,
      x_width => 28,
      y_width => 14
    )
    port map (
      x => concat_y_net_x5,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/r4_butterfly/butterfly2/ri_to_c"

entity ri_to_c_entity_0ba748958a is
  port (
    im: in std_logic_vector(14 downto 0); 
    re: in std_logic_vector(14 downto 0); 
    c: out std_logic_vector(29 downto 0)
  );
end ri_to_c_entity_0ba748958a;

architecture structural of ri_to_c_entity_0ba748958a is
  signal concat_y_net_x0: std_logic_vector(29 downto 0);
  signal force_im_output_port_net: std_logic_vector(14 downto 0);
  signal force_re_output_port_net: std_logic_vector(14 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(14 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(14 downto 0);

begin
  requant1_dout_net_x0 <= im;
  requant0_dout_net_x0 <= re;
  c <= concat_y_net_x0;

  concat: entity work.concat_22467883b2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x0
    );

  force_im: entity work.reinterpret_0d1490be80
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant1_dout_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_0d1490be80
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant0_dout_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/r4_butterfly/butterfly2"

entity butterfly2_entity_558f6ef896 is
  port (
    a: in std_logic_vector(27 downto 0); 
    b: in std_logic_vector(27 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    a_b: out std_logic_vector(29 downto 0); 
    a_b_x0: out std_logic_vector(29 downto 0)
  );
end butterfly2_entity_558f6ef896;

architecture structural of butterfly2_entity_558f6ef896 is
  signal add_im_s_net: std_logic_vector(14 downto 0);
  signal add_re_s_net: std_logic_vector(14 downto 0);
  signal ce_1_sg_x317: std_logic;
  signal clk_1_sg_x317: std_logic;
  signal concat_y_net_x10: std_logic_vector(27 downto 0);
  signal concat_y_net_x11: std_logic_vector(29 downto 0);
  signal concat_y_net_x12: std_logic_vector(29 downto 0);
  signal concat_y_net_x9: std_logic_vector(27 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(13 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(13 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(13 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(13 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(14 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(14 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(14 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(14 downto 0);
  signal shift0_op_net: std_logic_vector(14 downto 0);
  signal shift1_op_net: std_logic_vector(14 downto 0);
  signal shift2_op_net: std_logic_vector(14 downto 0);
  signal shift3_op_net: std_logic_vector(14 downto 0);
  signal sub_im_s_net: std_logic_vector(14 downto 0);
  signal sub_re_s_net: std_logic_vector(14 downto 0);

begin
  concat_y_net_x9 <= a;
  concat_y_net_x10 <= b;
  ce_1_sg_x317 <= ce_1;
  clk_1_sg_x317 <= clk_1;
  a_b <= concat_y_net_x11;
  a_b_x0 <= concat_y_net_x12;

  add_im: entity work.addsub_79dc8835bc
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x317,
      clk => clk_1_sg_x317,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_79dc8835bc
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x317,
      clk => clk_1_sg_x317,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_b517611461: entity work.c_to_ri_entity_3b76d00990
    port map (
      c => concat_y_net_x10,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_3b76d00990: entity work.c_to_ri_entity_3b76d00990
    port map (
      c => concat_y_net_x9,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 15,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 15,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 15,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 15,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 15,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 15,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 15,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 15,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_296b7ada4c: entity work.ri_to_c_entity_0ba748958a
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x12
    );

  ri_to_c_0ba748958a: entity work.ri_to_c_entity_0ba748958a
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x11
    );

  shift0: entity work.scale_11a6418200
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_11a6418200
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_11a6418200
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_11a6418200
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_f4e99698eb
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x317,
      clk => clk_1_sg_x317,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_f4e99698eb
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x317,
      clk => clk_1_sg_x317,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/r4_butterfly/butterfly3j"

entity butterfly3j_entity_ace26e8d1a is
  port (
    a: in std_logic_vector(27 downto 0); 
    b: in std_logic_vector(27 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    a_b: out std_logic_vector(29 downto 0); 
    a_b_x0: out std_logic_vector(29 downto 0); 
    sync_out: out std_logic
  );
end butterfly3j_entity_ace26e8d1a;

architecture structural of butterfly3j_entity_ace26e8d1a is
  signal add_im_s_net: std_logic_vector(14 downto 0);
  signal add_re_s_net: std_logic_vector(14 downto 0);
  signal ce_1_sg_x318: std_logic;
  signal clk_1_sg_x318: std_logic;
  signal concat_y_net_x10: std_logic_vector(29 downto 0);
  signal concat_y_net_x11: std_logic_vector(29 downto 0);
  signal concat_y_net_x7: std_logic_vector(27 downto 0);
  signal concat_y_net_x9: std_logic_vector(27 downto 0);
  signal delay_q_net_x0: std_logic;
  signal delay_q_net_x3: std_logic;
  signal force_im_output_port_net_x0: std_logic_vector(13 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(13 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(13 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(13 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(14 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(14 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(14 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(14 downto 0);
  signal shift0_op_net: std_logic_vector(14 downto 0);
  signal shift1_op_net: std_logic_vector(14 downto 0);
  signal shift2_op_net: std_logic_vector(14 downto 0);
  signal shift3_op_net: std_logic_vector(14 downto 0);
  signal sub_im_s_net: std_logic_vector(14 downto 0);
  signal sub_re_s_net: std_logic_vector(14 downto 0);

begin
  concat_y_net_x7 <= a;
  concat_y_net_x9 <= b;
  ce_1_sg_x318 <= ce_1;
  clk_1_sg_x318 <= clk_1;
  delay_q_net_x3 <= sync_in;
  a_b <= concat_y_net_x10;
  a_b_x0 <= concat_y_net_x11;
  sync_out <= delay_q_net_x0;

  add_im: entity work.addsub_f4e99698eb
    port map (
      a => force_im_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_79dc8835bc
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_17f2915afa: entity work.c_to_ri_entity_3b76d00990
    port map (
      c => concat_y_net_x9,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_f6f4dc6241: entity work.c_to_ri_entity_3b76d00990
    port map (
      c => concat_y_net_x7,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d(0) => delay_q_net_x3,
      en => '1',
      q(0) => delay_q_net_x0
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 15,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 15,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 15,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 15,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 15,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 15,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 15,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 15,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_4075506640: entity work.ri_to_c_entity_0ba748958a
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x11
    );

  ri_to_c_c22bcb0efd: entity work.ri_to_c_entity_0ba748958a
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x10
    );

  shift0: entity work.scale_11a6418200
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_11a6418200
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_11a6418200
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_11a6418200
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_79dc8835bc
    port map (
      a => force_im_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_f4e99698eb
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/r4_butterfly"

entity r4_butterfly_entity_da33117be2 is
  port (
    a_in: in std_logic_vector(25 downto 0); 
    b_in: in std_logic_vector(25 downto 0); 
    c_in: in std_logic_vector(25 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d_in: in std_logic_vector(25 downto 0); 
    sync_in: in std_logic; 
    a_out: out std_logic_vector(29 downto 0); 
    b_out: out std_logic_vector(29 downto 0); 
    c_out: out std_logic_vector(29 downto 0); 
    d_out: out std_logic_vector(29 downto 0); 
    sync_out: out std_logic
  );
end r4_butterfly_entity_da33117be2;

architecture structural of r4_butterfly_entity_da33117be2 is
  signal ce_1_sg_x319: std_logic;
  signal clk_1_sg_x319: std_logic;
  signal concat_y_net_x10: std_logic_vector(27 downto 0);
  signal concat_y_net_x11: std_logic_vector(27 downto 0);
  signal concat_y_net_x16: std_logic_vector(25 downto 0);
  signal concat_y_net_x17: std_logic_vector(25 downto 0);
  signal concat_y_net_x18: std_logic_vector(25 downto 0);
  signal concat_y_net_x19: std_logic_vector(29 downto 0);
  signal concat_y_net_x20: std_logic_vector(29 downto 0);
  signal concat_y_net_x21: std_logic_vector(29 downto 0);
  signal concat_y_net_x22: std_logic_vector(29 downto 0);
  signal concat_y_net_x7: std_logic_vector(27 downto 0);
  signal concat_y_net_x9: std_logic_vector(27 downto 0);
  signal delay1_q_net_x2: std_logic_vector(25 downto 0);
  signal delay_q_net_x2: std_logic;
  signal delay_q_net_x3: std_logic;
  signal delay_q_net_x4: std_logic;

begin
  delay1_q_net_x2 <= a_in;
  concat_y_net_x16 <= b_in;
  concat_y_net_x17 <= c_in;
  ce_1_sg_x319 <= ce_1;
  clk_1_sg_x319 <= clk_1;
  concat_y_net_x18 <= d_in;
  delay_q_net_x2 <= sync_in;
  a_out <= concat_y_net_x19;
  b_out <= concat_y_net_x20;
  c_out <= concat_y_net_x21;
  d_out <= concat_y_net_x22;
  sync_out <= delay_q_net_x4;

  butterfly0_7236742b6e: entity work.butterfly0_entity_7236742b6e
    port map (
      a => delay1_q_net_x2,
      b => concat_y_net_x17,
      ce_1 => ce_1_sg_x319,
      clk_1 => clk_1_sg_x319,
      a_b => concat_y_net_x9,
      a_b_x0 => concat_y_net_x7
    );

  butterfly1_a874a48525: entity work.butterfly1_entity_a874a48525
    port map (
      a => concat_y_net_x16,
      b => concat_y_net_x18,
      ce_1 => ce_1_sg_x319,
      clk_1 => clk_1_sg_x319,
      sync_in => delay_q_net_x2,
      a_b => concat_y_net_x10,
      a_b_x0 => concat_y_net_x11,
      sync_out => delay_q_net_x3
    );

  butterfly2_558f6ef896: entity work.butterfly2_entity_558f6ef896
    port map (
      a => concat_y_net_x9,
      b => concat_y_net_x10,
      ce_1 => ce_1_sg_x319,
      clk_1 => clk_1_sg_x319,
      a_b => concat_y_net_x19,
      a_b_x0 => concat_y_net_x20
    );

  butterfly3j_ace26e8d1a: entity work.butterfly3j_entity_ace26e8d1a
    port map (
      a => concat_y_net_x7,
      b => concat_y_net_x11,
      ce_1 => ce_1_sg_x319,
      clk_1 => clk_1_sg_x319,
      sync_in => delay_q_net_x3,
      a_b => concat_y_net_x21,
      a_b_x0 => concat_y_net_x22,
      sync_out => delay_q_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/r4_twiddle/cmpy1/c_to_ri"

entity c_to_ri_entity_a14e3a0825 is
  port (
    c: in std_logic_vector(25 downto 0); 
    im: out std_logic_vector(12 downto 0); 
    re: out std_logic_vector(12 downto 0)
  );
end c_to_ri_entity_a14e3a0825;

architecture structural of c_to_ri_entity_a14e3a0825 is
  signal delay1_q_net_x0: std_logic_vector(25 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(12 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(12 downto 0);
  signal slice_im_y_net: std_logic_vector(12 downto 0);
  signal slice_re_y_net: std_logic_vector(12 downto 0);

begin
  delay1_q_net_x0 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_33580846c4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_33580846c4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 12,
      x_width => 26,
      y_width => 13
    )
    port map (
      x => delay1_q_net_x0,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 13,
      new_msb => 25,
      x_width => 26,
      y_width => 13
    )
    port map (
      x => delay1_q_net_x0,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/r4_twiddle/cmpy1/ri_to_c"

entity ri_to_c_entity_ac37194b4a is
  port (
    im: in std_logic_vector(12 downto 0); 
    re: in std_logic_vector(12 downto 0); 
    c: out std_logic_vector(25 downto 0)
  );
end ri_to_c_entity_ac37194b4a;

architecture structural of ri_to_c_entity_ac37194b4a is
  signal concat_y_net_x17: std_logic_vector(25 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(12 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(12 downto 0);
  signal force_im_output_port_net: std_logic_vector(12 downto 0);
  signal force_re_output_port_net: std_logic_vector(12 downto 0);

begin
  convert_im_dout_net_x0 <= im;
  convert_re_dout_net_x0 <= re;
  c <= concat_y_net_x17;

  concat: entity work.concat_4720648850
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x17
    );

  force_im: entity work.reinterpret_18554b6b75
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert_im_dout_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_18554b6b75
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert_re_dout_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/r4_twiddle/cmpy1"

entity cmpy1_entity_807c125e96 is
  port (
    a_in: in std_logic_vector(25 downto 0); 
    b: in std_logic_vector(25 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    w: in std_logic_vector(17 downto 0); 
    a_out: out std_logic_vector(25 downto 0); 
    bw: out std_logic_vector(25 downto 0); 
    sync_out: out std_logic
  );
end cmpy1_entity_807c125e96;

architecture structural of cmpy1_entity_807c125e96 is
  signal br_add_bi_s_net: std_logic_vector(13 downto 0);
  signal ce_1_sg_x320: std_logic;
  signal clk_1_sg_x320: std_logic;
  signal concat_y_net_x18: std_logic_vector(25 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(12 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(12 downto 0);
  signal delay1_q_net_x1: std_logic_vector(25 downto 0);
  signal delay1_q_net_x3: std_logic_vector(25 downto 0);
  signal delay2_q_net_x0: std_logic_vector(25 downto 0);
  signal delay3_q_net_x0: std_logic;
  signal delay_q_net_x3: std_logic;
  signal force_im_output_port_net_x0: std_logic_vector(12 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(8 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(12 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(8 downto 0);
  signal imim_p_net: std_logic_vector(19 downto 0);
  signal mem_c_data_net_x1: std_logic_vector(17 downto 0);
  signal rere_p_net: std_logic_vector(19 downto 0);
  signal rr_add_ii_s_net: std_logic_vector(19 downto 0);
  signal rr_sub_ii_s_net: std_logic_vector(19 downto 0);
  signal ss_sub_rrii_s_net: std_logic_vector(19 downto 0);
  signal sumsum_p_net: std_logic_vector(19 downto 0);
  signal wr_add_wi_s_net: std_logic_vector(9 downto 0);

begin
  delay2_q_net_x0 <= a_in;
  delay1_q_net_x1 <= b;
  ce_1_sg_x320 <= ce_1;
  clk_1_sg_x320 <= clk_1;
  delay3_q_net_x0 <= sync_in;
  mem_c_data_net_x1 <= w;
  a_out <= delay1_q_net_x3;
  bw <= concat_y_net_x18;
  sync_out <= delay_q_net_x3;

  br_add_bi: entity work.addsub_c0d1d84d6b
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x0,
      ce => ce_1_sg_x320,
      clk => clk_1_sg_x320,
      clr => '0',
      s => br_add_bi_s_net
    );

  c_to_ri1_8bd9b60f8e: entity work.c_to_ri1_entity_7fe674c156
    port map (
      c => mem_c_data_net_x1,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_a14e3a0825: entity work.c_to_ri_entity_a14e3a0825
    port map (
      c => delay1_q_net_x1,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  convert_im: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 19,
      din_width => 20,
      dout_arith => 2,
      dout_bin_pt => 12,
      dout_width => 13,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x320,
      clk => clk_1_sg_x320,
      clr => '0',
      din => ss_sub_rrii_s_net,
      dout => convert_im_dout_net_x0
    );

  convert_re: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 19,
      din_width => 20,
      dout_arith => 2,
      dout_bin_pt => 12,
      dout_width => 13,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x320,
      clk => clk_1_sg_x320,
      clr => '0',
      din => rr_sub_ii_s_net,
      dout => convert_re_dout_net_x0
    );

  delay: entity work.xldelay
    generic map (
      latency => 8,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x320,
      clk => clk_1_sg_x320,
      d(0) => delay3_q_net_x0,
      en => '1',
      q(0) => delay_q_net_x3
    );

  delay1: entity work.xldelay
    generic map (
      latency => 8,
      reg_retiming => 0,
      width => 26
    )
    port map (
      ce => ce_1_sg_x320,
      clk => clk_1_sg_x320,
      d => delay2_q_net_x0,
      en => '1',
      q => delay1_q_net_x3
    );

  imim: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 12,
      a_width => 13,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 13,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 13,
      c_output_width => 22,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_845caa9bc89072e0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 19,
      p_width => 20,
      quantization => 1
    )
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x320,
      clk => clk_1_sg_x320,
      clr => '0',
      core_ce => ce_1_sg_x320,
      core_clk => clk_1_sg_x320,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => imim_p_net
    );

  rere: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 12,
      a_width => 13,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 13,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 13,
      c_output_width => 22,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_845caa9bc89072e0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 19,
      p_width => 20,
      quantization => 1
    )
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x320,
      clk => clk_1_sg_x320,
      clr => '0',
      core_ce => ce_1_sg_x320,
      core_clk => clk_1_sg_x320,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => rere_p_net
    );

  ri_to_c_ac37194b4a: entity work.ri_to_c_entity_ac37194b4a
    port map (
      im => convert_im_dout_net_x0,
      re => convert_re_dout_net_x0,
      c => concat_y_net_x18
    );

  rr_add_ii: entity work.addsub_a9cdc93774
    port map (
      a => imim_p_net,
      b => rere_p_net,
      ce => ce_1_sg_x320,
      clk => clk_1_sg_x320,
      clr => '0',
      s => rr_add_ii_s_net
    );

  rr_sub_ii: entity work.addsub_370c0f2c47
    port map (
      a => rere_p_net,
      b => imim_p_net,
      ce => ce_1_sg_x320,
      clk => clk_1_sg_x320,
      clr => '0',
      s => rr_sub_ii_s_net
    );

  ss_sub_rrii: entity work.addsub_5777994232
    port map (
      a => sumsum_p_net,
      b => rr_add_ii_s_net,
      ce => ce_1_sg_x320,
      clk => clk_1_sg_x320,
      clr => '0',
      s => ss_sub_rrii_s_net
    );

  sumsum: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 12,
      a_width => 14,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 10,
      c_a_type => 0,
      c_a_width => 14,
      c_b_type => 0,
      c_b_width => 10,
      c_baat => 14,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_35568d5aa6a70475",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 19,
      p_width => 20,
      quantization => 1
    )
    port map (
      a => br_add_bi_s_net,
      b => wr_add_wi_s_net,
      ce => ce_1_sg_x320,
      clk => clk_1_sg_x320,
      clr => '0',
      core_ce => ce_1_sg_x320,
      core_clk => clk_1_sg_x320,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => sumsum_p_net
    );

  wr_add_wi: entity work.addsub_bd2bd198b1
    port map (
      a => force_re_output_port_net_x1,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x320,
      clk => clk_1_sg_x320,
      clr => '0',
      s => wr_add_wi_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/r4_twiddle/cmpy2"

entity cmpy2_entity_d3cec8edee is
  port (
    b: in std_logic_vector(25 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    w: in std_logic_vector(17 downto 0); 
    bw: out std_logic_vector(25 downto 0)
  );
end cmpy2_entity_d3cec8edee;

architecture structural of cmpy2_entity_d3cec8edee is
  signal br_add_bi_s_net: std_logic_vector(13 downto 0);
  signal ce_1_sg_x321: std_logic;
  signal clk_1_sg_x321: std_logic;
  signal concat_y_net_x19: std_logic_vector(25 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(12 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(12 downto 0);
  signal delay4_q_net_x1: std_logic_vector(25 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(12 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(8 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(12 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(8 downto 0);
  signal imim_p_net: std_logic_vector(19 downto 0);
  signal mem_c_data_net_x1: std_logic_vector(17 downto 0);
  signal rere_p_net: std_logic_vector(19 downto 0);
  signal rr_add_ii_s_net: std_logic_vector(19 downto 0);
  signal rr_sub_ii_s_net: std_logic_vector(19 downto 0);
  signal ss_sub_rrii_s_net: std_logic_vector(19 downto 0);
  signal sumsum_p_net: std_logic_vector(19 downto 0);
  signal wr_add_wi_s_net: std_logic_vector(9 downto 0);

begin
  delay4_q_net_x1 <= b;
  ce_1_sg_x321 <= ce_1;
  clk_1_sg_x321 <= clk_1;
  mem_c_data_net_x1 <= w;
  bw <= concat_y_net_x19;

  br_add_bi: entity work.addsub_c0d1d84d6b
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x0,
      ce => ce_1_sg_x321,
      clk => clk_1_sg_x321,
      clr => '0',
      s => br_add_bi_s_net
    );

  c_to_ri1_e55107a511: entity work.c_to_ri1_entity_7fe674c156
    port map (
      c => mem_c_data_net_x1,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_dfc977c563: entity work.c_to_ri_entity_a14e3a0825
    port map (
      c => delay4_q_net_x1,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  convert_im: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 19,
      din_width => 20,
      dout_arith => 2,
      dout_bin_pt => 12,
      dout_width => 13,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x321,
      clk => clk_1_sg_x321,
      clr => '0',
      din => ss_sub_rrii_s_net,
      dout => convert_im_dout_net_x0
    );

  convert_re: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 19,
      din_width => 20,
      dout_arith => 2,
      dout_bin_pt => 12,
      dout_width => 13,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x321,
      clk => clk_1_sg_x321,
      clr => '0',
      din => rr_sub_ii_s_net,
      dout => convert_re_dout_net_x0
    );

  imim: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 12,
      a_width => 13,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 13,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 13,
      c_output_width => 22,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_845caa9bc89072e0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 19,
      p_width => 20,
      quantization => 1
    )
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x321,
      clk => clk_1_sg_x321,
      clr => '0',
      core_ce => ce_1_sg_x321,
      core_clk => clk_1_sg_x321,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => imim_p_net
    );

  rere: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 12,
      a_width => 13,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 13,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 13,
      c_output_width => 22,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_845caa9bc89072e0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 19,
      p_width => 20,
      quantization => 1
    )
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x321,
      clk => clk_1_sg_x321,
      clr => '0',
      core_ce => ce_1_sg_x321,
      core_clk => clk_1_sg_x321,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => rere_p_net
    );

  ri_to_c_4a2aa3e5f4: entity work.ri_to_c_entity_ac37194b4a
    port map (
      im => convert_im_dout_net_x0,
      re => convert_re_dout_net_x0,
      c => concat_y_net_x19
    );

  rr_add_ii: entity work.addsub_a9cdc93774
    port map (
      a => imim_p_net,
      b => rere_p_net,
      ce => ce_1_sg_x321,
      clk => clk_1_sg_x321,
      clr => '0',
      s => rr_add_ii_s_net
    );

  rr_sub_ii: entity work.addsub_370c0f2c47
    port map (
      a => rere_p_net,
      b => imim_p_net,
      ce => ce_1_sg_x321,
      clk => clk_1_sg_x321,
      clr => '0',
      s => rr_sub_ii_s_net
    );

  ss_sub_rrii: entity work.addsub_5777994232
    port map (
      a => sumsum_p_net,
      b => rr_add_ii_s_net,
      ce => ce_1_sg_x321,
      clk => clk_1_sg_x321,
      clr => '0',
      s => ss_sub_rrii_s_net
    );

  sumsum: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 12,
      a_width => 14,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 10,
      c_a_type => 0,
      c_a_width => 14,
      c_b_type => 0,
      c_b_width => 10,
      c_baat => 14,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_35568d5aa6a70475",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 19,
      p_width => 20,
      quantization => 1
    )
    port map (
      a => br_add_bi_s_net,
      b => wr_add_wi_s_net,
      ce => ce_1_sg_x321,
      clk => clk_1_sg_x321,
      clr => '0',
      core_ce => ce_1_sg_x321,
      core_clk => clk_1_sg_x321,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => sumsum_p_net
    );

  wr_add_wi: entity work.addsub_bd2bd198b1
    port map (
      a => force_re_output_port_net_x1,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x321,
      clk => clk_1_sg_x321,
      clr => '0',
      s => wr_add_wi_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/r4_twiddle/twiddle_gen1"

entity twiddle_gen1_entity_d8b97c5223 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    w: out std_logic_vector(17 downto 0)
  );
end twiddle_gen1_entity_d8b97c5223;

architecture structural of twiddle_gen1_entity_d8b97c5223 is
  signal addr_sel_y_net: std_logic_vector(3 downto 0);
  signal ce_1_sg_x323: std_logic;
  signal clk_1_sg_x323: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay_q_net_x13: std_logic;
  signal mem_c_data_net_x2: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x323 <= ce_1;
  clk_1_sg_x323 <= clk_1;
  delay_q_net_x13 <= sync_in;
  w <= mem_c_data_net_x2;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 7,
      x_width => 8,
      y_width => 4
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_01e34ae12479a5e1",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x323,
      clk => clk_1_sg_x323,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x13,
      op => counter_op_net
    );

  mem_c: entity work.xlsprom_dist
    generic map (
      addr_width => 4,
      c_address_width => 4,
      c_width => 18,
      core_name0 => "dmg_33_vx5_efe4f2e28a6a56b5",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x323,
      clk => clk_1_sg_x323,
      en => "1",
      data => mem_c_data_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/r4_twiddle/twiddle_gen2"

entity twiddle_gen2_entity_aab55de34e is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    w: out std_logic_vector(17 downto 0)
  );
end twiddle_gen2_entity_aab55de34e;

architecture structural of twiddle_gen2_entity_aab55de34e is
  signal addr_sel_y_net: std_logic_vector(3 downto 0);
  signal ce_1_sg_x324: std_logic;
  signal clk_1_sg_x324: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay_q_net_x14: std_logic;
  signal mem_c_data_net_x2: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x324 <= ce_1;
  clk_1_sg_x324 <= clk_1;
  delay_q_net_x14 <= sync_in;
  w <= mem_c_data_net_x2;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 7,
      x_width => 8,
      y_width => 4
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_01e34ae12479a5e1",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x324,
      clk => clk_1_sg_x324,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x14,
      op => counter_op_net
    );

  mem_c: entity work.xlsprom_dist
    generic map (
      addr_width => 4,
      c_address_width => 4,
      c_width => 18,
      core_name0 => "dmg_33_vx5_47bf930170fd8e60",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x324,
      clk => clk_1_sg_x324,
      en => "1",
      data => mem_c_data_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/r4_twiddle/twiddle_gen3"

entity twiddle_gen3_entity_3562354dc2 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    w: out std_logic_vector(17 downto 0)
  );
end twiddle_gen3_entity_3562354dc2;

architecture structural of twiddle_gen3_entity_3562354dc2 is
  signal addr_sel_y_net: std_logic_vector(3 downto 0);
  signal ce_1_sg_x325: std_logic;
  signal clk_1_sg_x325: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay_q_net_x15: std_logic;
  signal mem_c_data_net_x2: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x325 <= ce_1;
  clk_1_sg_x325 <= clk_1;
  delay_q_net_x15 <= sync_in;
  w <= mem_c_data_net_x2;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 4,
      new_msb => 7,
      x_width => 8,
      y_width => 4
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_01e34ae12479a5e1",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x325,
      clk => clk_1_sg_x325,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x15,
      op => counter_op_net
    );

  mem_c: entity work.xlsprom_dist
    generic map (
      addr_width => 4,
      c_address_width => 4,
      c_width => 18,
      core_name0 => "dmg_33_vx5_27954da46fb8f5d8",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x325,
      clk => clk_1_sg_x325,
      en => "1",
      data => mem_c_data_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3/r4_twiddle"

entity r4_twiddle_entity_3751d89af1 is
  port (
    a_in: in std_logic_vector(25 downto 0); 
    b: in std_logic_vector(25 downto 0); 
    c: in std_logic_vector(25 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(25 downto 0); 
    sync_in: in std_logic; 
    a_out: out std_logic_vector(25 downto 0); 
    bw: out std_logic_vector(25 downto 0); 
    cw: out std_logic_vector(25 downto 0); 
    dw: out std_logic_vector(25 downto 0); 
    sync_out: out std_logic
  );
end r4_twiddle_entity_3751d89af1;

architecture structural of r4_twiddle_entity_3751d89af1 is
  signal ce_1_sg_x326: std_logic;
  signal clk_1_sg_x326: std_logic;
  signal concat_y_net_x21: std_logic_vector(25 downto 0);
  signal concat_y_net_x22: std_logic_vector(25 downto 0);
  signal concat_y_net_x23: std_logic_vector(25 downto 0);
  signal delay1_q_net_x1: std_logic_vector(25 downto 0);
  signal delay1_q_net_x4: std_logic_vector(25 downto 0);
  signal delay2_q_net_x0: std_logic_vector(25 downto 0);
  signal delay3_q_net_x0: std_logic;
  signal delay4_q_net_x1: std_logic_vector(25 downto 0);
  signal delay5_q_net_x1: std_logic_vector(25 downto 0);
  signal delay_q_net_x16: std_logic;
  signal delay_q_net_x4: std_logic;
  signal mem_c_data_net_x2: std_logic_vector(17 downto 0);
  signal mem_c_data_net_x3: std_logic_vector(17 downto 0);
  signal mem_c_data_net_x4: std_logic_vector(17 downto 0);
  signal mux1_y_net_x8: std_logic_vector(25 downto 0);
  signal mux1_y_net_x9: std_logic_vector(25 downto 0);
  signal slr_q_net_x10: std_logic_vector(25 downto 0);
  signal slr_q_net_x11: std_logic_vector(25 downto 0);

begin
  slr_q_net_x10 <= a_in;
  mux1_y_net_x8 <= b;
  slr_q_net_x11 <= c;
  ce_1_sg_x326 <= ce_1;
  clk_1_sg_x326 <= clk_1;
  mux1_y_net_x9 <= d;
  delay_q_net_x16 <= sync_in;
  a_out <= delay1_q_net_x4;
  bw <= concat_y_net_x21;
  cw <= concat_y_net_x22;
  dw <= concat_y_net_x23;
  sync_out <= delay_q_net_x4;

  cmpy1_807c125e96: entity work.cmpy1_entity_807c125e96
    port map (
      a_in => delay2_q_net_x0,
      b => delay1_q_net_x1,
      ce_1 => ce_1_sg_x326,
      clk_1 => clk_1_sg_x326,
      sync_in => delay3_q_net_x0,
      w => mem_c_data_net_x2,
      a_out => delay1_q_net_x4,
      bw => concat_y_net_x21,
      sync_out => delay_q_net_x4
    );

  cmpy2_d3cec8edee: entity work.cmpy2_entity_d3cec8edee
    port map (
      b => delay4_q_net_x1,
      ce_1 => ce_1_sg_x326,
      clk_1 => clk_1_sg_x326,
      w => mem_c_data_net_x3,
      bw => concat_y_net_x22
    );

  cmpy3_937c7924be: entity work.cmpy2_entity_d3cec8edee
    port map (
      b => delay5_q_net_x1,
      ce_1 => ce_1_sg_x326,
      clk_1 => clk_1_sg_x326,
      w => mem_c_data_net_x4,
      bw => concat_y_net_x23
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 26
    )
    port map (
      ce => ce_1_sg_x326,
      clk => clk_1_sg_x326,
      d => mux1_y_net_x8,
      en => '1',
      q => delay1_q_net_x1
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 26
    )
    port map (
      ce => ce_1_sg_x326,
      clk => clk_1_sg_x326,
      d => slr_q_net_x10,
      en => '1',
      q => delay2_q_net_x0
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x326,
      clk => clk_1_sg_x326,
      d(0) => delay_q_net_x16,
      en => '1',
      q(0) => delay3_q_net_x0
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 26
    )
    port map (
      ce => ce_1_sg_x326,
      clk => clk_1_sg_x326,
      d => slr_q_net_x11,
      en => '1',
      q => delay4_q_net_x1
    );

  delay5: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 26
    )
    port map (
      ce => ce_1_sg_x326,
      clk => clk_1_sg_x326,
      d => mux1_y_net_x9,
      en => '1',
      q => delay5_q_net_x1
    );

  twiddle_gen1_d8b97c5223: entity work.twiddle_gen1_entity_d8b97c5223
    port map (
      ce_1 => ce_1_sg_x326,
      clk_1 => clk_1_sg_x326,
      sync_in => delay_q_net_x16,
      w => mem_c_data_net_x2
    );

  twiddle_gen2_aab55de34e: entity work.twiddle_gen2_entity_aab55de34e
    port map (
      ce_1 => ce_1_sg_x326,
      clk_1 => clk_1_sg_x326,
      sync_in => delay_q_net_x16,
      w => mem_c_data_net_x3
    );

  twiddle_gen3_3562354dc2: entity work.twiddle_gen3_entity_3562354dc2
    port map (
      ce_1 => ce_1_sg_x326,
      clk_1 => clk_1_sg_x326,
      sync_in => delay_q_net_x16,
      w => mem_c_data_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_3"

entity r4_dit_stage_3_entity_2e339e97dd is
  port (
    a_in: in std_logic_vector(25 downto 0); 
    b_in: in std_logic_vector(25 downto 0); 
    c_in: in std_logic_vector(25 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d_in: in std_logic_vector(25 downto 0); 
    sync_in: in std_logic; 
    a_out: out std_logic_vector(29 downto 0); 
    b_out: out std_logic_vector(29 downto 0); 
    c_out: out std_logic_vector(29 downto 0); 
    d_out: out std_logic_vector(29 downto 0); 
    sync_out: out std_logic
  );
end r4_dit_stage_3_entity_2e339e97dd;

architecture structural of r4_dit_stage_3_entity_2e339e97dd is
  signal ce_1_sg_x327: std_logic;
  signal clk_1_sg_x327: std_logic;
  signal concat_y_net_x23: std_logic_vector(25 downto 0);
  signal concat_y_net_x24: std_logic_vector(25 downto 0);
  signal concat_y_net_x25: std_logic_vector(25 downto 0);
  signal concat_y_net_x48: std_logic_vector(25 downto 0);
  signal concat_y_net_x49: std_logic_vector(25 downto 0);
  signal concat_y_net_x50: std_logic_vector(25 downto 0);
  signal concat_y_net_x51: std_logic_vector(25 downto 0);
  signal concat_y_net_x52: std_logic_vector(29 downto 0);
  signal concat_y_net_x53: std_logic_vector(29 downto 0);
  signal concat_y_net_x54: std_logic_vector(29 downto 0);
  signal concat_y_net_x55: std_logic_vector(29 downto 0);
  signal delay1_q_net_x4: std_logic_vector(25 downto 0);
  signal delay_q_net_x12: std_logic;
  signal delay_q_net_x13: std_logic;
  signal delay_q_net_x14: std_logic;
  signal delay_q_net_x16: std_logic;
  signal mux1_y_net_x8: std_logic_vector(25 downto 0);
  signal mux1_y_net_x9: std_logic_vector(25 downto 0);
  signal slr_q_net_x10: std_logic_vector(25 downto 0);
  signal slr_q_net_x11: std_logic_vector(25 downto 0);

begin
  concat_y_net_x48 <= a_in;
  concat_y_net_x49 <= b_in;
  concat_y_net_x50 <= c_in;
  ce_1_sg_x327 <= ce_1;
  clk_1_sg_x327 <= clk_1;
  concat_y_net_x51 <= d_in;
  delay_q_net_x13 <= sync_in;
  a_out <= concat_y_net_x52;
  b_out <= concat_y_net_x53;
  c_out <= concat_y_net_x54;
  d_out <= concat_y_net_x55;
  sync_out <= delay_q_net_x14;

  quadplex_commutator_5766cb42d0: entity work.quadplex_commutator_entity_5766cb42d0
    port map (
      a => concat_y_net_x48,
      b => concat_y_net_x49,
      c => concat_y_net_x50,
      ce_1 => ce_1_sg_x327,
      clk_1 => clk_1_sg_x327,
      d => concat_y_net_x51,
      sync_in => delay_q_net_x13,
      abcd0 => slr_q_net_x10,
      abcd1 => mux1_y_net_x8,
      abcd2 => slr_q_net_x11,
      abcd3 => mux1_y_net_x9,
      sync_out => delay_q_net_x16
    );

  r4_butterfly_da33117be2: entity work.r4_butterfly_entity_da33117be2
    port map (
      a_in => delay1_q_net_x4,
      b_in => concat_y_net_x23,
      c_in => concat_y_net_x24,
      ce_1 => ce_1_sg_x327,
      clk_1 => clk_1_sg_x327,
      d_in => concat_y_net_x25,
      sync_in => delay_q_net_x12,
      a_out => concat_y_net_x52,
      b_out => concat_y_net_x53,
      c_out => concat_y_net_x54,
      d_out => concat_y_net_x55,
      sync_out => delay_q_net_x14
    );

  r4_twiddle_3751d89af1: entity work.r4_twiddle_entity_3751d89af1
    port map (
      a_in => slr_q_net_x10,
      b => mux1_y_net_x8,
      c => slr_q_net_x11,
      ce_1 => ce_1_sg_x327,
      clk_1 => clk_1_sg_x327,
      d => mux1_y_net_x9,
      sync_in => delay_q_net_x16,
      a_out => delay1_q_net_x4,
      bw => concat_y_net_x23,
      cw => concat_y_net_x24,
      dw => concat_y_net_x25,
      sync_out => delay_q_net_x12
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/quadplex_commutator/biplex_commutator_01/delay_b"

entity delay_b_entity_8bec184937 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(29 downto 0); 
    out_x0: out std_logic_vector(29 downto 0)
  );
end delay_b_entity_8bec184937;

architecture structural of delay_b_entity_8bec184937 is
  signal ce_1_sg_x328: std_logic;
  signal clk_1_sg_x328: std_logic;
  signal slr_q_net_x1: std_logic_vector(29 downto 0);
  signal slr_q_net_x2: std_logic_vector(29 downto 0);

begin
  ce_1_sg_x328 <= ce_1;
  clk_1_sg_x328 <= clk_1;
  slr_q_net_x1 <= in_x0;
  out_x0 <= slr_q_net_x2;

  slr: entity work.xldelay
    generic map (
      latency => 4,
      reg_retiming => 0,
      width => 30
    )
    port map (
      ce => ce_1_sg_x328,
      clk => clk_1_sg_x328,
      d => slr_q_net_x1,
      en => '1',
      q => slr_q_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/quadplex_commutator/biplex_commutator_01"

entity biplex_commutator_01_entity_eaac85949c is
  port (
    aloahi: in std_logic_vector(29 downto 0); 
    blobhi: in std_logic_vector(29 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(29 downto 0); 
    aloblo: out std_logic_vector(29 downto 0)
  );
end biplex_commutator_01_entity_eaac85949c;

architecture structural of biplex_commutator_01_entity_eaac85949c is
  signal ce_1_sg_x330: std_logic;
  signal clk_1_sg_x330: std_logic;
  signal counter_op_net: std_logic_vector(2 downto 0);
  signal delay_q_net_x0: std_logic;
  signal mux1_y_net_x0: std_logic_vector(29 downto 0);
  signal mux_y_net_x0: std_logic_vector(29 downto 0);
  signal slr_q_net_x2: std_logic_vector(29 downto 0);
  signal slr_q_net_x3: std_logic_vector(29 downto 0);
  signal slr_q_net_x4: std_logic_vector(29 downto 0);
  signal slr_q_net_x5: std_logic_vector(29 downto 0);
  signal top_bit_y_net: std_logic;

begin
  slr_q_net_x3 <= aloahi;
  slr_q_net_x4 <= blobhi;
  ce_1_sg_x330 <= ce_1;
  clk_1_sg_x330 <= clk_1;
  delay_q_net_x0 <= sync_in;
  ahibhi <= mux1_y_net_x0;
  aloblo <= slr_q_net_x5;

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_924a7f7132ea4004",
      op_arith => xlUnsigned,
      op_width => 3
    )
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x0,
      op => counter_op_net
    );

  delay_b_8bec184937: entity work.delay_b_entity_8bec184937
    port map (
      ce_1 => ce_1_sg_x330,
      clk_1 => clk_1_sg_x330,
      in_x0 => slr_q_net_x4,
      out_x0 => slr_q_net_x2
    );

  delay_lo_54c5874a47: entity work.delay_b_entity_8bec184937
    port map (
      ce_1 => ce_1_sg_x330,
      clk_1 => clk_1_sg_x330,
      in_x0 => mux_y_net_x0,
      out_x0 => slr_q_net_x5
    );

  mux: entity work.mux_458eaa1690
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      clr => '0',
      d0 => slr_q_net_x3,
      d1 => slr_q_net_x2,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x0
    );

  mux1: entity work.mux_458eaa1690
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      clr => '0',
      d0 => slr_q_net_x2,
      d1 => slr_q_net_x3,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x0
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 3,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/quadplex_commutator/biplex_commutator_23"

entity biplex_commutator_23_entity_fff0f794e5 is
  port (
    aloahi: in std_logic_vector(29 downto 0); 
    blobhi: in std_logic_vector(29 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(29 downto 0); 
    aloblo: out std_logic_vector(29 downto 0); 
    sync_out: out std_logic
  );
end biplex_commutator_23_entity_fff0f794e5;

architecture structural of biplex_commutator_23_entity_fff0f794e5 is
  signal ce_1_sg_x333: std_logic;
  signal clk_1_sg_x333: std_logic;
  signal counter_op_net: std_logic_vector(2 downto 0);
  signal delay_q_net_x1: std_logic;
  signal delay_q_net_x2: std_logic;
  signal mux1_y_net_x2: std_logic_vector(29 downto 0);
  signal mux1_y_net_x3: std_logic_vector(29 downto 0);
  signal mux1_y_net_x4: std_logic_vector(29 downto 0);
  signal mux_y_net_x0: std_logic_vector(29 downto 0);
  signal slr_q_net_x0: std_logic_vector(29 downto 0);
  signal slr_q_net_x2: std_logic_vector(29 downto 0);
  signal top_bit_y_net: std_logic;

begin
  mux1_y_net_x2 <= aloahi;
  mux1_y_net_x3 <= blobhi;
  ce_1_sg_x333 <= ce_1;
  clk_1_sg_x333 <= clk_1;
  delay_q_net_x1 <= sync_in;
  ahibhi <= mux1_y_net_x4;
  aloblo <= slr_q_net_x2;
  sync_out <= delay_q_net_x2;

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_924a7f7132ea4004",
      op_arith => xlUnsigned,
      op_width => 3
    )
    port map (
      ce => ce_1_sg_x333,
      clk => clk_1_sg_x333,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x1,
      op => counter_op_net
    );

  delay: entity work.xldelay
    generic map (
      latency => 5,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x333,
      clk => clk_1_sg_x333,
      d(0) => delay_q_net_x1,
      en => '1',
      q(0) => delay_q_net_x2
    );

  delay_b_85a05e2346: entity work.delay_b_entity_8bec184937
    port map (
      ce_1 => ce_1_sg_x333,
      clk_1 => clk_1_sg_x333,
      in_x0 => mux1_y_net_x3,
      out_x0 => slr_q_net_x0
    );

  delay_lo_4bf2fad737: entity work.delay_b_entity_8bec184937
    port map (
      ce_1 => ce_1_sg_x333,
      clk_1 => clk_1_sg_x333,
      in_x0 => mux_y_net_x0,
      out_x0 => slr_q_net_x2
    );

  mux: entity work.mux_458eaa1690
    port map (
      ce => ce_1_sg_x333,
      clk => clk_1_sg_x333,
      clr => '0',
      d0 => mux1_y_net_x2,
      d1 => slr_q_net_x0,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x0
    );

  mux1: entity work.mux_458eaa1690
    port map (
      ce => ce_1_sg_x333,
      clk => clk_1_sg_x333,
      clr => '0',
      d0 => slr_q_net_x0,
      d1 => mux1_y_net_x2,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x4
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 3,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/quadplex_commutator/biplex_commutator_ac/delay_b"

entity delay_b_entity_9f9ce9fb0d is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(29 downto 0); 
    out_x0: out std_logic_vector(29 downto 0)
  );
end delay_b_entity_9f9ce9fb0d;

architecture structural of delay_b_entity_9f9ce9fb0d is
  signal ce_1_sg_x334: std_logic;
  signal clk_1_sg_x334: std_logic;
  signal concat_y_net_x55: std_logic_vector(29 downto 0);
  signal slr_q_net_x0: std_logic_vector(29 downto 0);

begin
  ce_1_sg_x334 <= ce_1;
  clk_1_sg_x334 <= clk_1;
  concat_y_net_x55 <= in_x0;
  out_x0 <= slr_q_net_x0;

  slr: entity work.xldelay
    generic map (
      latency => 8,
      reg_retiming => 0,
      width => 30
    )
    port map (
      ce => ce_1_sg_x334,
      clk => clk_1_sg_x334,
      d => concat_y_net_x55,
      en => '1',
      q => slr_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/quadplex_commutator/biplex_commutator_ac"

entity biplex_commutator_ac_entity_be619e3591 is
  port (
    aloahi: in std_logic_vector(29 downto 0); 
    blobhi: in std_logic_vector(29 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(29 downto 0); 
    aloblo: out std_logic_vector(29 downto 0); 
    sync_out: out std_logic
  );
end biplex_commutator_ac_entity_be619e3591;

architecture structural of biplex_commutator_ac_entity_be619e3591 is
  signal ce_1_sg_x336: std_logic;
  signal clk_1_sg_x336: std_logic;
  signal concat_y_net_x56: std_logic_vector(29 downto 0);
  signal concat_y_net_x57: std_logic_vector(29 downto 0);
  signal counter_op_net: std_logic_vector(3 downto 0);
  signal delay_q_net_x15: std_logic;
  signal delay_q_net_x16: std_logic;
  signal mux1_y_net_x3: std_logic_vector(29 downto 0);
  signal mux_y_net_x0: std_logic_vector(29 downto 0);
  signal slr_q_net_x0: std_logic_vector(29 downto 0);
  signal slr_q_net_x5: std_logic_vector(29 downto 0);
  signal top_bit_y_net: std_logic;

begin
  concat_y_net_x56 <= aloahi;
  concat_y_net_x57 <= blobhi;
  ce_1_sg_x336 <= ce_1;
  clk_1_sg_x336 <= clk_1;
  delay_q_net_x15 <= sync_in;
  ahibhi <= mux1_y_net_x3;
  aloblo <= slr_q_net_x5;
  sync_out <= delay_q_net_x16;

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_833a35886d0c544c",
      op_arith => xlUnsigned,
      op_width => 4
    )
    port map (
      ce => ce_1_sg_x336,
      clk => clk_1_sg_x336,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x15,
      op => counter_op_net
    );

  delay: entity work.xldelay
    generic map (
      latency => 9,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x336,
      clk => clk_1_sg_x336,
      d(0) => delay_q_net_x15,
      en => '1',
      q(0) => delay_q_net_x16
    );

  delay_b_9f9ce9fb0d: entity work.delay_b_entity_9f9ce9fb0d
    port map (
      ce_1 => ce_1_sg_x336,
      clk_1 => clk_1_sg_x336,
      in_x0 => concat_y_net_x57,
      out_x0 => slr_q_net_x0
    );

  delay_lo_a4075e5827: entity work.delay_b_entity_9f9ce9fb0d
    port map (
      ce_1 => ce_1_sg_x336,
      clk_1 => clk_1_sg_x336,
      in_x0 => mux_y_net_x0,
      out_x0 => slr_q_net_x5
    );

  mux: entity work.mux_458eaa1690
    port map (
      ce => ce_1_sg_x336,
      clk => clk_1_sg_x336,
      clr => '0',
      d0 => concat_y_net_x56,
      d1 => slr_q_net_x0,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x0
    );

  mux1: entity work.mux_458eaa1690
    port map (
      ce => ce_1_sg_x336,
      clk => clk_1_sg_x336,
      clr => '0',
      d0 => slr_q_net_x0,
      d1 => concat_y_net_x56,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x3
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 3,
      new_msb => 3,
      x_width => 4,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/quadplex_commutator"

entity quadplex_commutator_entity_e1467df2f4 is
  port (
    a: in std_logic_vector(29 downto 0); 
    b: in std_logic_vector(29 downto 0); 
    c: in std_logic_vector(29 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(29 downto 0); 
    sync_in: in std_logic; 
    abcd0: out std_logic_vector(29 downto 0); 
    abcd1: out std_logic_vector(29 downto 0); 
    abcd2: out std_logic_vector(29 downto 0); 
    abcd3: out std_logic_vector(29 downto 0); 
    sync_out: out std_logic
  );
end quadplex_commutator_entity_e1467df2f4;

architecture structural of quadplex_commutator_entity_e1467df2f4 is
  signal ce_1_sg_x340: std_logic;
  signal clk_1_sg_x340: std_logic;
  signal concat_y_net_x60: std_logic_vector(29 downto 0);
  signal concat_y_net_x61: std_logic_vector(29 downto 0);
  signal concat_y_net_x62: std_logic_vector(29 downto 0);
  signal concat_y_net_x63: std_logic_vector(29 downto 0);
  signal delay_q_net_x17: std_logic;
  signal delay_q_net_x18: std_logic;
  signal delay_q_net_x19: std_logic;
  signal delay_q_net_x20: std_logic;
  signal mux1_y_net_x3: std_logic_vector(29 downto 0);
  signal mux1_y_net_x5: std_logic_vector(29 downto 0);
  signal mux1_y_net_x6: std_logic_vector(29 downto 0);
  signal mux1_y_net_x7: std_logic_vector(29 downto 0);
  signal slr_q_net_x6: std_logic_vector(29 downto 0);
  signal slr_q_net_x7: std_logic_vector(29 downto 0);
  signal slr_q_net_x8: std_logic_vector(29 downto 0);
  signal slr_q_net_x9: std_logic_vector(29 downto 0);

begin
  concat_y_net_x60 <= a;
  concat_y_net_x61 <= b;
  concat_y_net_x62 <= c;
  ce_1_sg_x340 <= ce_1;
  clk_1_sg_x340 <= clk_1;
  concat_y_net_x63 <= d;
  delay_q_net_x19 <= sync_in;
  abcd0 <= slr_q_net_x8;
  abcd1 <= mux1_y_net_x6;
  abcd2 <= slr_q_net_x9;
  abcd3 <= mux1_y_net_x7;
  sync_out <= delay_q_net_x20;

  biplex_commutator_01_eaac85949c: entity work.biplex_commutator_01_entity_eaac85949c
    port map (
      aloahi => slr_q_net_x6,
      blobhi => slr_q_net_x7,
      ce_1 => ce_1_sg_x340,
      clk_1 => clk_1_sg_x340,
      sync_in => delay_q_net_x17,
      ahibhi => mux1_y_net_x6,
      aloblo => slr_q_net_x8
    );

  biplex_commutator_23_fff0f794e5: entity work.biplex_commutator_23_entity_fff0f794e5
    port map (
      aloahi => mux1_y_net_x3,
      blobhi => mux1_y_net_x5,
      ce_1 => ce_1_sg_x340,
      clk_1 => clk_1_sg_x340,
      sync_in => delay_q_net_x18,
      ahibhi => mux1_y_net_x7,
      aloblo => slr_q_net_x9,
      sync_out => delay_q_net_x20
    );

  biplex_commutator_ac_be619e3591: entity work.biplex_commutator_ac_entity_be619e3591
    port map (
      aloahi => concat_y_net_x60,
      blobhi => concat_y_net_x62,
      ce_1 => ce_1_sg_x340,
      clk_1 => clk_1_sg_x340,
      sync_in => delay_q_net_x19,
      ahibhi => mux1_y_net_x3,
      aloblo => slr_q_net_x6,
      sync_out => delay_q_net_x17
    );

  biplex_commutator_bd_2cc0407482: entity work.biplex_commutator_ac_entity_be619e3591
    port map (
      aloahi => concat_y_net_x61,
      blobhi => concat_y_net_x63,
      ce_1 => ce_1_sg_x340,
      clk_1 => clk_1_sg_x340,
      sync_in => delay_q_net_x19,
      ahibhi => mux1_y_net_x5,
      aloblo => slr_q_net_x7,
      sync_out => delay_q_net_x18
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/r4_butterfly/butterfly0/c_to_ri"

entity c_to_ri_entity_57e270bed1 is
  port (
    c: in std_logic_vector(29 downto 0); 
    im: out std_logic_vector(14 downto 0); 
    re: out std_logic_vector(14 downto 0)
  );
end c_to_ri_entity_57e270bed1;

architecture structural of c_to_ri_entity_57e270bed1 is
  signal delay1_q_net_x0: std_logic_vector(29 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(14 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(14 downto 0);
  signal slice_im_y_net: std_logic_vector(14 downto 0);
  signal slice_re_y_net: std_logic_vector(14 downto 0);

begin
  delay1_q_net_x0 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_c2430bbd90
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_c2430bbd90
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 14,
      x_width => 30,
      y_width => 15
    )
    port map (
      x => delay1_q_net_x0,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 15,
      new_msb => 29,
      x_width => 30,
      y_width => 15
    )
    port map (
      x => delay1_q_net_x0,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/r4_butterfly/butterfly0/ri_to_c"

entity ri_to_c_entity_25be5da4bb is
  port (
    im: in std_logic_vector(15 downto 0); 
    re: in std_logic_vector(15 downto 0); 
    c: out std_logic_vector(31 downto 0)
  );
end ri_to_c_entity_25be5da4bb;

architecture structural of ri_to_c_entity_25be5da4bb is
  signal concat_y_net_x0: std_logic_vector(31 downto 0);
  signal force_im_output_port_net: std_logic_vector(15 downto 0);
  signal force_re_output_port_net: std_logic_vector(15 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(15 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(15 downto 0);

begin
  requant1_dout_net_x0 <= im;
  requant0_dout_net_x0 <= re;
  c <= concat_y_net_x0;

  concat: entity work.concat_a369e00c6b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x0
    );

  force_im: entity work.reinterpret_7025463ea8
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant1_dout_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_7025463ea8
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant0_dout_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/r4_butterfly/butterfly0"

entity butterfly0_entity_bb3478fb88 is
  port (
    a: in std_logic_vector(29 downto 0); 
    b: in std_logic_vector(29 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    a_b: out std_logic_vector(31 downto 0); 
    a_b_x0: out std_logic_vector(31 downto 0)
  );
end butterfly0_entity_bb3478fb88;

architecture structural of butterfly0_entity_bb3478fb88 is
  signal add_im_s_net: std_logic_vector(15 downto 0);
  signal add_re_s_net: std_logic_vector(15 downto 0);
  signal ce_1_sg_x341: std_logic;
  signal clk_1_sg_x341: std_logic;
  signal concat_y_net_x3: std_logic_vector(29 downto 0);
  signal concat_y_net_x4: std_logic_vector(31 downto 0);
  signal concat_y_net_x5: std_logic_vector(31 downto 0);
  signal delay1_q_net_x1: std_logic_vector(29 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(14 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(14 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(14 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(14 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(15 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(15 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(15 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(15 downto 0);
  signal shift0_op_net: std_logic_vector(15 downto 0);
  signal shift1_op_net: std_logic_vector(15 downto 0);
  signal shift2_op_net: std_logic_vector(15 downto 0);
  signal shift3_op_net: std_logic_vector(15 downto 0);
  signal sub_im_s_net: std_logic_vector(15 downto 0);
  signal sub_re_s_net: std_logic_vector(15 downto 0);

begin
  delay1_q_net_x1 <= a;
  concat_y_net_x3 <= b;
  ce_1_sg_x341 <= ce_1;
  clk_1_sg_x341 <= clk_1;
  a_b <= concat_y_net_x4;
  a_b_x0 <= concat_y_net_x5;

  add_im: entity work.addsub_e8bb7c4e8b
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x341,
      clk => clk_1_sg_x341,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_e8bb7c4e8b
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x341,
      clk => clk_1_sg_x341,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_37a4356664: entity work.c_to_ri_entity_57e270bed1
    port map (
      c => concat_y_net_x3,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_57e270bed1: entity work.c_to_ri_entity_57e270bed1
    port map (
      c => delay1_q_net_x1,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 16,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 16,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 16,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 16,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_dba0bce083: entity work.ri_to_c_entity_25be5da4bb
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x5
    );

  ri_to_c_25be5da4bb: entity work.ri_to_c_entity_25be5da4bb
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x4
    );

  shift0: entity work.scale_fa7c2ab9f6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_fa7c2ab9f6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_fa7c2ab9f6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_fa7c2ab9f6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_81ed09e952
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x341,
      clk => clk_1_sg_x341,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_81ed09e952
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x341,
      clk => clk_1_sg_x341,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/r4_butterfly/butterfly1"

entity butterfly1_entity_48108caaa1 is
  port (
    a: in std_logic_vector(29 downto 0); 
    b: in std_logic_vector(29 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    a_b: out std_logic_vector(31 downto 0); 
    a_b_x0: out std_logic_vector(31 downto 0); 
    sync_out: out std_logic
  );
end butterfly1_entity_48108caaa1;

architecture structural of butterfly1_entity_48108caaa1 is
  signal add_im_s_net: std_logic_vector(15 downto 0);
  signal add_re_s_net: std_logic_vector(15 downto 0);
  signal ce_1_sg_x342: std_logic;
  signal clk_1_sg_x342: std_logic;
  signal concat_y_net_x4: std_logic_vector(29 downto 0);
  signal concat_y_net_x5: std_logic_vector(29 downto 0);
  signal concat_y_net_x6: std_logic_vector(31 downto 0);
  signal concat_y_net_x7: std_logic_vector(31 downto 0);
  signal delay_q_net_x1: std_logic;
  signal delay_q_net_x2: std_logic;
  signal force_im_output_port_net_x0: std_logic_vector(14 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(14 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(14 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(14 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(15 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(15 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(15 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(15 downto 0);
  signal shift0_op_net: std_logic_vector(15 downto 0);
  signal shift1_op_net: std_logic_vector(15 downto 0);
  signal shift2_op_net: std_logic_vector(15 downto 0);
  signal shift3_op_net: std_logic_vector(15 downto 0);
  signal sub_im_s_net: std_logic_vector(15 downto 0);
  signal sub_re_s_net: std_logic_vector(15 downto 0);

begin
  concat_y_net_x4 <= a;
  concat_y_net_x5 <= b;
  ce_1_sg_x342 <= ce_1;
  clk_1_sg_x342 <= clk_1;
  delay_q_net_x1 <= sync_in;
  a_b <= concat_y_net_x6;
  a_b_x0 <= concat_y_net_x7;
  sync_out <= delay_q_net_x2;

  add_im: entity work.addsub_e8bb7c4e8b
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x342,
      clk => clk_1_sg_x342,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_e8bb7c4e8b
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x342,
      clk => clk_1_sg_x342,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_a8bbef38a6: entity work.c_to_ri_entity_57e270bed1
    port map (
      c => concat_y_net_x5,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_750757208e: entity work.c_to_ri_entity_57e270bed1
    port map (
      c => concat_y_net_x4,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x342,
      clk => clk_1_sg_x342,
      d(0) => delay_q_net_x1,
      en => '1',
      q(0) => delay_q_net_x2
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 16,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 16,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 16,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 16,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_fedf1fc5a2: entity work.ri_to_c_entity_25be5da4bb
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x7
    );

  ri_to_c_a014d8fb1f: entity work.ri_to_c_entity_25be5da4bb
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x6
    );

  shift0: entity work.scale_fa7c2ab9f6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_fa7c2ab9f6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_fa7c2ab9f6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_fa7c2ab9f6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_81ed09e952
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x342,
      clk => clk_1_sg_x342,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_81ed09e952
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x342,
      clk => clk_1_sg_x342,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/r4_butterfly/butterfly2/c_to_ri"

entity c_to_ri_entity_9e5ab6b1ae is
  port (
    c: in std_logic_vector(31 downto 0); 
    im: out std_logic_vector(15 downto 0); 
    re: out std_logic_vector(15 downto 0)
  );
end c_to_ri_entity_9e5ab6b1ae;

architecture structural of c_to_ri_entity_9e5ab6b1ae is
  signal concat_y_net_x5: std_logic_vector(31 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(15 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(15 downto 0);
  signal slice_im_y_net: std_logic_vector(15 downto 0);
  signal slice_re_y_net: std_logic_vector(15 downto 0);

begin
  concat_y_net_x5 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_151459306d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_151459306d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 15,
      x_width => 32,
      y_width => 16
    )
    port map (
      x => concat_y_net_x5,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 16,
      new_msb => 31,
      x_width => 32,
      y_width => 16
    )
    port map (
      x => concat_y_net_x5,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/r4_butterfly/butterfly2/ri_to_c"

entity ri_to_c_entity_e063d0f593 is
  port (
    im: in std_logic_vector(16 downto 0); 
    re: in std_logic_vector(16 downto 0); 
    c: out std_logic_vector(33 downto 0)
  );
end ri_to_c_entity_e063d0f593;

architecture structural of ri_to_c_entity_e063d0f593 is
  signal concat_y_net_x0: std_logic_vector(33 downto 0);
  signal force_im_output_port_net: std_logic_vector(16 downto 0);
  signal force_re_output_port_net: std_logic_vector(16 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(16 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(16 downto 0);

begin
  requant1_dout_net_x0 <= im;
  requant0_dout_net_x0 <= re;
  c <= concat_y_net_x0;

  concat: entity work.concat_25b7e1d1f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x0
    );

  force_im: entity work.reinterpret_573890e1c0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant1_dout_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_573890e1c0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant0_dout_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/r4_butterfly/butterfly2"

entity butterfly2_entity_03175731b5 is
  port (
    a: in std_logic_vector(31 downto 0); 
    b: in std_logic_vector(31 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    a_b: out std_logic_vector(33 downto 0); 
    a_b_x0: out std_logic_vector(33 downto 0)
  );
end butterfly2_entity_03175731b5;

architecture structural of butterfly2_entity_03175731b5 is
  signal add_im_s_net: std_logic_vector(16 downto 0);
  signal add_re_s_net: std_logic_vector(16 downto 0);
  signal ce_1_sg_x343: std_logic;
  signal clk_1_sg_x343: std_logic;
  signal concat_y_net_x10: std_logic_vector(31 downto 0);
  signal concat_y_net_x11: std_logic_vector(33 downto 0);
  signal concat_y_net_x12: std_logic_vector(33 downto 0);
  signal concat_y_net_x9: std_logic_vector(31 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(15 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(15 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(15 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(15 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(16 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(16 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(16 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(16 downto 0);
  signal shift0_op_net: std_logic_vector(16 downto 0);
  signal shift1_op_net: std_logic_vector(16 downto 0);
  signal shift2_op_net: std_logic_vector(16 downto 0);
  signal shift3_op_net: std_logic_vector(16 downto 0);
  signal sub_im_s_net: std_logic_vector(16 downto 0);
  signal sub_re_s_net: std_logic_vector(16 downto 0);

begin
  concat_y_net_x9 <= a;
  concat_y_net_x10 <= b;
  ce_1_sg_x343 <= ce_1;
  clk_1_sg_x343 <= clk_1;
  a_b <= concat_y_net_x11;
  a_b_x0 <= concat_y_net_x12;

  add_im: entity work.addsub_14b004d38d
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x343,
      clk => clk_1_sg_x343,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_14b004d38d
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x343,
      clk => clk_1_sg_x343,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_b49805bb0c: entity work.c_to_ri_entity_9e5ab6b1ae
    port map (
      c => concat_y_net_x10,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_9e5ab6b1ae: entity work.c_to_ri_entity_9e5ab6b1ae
    port map (
      c => concat_y_net_x9,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 17,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 17,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 17,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 17,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_41aab30747: entity work.ri_to_c_entity_e063d0f593
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x12
    );

  ri_to_c_e063d0f593: entity work.ri_to_c_entity_e063d0f593
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x11
    );

  shift0: entity work.scale_b42effccbc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_b42effccbc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_b42effccbc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_b42effccbc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_5d0bd43700
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x343,
      clk => clk_1_sg_x343,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_5d0bd43700
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x343,
      clk => clk_1_sg_x343,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/r4_butterfly/butterfly3j"

entity butterfly3j_entity_bc72a40e93 is
  port (
    a: in std_logic_vector(31 downto 0); 
    b: in std_logic_vector(31 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    a_b: out std_logic_vector(33 downto 0); 
    a_b_x0: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end butterfly3j_entity_bc72a40e93;

architecture structural of butterfly3j_entity_bc72a40e93 is
  signal add_im_s_net: std_logic_vector(16 downto 0);
  signal add_re_s_net: std_logic_vector(16 downto 0);
  signal ce_1_sg_x344: std_logic;
  signal clk_1_sg_x344: std_logic;
  signal concat_y_net_x10: std_logic_vector(33 downto 0);
  signal concat_y_net_x11: std_logic_vector(33 downto 0);
  signal concat_y_net_x7: std_logic_vector(31 downto 0);
  signal concat_y_net_x9: std_logic_vector(31 downto 0);
  signal delay_q_net_x0: std_logic;
  signal delay_q_net_x3: std_logic;
  signal force_im_output_port_net_x0: std_logic_vector(15 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(15 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(15 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(15 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(16 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(16 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(16 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(16 downto 0);
  signal shift0_op_net: std_logic_vector(16 downto 0);
  signal shift1_op_net: std_logic_vector(16 downto 0);
  signal shift2_op_net: std_logic_vector(16 downto 0);
  signal shift3_op_net: std_logic_vector(16 downto 0);
  signal sub_im_s_net: std_logic_vector(16 downto 0);
  signal sub_re_s_net: std_logic_vector(16 downto 0);

begin
  concat_y_net_x7 <= a;
  concat_y_net_x9 <= b;
  ce_1_sg_x344 <= ce_1;
  clk_1_sg_x344 <= clk_1;
  delay_q_net_x3 <= sync_in;
  a_b <= concat_y_net_x10;
  a_b_x0 <= concat_y_net_x11;
  sync_out <= delay_q_net_x0;

  add_im: entity work.addsub_5d0bd43700
    port map (
      a => force_im_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x344,
      clk => clk_1_sg_x344,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_14b004d38d
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x344,
      clk => clk_1_sg_x344,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_fd29c655b0: entity work.c_to_ri_entity_9e5ab6b1ae
    port map (
      c => concat_y_net_x9,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_aa8291571b: entity work.c_to_ri_entity_9e5ab6b1ae
    port map (
      c => concat_y_net_x7,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x344,
      clk => clk_1_sg_x344,
      d(0) => delay_q_net_x3,
      en => '1',
      q(0) => delay_q_net_x0
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 17,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 17,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 17,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 17,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_6fcaeb9478: entity work.ri_to_c_entity_e063d0f593
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x11
    );

  ri_to_c_0488806938: entity work.ri_to_c_entity_e063d0f593
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x10
    );

  shift0: entity work.scale_b42effccbc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_b42effccbc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_b42effccbc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_b42effccbc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_14b004d38d
    port map (
      a => force_im_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x344,
      clk => clk_1_sg_x344,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_5d0bd43700
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x344,
      clk => clk_1_sg_x344,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/r4_butterfly"

entity r4_butterfly_entity_0ab8bacc2c is
  port (
    a_in: in std_logic_vector(29 downto 0); 
    b_in: in std_logic_vector(29 downto 0); 
    c_in: in std_logic_vector(29 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d_in: in std_logic_vector(29 downto 0); 
    sync_in: in std_logic; 
    a_out: out std_logic_vector(33 downto 0); 
    b_out: out std_logic_vector(33 downto 0); 
    c_out: out std_logic_vector(33 downto 0); 
    d_out: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end r4_butterfly_entity_0ab8bacc2c;

architecture structural of r4_butterfly_entity_0ab8bacc2c is
  signal ce_1_sg_x345: std_logic;
  signal clk_1_sg_x345: std_logic;
  signal concat_y_net_x10: std_logic_vector(31 downto 0);
  signal concat_y_net_x11: std_logic_vector(31 downto 0);
  signal concat_y_net_x16: std_logic_vector(29 downto 0);
  signal concat_y_net_x17: std_logic_vector(29 downto 0);
  signal concat_y_net_x18: std_logic_vector(29 downto 0);
  signal concat_y_net_x19: std_logic_vector(33 downto 0);
  signal concat_y_net_x20: std_logic_vector(33 downto 0);
  signal concat_y_net_x21: std_logic_vector(33 downto 0);
  signal concat_y_net_x22: std_logic_vector(33 downto 0);
  signal concat_y_net_x7: std_logic_vector(31 downto 0);
  signal concat_y_net_x9: std_logic_vector(31 downto 0);
  signal delay1_q_net_x2: std_logic_vector(29 downto 0);
  signal delay_q_net_x2: std_logic;
  signal delay_q_net_x3: std_logic;
  signal delay_q_net_x4: std_logic;

begin
  delay1_q_net_x2 <= a_in;
  concat_y_net_x16 <= b_in;
  concat_y_net_x17 <= c_in;
  ce_1_sg_x345 <= ce_1;
  clk_1_sg_x345 <= clk_1;
  concat_y_net_x18 <= d_in;
  delay_q_net_x2 <= sync_in;
  a_out <= concat_y_net_x19;
  b_out <= concat_y_net_x20;
  c_out <= concat_y_net_x21;
  d_out <= concat_y_net_x22;
  sync_out <= delay_q_net_x4;

  butterfly0_bb3478fb88: entity work.butterfly0_entity_bb3478fb88
    port map (
      a => delay1_q_net_x2,
      b => concat_y_net_x17,
      ce_1 => ce_1_sg_x345,
      clk_1 => clk_1_sg_x345,
      a_b => concat_y_net_x9,
      a_b_x0 => concat_y_net_x7
    );

  butterfly1_48108caaa1: entity work.butterfly1_entity_48108caaa1
    port map (
      a => concat_y_net_x16,
      b => concat_y_net_x18,
      ce_1 => ce_1_sg_x345,
      clk_1 => clk_1_sg_x345,
      sync_in => delay_q_net_x2,
      a_b => concat_y_net_x10,
      a_b_x0 => concat_y_net_x11,
      sync_out => delay_q_net_x3
    );

  butterfly2_03175731b5: entity work.butterfly2_entity_03175731b5
    port map (
      a => concat_y_net_x9,
      b => concat_y_net_x10,
      ce_1 => ce_1_sg_x345,
      clk_1 => clk_1_sg_x345,
      a_b => concat_y_net_x19,
      a_b_x0 => concat_y_net_x20
    );

  butterfly3j_bc72a40e93: entity work.butterfly3j_entity_bc72a40e93
    port map (
      a => concat_y_net_x7,
      b => concat_y_net_x11,
      ce_1 => ce_1_sg_x345,
      clk_1 => clk_1_sg_x345,
      sync_in => delay_q_net_x3,
      a_b => concat_y_net_x21,
      a_b_x0 => concat_y_net_x22,
      sync_out => delay_q_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/r4_twiddle/cmpy1/c_to_ri"

entity c_to_ri_entity_b773420e76 is
  port (
    c: in std_logic_vector(29 downto 0); 
    im: out std_logic_vector(14 downto 0); 
    re: out std_logic_vector(14 downto 0)
  );
end c_to_ri_entity_b773420e76;

architecture structural of c_to_ri_entity_b773420e76 is
  signal delay1_q_net_x0: std_logic_vector(29 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(14 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(14 downto 0);
  signal slice_im_y_net: std_logic_vector(14 downto 0);
  signal slice_re_y_net: std_logic_vector(14 downto 0);

begin
  delay1_q_net_x0 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_c2430bbd90
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_c2430bbd90
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 14,
      x_width => 30,
      y_width => 15
    )
    port map (
      x => delay1_q_net_x0,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 15,
      new_msb => 29,
      x_width => 30,
      y_width => 15
    )
    port map (
      x => delay1_q_net_x0,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/r4_twiddle/cmpy1/ri_to_c"

entity ri_to_c_entity_37144ab30f is
  port (
    im: in std_logic_vector(14 downto 0); 
    re: in std_logic_vector(14 downto 0); 
    c: out std_logic_vector(29 downto 0)
  );
end ri_to_c_entity_37144ab30f;

architecture structural of ri_to_c_entity_37144ab30f is
  signal concat_y_net_x17: std_logic_vector(29 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(14 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(14 downto 0);
  signal force_im_output_port_net: std_logic_vector(14 downto 0);
  signal force_re_output_port_net: std_logic_vector(14 downto 0);

begin
  convert_im_dout_net_x0 <= im;
  convert_re_dout_net_x0 <= re;
  c <= concat_y_net_x17;

  concat: entity work.concat_22467883b2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x17
    );

  force_im: entity work.reinterpret_0d1490be80
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert_im_dout_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_0d1490be80
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert_re_dout_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/r4_twiddle/cmpy1"

entity cmpy1_entity_f1024babbe is
  port (
    a_in: in std_logic_vector(29 downto 0); 
    b: in std_logic_vector(29 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    w: in std_logic_vector(17 downto 0); 
    a_out: out std_logic_vector(29 downto 0); 
    bw: out std_logic_vector(29 downto 0); 
    sync_out: out std_logic
  );
end cmpy1_entity_f1024babbe;

architecture structural of cmpy1_entity_f1024babbe is
  signal br_add_bi_s_net: std_logic_vector(15 downto 0);
  signal ce_1_sg_x346: std_logic;
  signal clk_1_sg_x346: std_logic;
  signal concat_y_net_x18: std_logic_vector(29 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(14 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(14 downto 0);
  signal delay1_q_net_x1: std_logic_vector(29 downto 0);
  signal delay1_q_net_x3: std_logic_vector(29 downto 0);
  signal delay2_q_net_x0: std_logic_vector(29 downto 0);
  signal delay3_q_net_x0: std_logic;
  signal delay_q_net_x3: std_logic;
  signal force_im_output_port_net_x0: std_logic_vector(14 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(8 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(14 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(8 downto 0);
  signal imim_p_net: std_logic_vector(21 downto 0);
  signal mem_c_data_net_x1: std_logic_vector(17 downto 0);
  signal rere_p_net: std_logic_vector(21 downto 0);
  signal rr_add_ii_s_net: std_logic_vector(21 downto 0);
  signal rr_sub_ii_s_net: std_logic_vector(21 downto 0);
  signal ss_sub_rrii_s_net: std_logic_vector(21 downto 0);
  signal sumsum_p_net: std_logic_vector(21 downto 0);
  signal wr_add_wi_s_net: std_logic_vector(9 downto 0);

begin
  delay2_q_net_x0 <= a_in;
  delay1_q_net_x1 <= b;
  ce_1_sg_x346 <= ce_1;
  clk_1_sg_x346 <= clk_1;
  delay3_q_net_x0 <= sync_in;
  mem_c_data_net_x1 <= w;
  a_out <= delay1_q_net_x3;
  bw <= concat_y_net_x18;
  sync_out <= delay_q_net_x3;

  br_add_bi: entity work.addsub_24b2bc78a0
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x0,
      ce => ce_1_sg_x346,
      clk => clk_1_sg_x346,
      clr => '0',
      s => br_add_bi_s_net
    );

  c_to_ri1_84c76a8133: entity work.c_to_ri1_entity_7fe674c156
    port map (
      c => mem_c_data_net_x1,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_b773420e76: entity work.c_to_ri_entity_b773420e76
    port map (
      c => delay1_q_net_x1,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  convert_im: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 21,
      din_width => 22,
      dout_arith => 2,
      dout_bin_pt => 14,
      dout_width => 15,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x346,
      clk => clk_1_sg_x346,
      clr => '0',
      din => ss_sub_rrii_s_net,
      dout => convert_im_dout_net_x0
    );

  convert_re: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 21,
      din_width => 22,
      dout_arith => 2,
      dout_bin_pt => 14,
      dout_width => 15,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x346,
      clk => clk_1_sg_x346,
      clr => '0',
      din => rr_sub_ii_s_net,
      dout => convert_re_dout_net_x0
    );

  delay: entity work.xldelay
    generic map (
      latency => 8,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x346,
      clk => clk_1_sg_x346,
      d(0) => delay3_q_net_x0,
      en => '1',
      q(0) => delay_q_net_x3
    );

  delay1: entity work.xldelay
    generic map (
      latency => 8,
      reg_retiming => 0,
      width => 30
    )
    port map (
      ce => ce_1_sg_x346,
      clk => clk_1_sg_x346,
      d => delay2_q_net_x0,
      en => '1',
      q => delay1_q_net_x3
    );

  imim: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 14,
      a_width => 15,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 15,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 15,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_9a2572cfdd818f42",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 21,
      p_width => 22,
      quantization => 1
    )
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x346,
      clk => clk_1_sg_x346,
      clr => '0',
      core_ce => ce_1_sg_x346,
      core_clk => clk_1_sg_x346,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => imim_p_net
    );

  rere: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 14,
      a_width => 15,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 15,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 15,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_9a2572cfdd818f42",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 21,
      p_width => 22,
      quantization => 1
    )
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x346,
      clk => clk_1_sg_x346,
      clr => '0',
      core_ce => ce_1_sg_x346,
      core_clk => clk_1_sg_x346,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => rere_p_net
    );

  ri_to_c_37144ab30f: entity work.ri_to_c_entity_37144ab30f
    port map (
      im => convert_im_dout_net_x0,
      re => convert_re_dout_net_x0,
      c => concat_y_net_x18
    );

  rr_add_ii: entity work.addsub_c7058621d7
    port map (
      a => imim_p_net,
      b => rere_p_net,
      ce => ce_1_sg_x346,
      clk => clk_1_sg_x346,
      clr => '0',
      s => rr_add_ii_s_net
    );

  rr_sub_ii: entity work.addsub_977ed7b8a2
    port map (
      a => rere_p_net,
      b => imim_p_net,
      ce => ce_1_sg_x346,
      clk => clk_1_sg_x346,
      clr => '0',
      s => rr_sub_ii_s_net
    );

  ss_sub_rrii: entity work.addsub_0f2f4c67a4
    port map (
      a => sumsum_p_net,
      b => rr_add_ii_s_net,
      ce => ce_1_sg_x346,
      clk => clk_1_sg_x346,
      clr => '0',
      s => ss_sub_rrii_s_net
    );

  sumsum: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 14,
      a_width => 16,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 10,
      c_a_type => 0,
      c_a_width => 16,
      c_b_type => 0,
      c_b_width => 10,
      c_baat => 16,
      c_output_width => 26,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_e96fd0f2d7a7d0c5",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 21,
      p_width => 22,
      quantization => 1
    )
    port map (
      a => br_add_bi_s_net,
      b => wr_add_wi_s_net,
      ce => ce_1_sg_x346,
      clk => clk_1_sg_x346,
      clr => '0',
      core_ce => ce_1_sg_x346,
      core_clk => clk_1_sg_x346,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => sumsum_p_net
    );

  wr_add_wi: entity work.addsub_bd2bd198b1
    port map (
      a => force_re_output_port_net_x1,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x346,
      clk => clk_1_sg_x346,
      clr => '0',
      s => wr_add_wi_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/r4_twiddle/cmpy2"

entity cmpy2_entity_0fb3561415 is
  port (
    b: in std_logic_vector(29 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    w: in std_logic_vector(17 downto 0); 
    bw: out std_logic_vector(29 downto 0)
  );
end cmpy2_entity_0fb3561415;

architecture structural of cmpy2_entity_0fb3561415 is
  signal br_add_bi_s_net: std_logic_vector(15 downto 0);
  signal ce_1_sg_x347: std_logic;
  signal clk_1_sg_x347: std_logic;
  signal concat_y_net_x19: std_logic_vector(29 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(14 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(14 downto 0);
  signal delay4_q_net_x1: std_logic_vector(29 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(14 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(8 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(14 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(8 downto 0);
  signal imim_p_net: std_logic_vector(21 downto 0);
  signal mem_c_data_net_x1: std_logic_vector(17 downto 0);
  signal rere_p_net: std_logic_vector(21 downto 0);
  signal rr_add_ii_s_net: std_logic_vector(21 downto 0);
  signal rr_sub_ii_s_net: std_logic_vector(21 downto 0);
  signal ss_sub_rrii_s_net: std_logic_vector(21 downto 0);
  signal sumsum_p_net: std_logic_vector(21 downto 0);
  signal wr_add_wi_s_net: std_logic_vector(9 downto 0);

begin
  delay4_q_net_x1 <= b;
  ce_1_sg_x347 <= ce_1;
  clk_1_sg_x347 <= clk_1;
  mem_c_data_net_x1 <= w;
  bw <= concat_y_net_x19;

  br_add_bi: entity work.addsub_24b2bc78a0
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x0,
      ce => ce_1_sg_x347,
      clk => clk_1_sg_x347,
      clr => '0',
      s => br_add_bi_s_net
    );

  c_to_ri1_20a6e15328: entity work.c_to_ri1_entity_7fe674c156
    port map (
      c => mem_c_data_net_x1,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_8dd3bf6675: entity work.c_to_ri_entity_b773420e76
    port map (
      c => delay4_q_net_x1,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  convert_im: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 21,
      din_width => 22,
      dout_arith => 2,
      dout_bin_pt => 14,
      dout_width => 15,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x347,
      clk => clk_1_sg_x347,
      clr => '0',
      din => ss_sub_rrii_s_net,
      dout => convert_im_dout_net_x0
    );

  convert_re: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 21,
      din_width => 22,
      dout_arith => 2,
      dout_bin_pt => 14,
      dout_width => 15,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x347,
      clk => clk_1_sg_x347,
      clr => '0',
      din => rr_sub_ii_s_net,
      dout => convert_re_dout_net_x0
    );

  imim: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 14,
      a_width => 15,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 15,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 15,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_9a2572cfdd818f42",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 21,
      p_width => 22,
      quantization => 1
    )
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x347,
      clk => clk_1_sg_x347,
      clr => '0',
      core_ce => ce_1_sg_x347,
      core_clk => clk_1_sg_x347,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => imim_p_net
    );

  rere: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 14,
      a_width => 15,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 15,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 15,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_9a2572cfdd818f42",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 21,
      p_width => 22,
      quantization => 1
    )
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x347,
      clk => clk_1_sg_x347,
      clr => '0',
      core_ce => ce_1_sg_x347,
      core_clk => clk_1_sg_x347,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => rere_p_net
    );

  ri_to_c_60f6727aff: entity work.ri_to_c_entity_37144ab30f
    port map (
      im => convert_im_dout_net_x0,
      re => convert_re_dout_net_x0,
      c => concat_y_net_x19
    );

  rr_add_ii: entity work.addsub_c7058621d7
    port map (
      a => imim_p_net,
      b => rere_p_net,
      ce => ce_1_sg_x347,
      clk => clk_1_sg_x347,
      clr => '0',
      s => rr_add_ii_s_net
    );

  rr_sub_ii: entity work.addsub_977ed7b8a2
    port map (
      a => rere_p_net,
      b => imim_p_net,
      ce => ce_1_sg_x347,
      clk => clk_1_sg_x347,
      clr => '0',
      s => rr_sub_ii_s_net
    );

  ss_sub_rrii: entity work.addsub_0f2f4c67a4
    port map (
      a => sumsum_p_net,
      b => rr_add_ii_s_net,
      ce => ce_1_sg_x347,
      clk => clk_1_sg_x347,
      clr => '0',
      s => ss_sub_rrii_s_net
    );

  sumsum: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 14,
      a_width => 16,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 10,
      c_a_type => 0,
      c_a_width => 16,
      c_b_type => 0,
      c_b_width => 10,
      c_baat => 16,
      c_output_width => 26,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_e96fd0f2d7a7d0c5",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 21,
      p_width => 22,
      quantization => 1
    )
    port map (
      a => br_add_bi_s_net,
      b => wr_add_wi_s_net,
      ce => ce_1_sg_x347,
      clk => clk_1_sg_x347,
      clr => '0',
      core_ce => ce_1_sg_x347,
      core_clk => clk_1_sg_x347,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => sumsum_p_net
    );

  wr_add_wi: entity work.addsub_bd2bd198b1
    port map (
      a => force_re_output_port_net_x1,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x347,
      clk => clk_1_sg_x347,
      clr => '0',
      s => wr_add_wi_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/r4_twiddle/twiddle_gen1"

entity twiddle_gen1_entity_3a83a45804 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    w: out std_logic_vector(17 downto 0)
  );
end twiddle_gen1_entity_3a83a45804;

architecture structural of twiddle_gen1_entity_3a83a45804 is
  signal addr_sel_y_net: std_logic_vector(5 downto 0);
  signal ce_1_sg_x349: std_logic;
  signal clk_1_sg_x349: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay_q_net_x21: std_logic;
  signal mem_c_data_net_x2: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x349 <= ce_1;
  clk_1_sg_x349 <= clk_1;
  delay_q_net_x21 <= sync_in;
  w <= mem_c_data_net_x2;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 7,
      x_width => 8,
      y_width => 6
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_01e34ae12479a5e1",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x349,
      clk => clk_1_sg_x349,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x21,
      op => counter_op_net
    );

  mem_c: entity work.xlsprom
    generic map (
      c_address_width => 6,
      c_width => 18,
      core_name0 => "bmg_24_vx5_e356d8b9149f54d5",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x349,
      clk => clk_1_sg_x349,
      en => "1",
      rst => "0",
      data => mem_c_data_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/r4_twiddle/twiddle_gen2"

entity twiddle_gen2_entity_25e549652a is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    w: out std_logic_vector(17 downto 0)
  );
end twiddle_gen2_entity_25e549652a;

architecture structural of twiddle_gen2_entity_25e549652a is
  signal addr_sel_y_net: std_logic_vector(5 downto 0);
  signal ce_1_sg_x350: std_logic;
  signal clk_1_sg_x350: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay_q_net_x22: std_logic;
  signal mem_c_data_net_x2: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x350 <= ce_1;
  clk_1_sg_x350 <= clk_1;
  delay_q_net_x22 <= sync_in;
  w <= mem_c_data_net_x2;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 7,
      x_width => 8,
      y_width => 6
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_01e34ae12479a5e1",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x350,
      clk => clk_1_sg_x350,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x22,
      op => counter_op_net
    );

  mem_c: entity work.xlsprom
    generic map (
      c_address_width => 6,
      c_width => 18,
      core_name0 => "bmg_24_vx5_c5c136a08dd56dbc",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x350,
      clk => clk_1_sg_x350,
      en => "1",
      rst => "0",
      data => mem_c_data_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/r4_twiddle/twiddle_gen3"

entity twiddle_gen3_entity_af5898bf4e is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    w: out std_logic_vector(17 downto 0)
  );
end twiddle_gen3_entity_af5898bf4e;

architecture structural of twiddle_gen3_entity_af5898bf4e is
  signal addr_sel_y_net: std_logic_vector(5 downto 0);
  signal ce_1_sg_x351: std_logic;
  signal clk_1_sg_x351: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay_q_net_x23: std_logic;
  signal mem_c_data_net_x2: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x351 <= ce_1;
  clk_1_sg_x351 <= clk_1;
  delay_q_net_x23 <= sync_in;
  w <= mem_c_data_net_x2;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 7,
      x_width => 8,
      y_width => 6
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_01e34ae12479a5e1",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x351,
      clk => clk_1_sg_x351,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x23,
      op => counter_op_net
    );

  mem_c: entity work.xlsprom
    generic map (
      c_address_width => 6,
      c_width => 18,
      core_name0 => "bmg_24_vx5_9d8577c93c4baa0d",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x351,
      clk => clk_1_sg_x351,
      en => "1",
      rst => "0",
      data => mem_c_data_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4/r4_twiddle"

entity r4_twiddle_entity_f1f6e73f6c is
  port (
    a_in: in std_logic_vector(29 downto 0); 
    b: in std_logic_vector(29 downto 0); 
    c: in std_logic_vector(29 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(29 downto 0); 
    sync_in: in std_logic; 
    a_out: out std_logic_vector(29 downto 0); 
    bw: out std_logic_vector(29 downto 0); 
    cw: out std_logic_vector(29 downto 0); 
    dw: out std_logic_vector(29 downto 0); 
    sync_out: out std_logic
  );
end r4_twiddle_entity_f1f6e73f6c;

architecture structural of r4_twiddle_entity_f1f6e73f6c is
  signal ce_1_sg_x352: std_logic;
  signal clk_1_sg_x352: std_logic;
  signal concat_y_net_x21: std_logic_vector(29 downto 0);
  signal concat_y_net_x22: std_logic_vector(29 downto 0);
  signal concat_y_net_x23: std_logic_vector(29 downto 0);
  signal delay1_q_net_x1: std_logic_vector(29 downto 0);
  signal delay1_q_net_x4: std_logic_vector(29 downto 0);
  signal delay2_q_net_x0: std_logic_vector(29 downto 0);
  signal delay3_q_net_x0: std_logic;
  signal delay4_q_net_x1: std_logic_vector(29 downto 0);
  signal delay5_q_net_x1: std_logic_vector(29 downto 0);
  signal delay_q_net_x24: std_logic;
  signal delay_q_net_x4: std_logic;
  signal mem_c_data_net_x2: std_logic_vector(17 downto 0);
  signal mem_c_data_net_x3: std_logic_vector(17 downto 0);
  signal mem_c_data_net_x4: std_logic_vector(17 downto 0);
  signal mux1_y_net_x8: std_logic_vector(29 downto 0);
  signal mux1_y_net_x9: std_logic_vector(29 downto 0);
  signal slr_q_net_x10: std_logic_vector(29 downto 0);
  signal slr_q_net_x11: std_logic_vector(29 downto 0);

begin
  slr_q_net_x10 <= a_in;
  mux1_y_net_x8 <= b;
  slr_q_net_x11 <= c;
  ce_1_sg_x352 <= ce_1;
  clk_1_sg_x352 <= clk_1;
  mux1_y_net_x9 <= d;
  delay_q_net_x24 <= sync_in;
  a_out <= delay1_q_net_x4;
  bw <= concat_y_net_x21;
  cw <= concat_y_net_x22;
  dw <= concat_y_net_x23;
  sync_out <= delay_q_net_x4;

  cmpy1_f1024babbe: entity work.cmpy1_entity_f1024babbe
    port map (
      a_in => delay2_q_net_x0,
      b => delay1_q_net_x1,
      ce_1 => ce_1_sg_x352,
      clk_1 => clk_1_sg_x352,
      sync_in => delay3_q_net_x0,
      w => mem_c_data_net_x2,
      a_out => delay1_q_net_x4,
      bw => concat_y_net_x21,
      sync_out => delay_q_net_x4
    );

  cmpy2_0fb3561415: entity work.cmpy2_entity_0fb3561415
    port map (
      b => delay4_q_net_x1,
      ce_1 => ce_1_sg_x352,
      clk_1 => clk_1_sg_x352,
      w => mem_c_data_net_x3,
      bw => concat_y_net_x22
    );

  cmpy3_a245edc9f1: entity work.cmpy2_entity_0fb3561415
    port map (
      b => delay5_q_net_x1,
      ce_1 => ce_1_sg_x352,
      clk_1 => clk_1_sg_x352,
      w => mem_c_data_net_x4,
      bw => concat_y_net_x23
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 30
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => mux1_y_net_x8,
      en => '1',
      q => delay1_q_net_x1
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 30
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => slr_q_net_x10,
      en => '1',
      q => delay2_q_net_x0
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d(0) => delay_q_net_x24,
      en => '1',
      q(0) => delay3_q_net_x0
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 30
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => slr_q_net_x11,
      en => '1',
      q => delay4_q_net_x1
    );

  delay5: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 30
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => mux1_y_net_x9,
      en => '1',
      q => delay5_q_net_x1
    );

  twiddle_gen1_3a83a45804: entity work.twiddle_gen1_entity_3a83a45804
    port map (
      ce_1 => ce_1_sg_x352,
      clk_1 => clk_1_sg_x352,
      sync_in => delay_q_net_x24,
      w => mem_c_data_net_x2
    );

  twiddle_gen2_25e549652a: entity work.twiddle_gen2_entity_25e549652a
    port map (
      ce_1 => ce_1_sg_x352,
      clk_1 => clk_1_sg_x352,
      sync_in => delay_q_net_x24,
      w => mem_c_data_net_x3
    );

  twiddle_gen3_af5898bf4e: entity work.twiddle_gen3_entity_af5898bf4e
    port map (
      ce_1 => ce_1_sg_x352,
      clk_1 => clk_1_sg_x352,
      sync_in => delay_q_net_x24,
      w => mem_c_data_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_4"

entity r4_dit_stage_4_entity_fc2110268b is
  port (
    a_in: in std_logic_vector(29 downto 0); 
    b_in: in std_logic_vector(29 downto 0); 
    c_in: in std_logic_vector(29 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d_in: in std_logic_vector(29 downto 0); 
    sync_in: in std_logic; 
    a_out: out std_logic_vector(33 downto 0); 
    b_out: out std_logic_vector(33 downto 0); 
    c_out: out std_logic_vector(33 downto 0); 
    d_out: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end r4_dit_stage_4_entity_fc2110268b;

architecture structural of r4_dit_stage_4_entity_fc2110268b is
  signal ce_1_sg_x353: std_logic;
  signal clk_1_sg_x353: std_logic;
  signal concat_y_net_x23: std_logic_vector(29 downto 0);
  signal concat_y_net_x24: std_logic_vector(29 downto 0);
  signal concat_y_net_x25: std_logic_vector(29 downto 0);
  signal concat_y_net_x26: std_logic_vector(33 downto 0);
  signal concat_y_net_x27: std_logic_vector(33 downto 0);
  signal concat_y_net_x28: std_logic_vector(33 downto 0);
  signal concat_y_net_x29: std_logic_vector(33 downto 0);
  signal concat_y_net_x64: std_logic_vector(29 downto 0);
  signal concat_y_net_x65: std_logic_vector(29 downto 0);
  signal concat_y_net_x66: std_logic_vector(29 downto 0);
  signal concat_y_net_x67: std_logic_vector(29 downto 0);
  signal delay1_q_net_x4: std_logic_vector(29 downto 0);
  signal delay_q_net_x20: std_logic;
  signal delay_q_net_x21: std_logic;
  signal delay_q_net_x22: std_logic;
  signal delay_q_net_x24: std_logic;
  signal mux1_y_net_x8: std_logic_vector(29 downto 0);
  signal mux1_y_net_x9: std_logic_vector(29 downto 0);
  signal slr_q_net_x10: std_logic_vector(29 downto 0);
  signal slr_q_net_x11: std_logic_vector(29 downto 0);

begin
  concat_y_net_x64 <= a_in;
  concat_y_net_x65 <= b_in;
  concat_y_net_x66 <= c_in;
  ce_1_sg_x353 <= ce_1;
  clk_1_sg_x353 <= clk_1;
  concat_y_net_x67 <= d_in;
  delay_q_net_x21 <= sync_in;
  a_out <= concat_y_net_x26;
  b_out <= concat_y_net_x27;
  c_out <= concat_y_net_x28;
  d_out <= concat_y_net_x29;
  sync_out <= delay_q_net_x22;

  quadplex_commutator_e1467df2f4: entity work.quadplex_commutator_entity_e1467df2f4
    port map (
      a => concat_y_net_x64,
      b => concat_y_net_x65,
      c => concat_y_net_x66,
      ce_1 => ce_1_sg_x353,
      clk_1 => clk_1_sg_x353,
      d => concat_y_net_x67,
      sync_in => delay_q_net_x21,
      abcd0 => slr_q_net_x10,
      abcd1 => mux1_y_net_x8,
      abcd2 => slr_q_net_x11,
      abcd3 => mux1_y_net_x9,
      sync_out => delay_q_net_x24
    );

  r4_butterfly_0ab8bacc2c: entity work.r4_butterfly_entity_0ab8bacc2c
    port map (
      a_in => delay1_q_net_x4,
      b_in => concat_y_net_x23,
      c_in => concat_y_net_x24,
      ce_1 => ce_1_sg_x353,
      clk_1 => clk_1_sg_x353,
      d_in => concat_y_net_x25,
      sync_in => delay_q_net_x20,
      a_out => concat_y_net_x26,
      b_out => concat_y_net_x27,
      c_out => concat_y_net_x28,
      d_out => concat_y_net_x29,
      sync_out => delay_q_net_x22
    );

  r4_twiddle_f1f6e73f6c: entity work.r4_twiddle_entity_f1f6e73f6c
    port map (
      a_in => slr_q_net_x10,
      b => mux1_y_net_x8,
      c => slr_q_net_x11,
      ce_1 => ce_1_sg_x353,
      clk_1 => clk_1_sg_x353,
      d => mux1_y_net_x9,
      sync_in => delay_q_net_x24,
      a_out => delay1_q_net_x4,
      bw => concat_y_net_x23,
      cw => concat_y_net_x24,
      dw => concat_y_net_x25,
      sync_out => delay_q_net_x20
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/quadplex_commutator/biplex_commutator_01/delay_b"

entity delay_b_entity_333926c402 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(33 downto 0); 
    out_x0: out std_logic_vector(33 downto 0)
  );
end delay_b_entity_333926c402;

architecture structural of delay_b_entity_333926c402 is
  signal ce_1_sg_x354: std_logic;
  signal clk_1_sg_x354: std_logic;
  signal slr_q_net_x1: std_logic_vector(33 downto 0);
  signal slr_q_net_x2: std_logic_vector(33 downto 0);

begin
  ce_1_sg_x354 <= ce_1;
  clk_1_sg_x354 <= clk_1;
  slr_q_net_x1 <= in_x0;
  out_x0 <= slr_q_net_x2;

  slr: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 34
    )
    port map (
      ce => ce_1_sg_x354,
      clk => clk_1_sg_x354,
      d => slr_q_net_x1,
      en => '1',
      q => slr_q_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/quadplex_commutator/biplex_commutator_01"

entity biplex_commutator_01_entity_aa2e066db0 is
  port (
    aloahi: in std_logic_vector(33 downto 0); 
    blobhi: in std_logic_vector(33 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(33 downto 0); 
    aloblo: out std_logic_vector(33 downto 0)
  );
end biplex_commutator_01_entity_aa2e066db0;

architecture structural of biplex_commutator_01_entity_aa2e066db0 is
  signal ce_1_sg_x356: std_logic;
  signal clk_1_sg_x356: std_logic;
  signal counter_op_net: std_logic;
  signal delay_q_net_x0: std_logic;
  signal mux1_y_net_x0: std_logic_vector(33 downto 0);
  signal mux_y_net_x0: std_logic_vector(33 downto 0);
  signal slr_q_net_x2: std_logic_vector(33 downto 0);
  signal slr_q_net_x3: std_logic_vector(33 downto 0);
  signal slr_q_net_x4: std_logic_vector(33 downto 0);
  signal slr_q_net_x5: std_logic_vector(33 downto 0);
  signal top_bit_y_net: std_logic;

begin
  slr_q_net_x3 <= aloahi;
  slr_q_net_x4 <= blobhi;
  ce_1_sg_x356 <= ce_1;
  clk_1_sg_x356 <= clk_1;
  delay_q_net_x0 <= sync_in;
  ahibhi <= mux1_y_net_x0;
  aloblo <= slr_q_net_x5;

  counter: entity work.counter_9b03e3d644
    port map (
      ce => ce_1_sg_x356,
      clk => clk_1_sg_x356,
      clr => '0',
      rst(0) => delay_q_net_x0,
      op(0) => counter_op_net
    );

  delay_b_333926c402: entity work.delay_b_entity_333926c402
    port map (
      ce_1 => ce_1_sg_x356,
      clk_1 => clk_1_sg_x356,
      in_x0 => slr_q_net_x4,
      out_x0 => slr_q_net_x2
    );

  delay_lo_167ab02da7: entity work.delay_b_entity_333926c402
    port map (
      ce_1 => ce_1_sg_x356,
      clk_1 => clk_1_sg_x356,
      in_x0 => mux_y_net_x0,
      out_x0 => slr_q_net_x5
    );

  mux: entity work.mux_22ce705a06
    port map (
      ce => ce_1_sg_x356,
      clk => clk_1_sg_x356,
      clr => '0',
      d0 => slr_q_net_x3,
      d1 => slr_q_net_x2,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x0
    );

  mux1: entity work.mux_22ce705a06
    port map (
      ce => ce_1_sg_x356,
      clk => clk_1_sg_x356,
      clr => '0',
      d0 => slr_q_net_x2,
      d1 => slr_q_net_x3,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x0
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 1,
      y_width => 1
    )
    port map (
      x(0) => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/quadplex_commutator/biplex_commutator_23"

entity biplex_commutator_23_entity_4f62580056 is
  port (
    aloahi: in std_logic_vector(33 downto 0); 
    blobhi: in std_logic_vector(33 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(33 downto 0); 
    aloblo: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end biplex_commutator_23_entity_4f62580056;

architecture structural of biplex_commutator_23_entity_4f62580056 is
  signal ce_1_sg_x359: std_logic;
  signal clk_1_sg_x359: std_logic;
  signal counter_op_net: std_logic;
  signal delay_q_net_x1: std_logic;
  signal delay_q_net_x2: std_logic;
  signal mux1_y_net_x2: std_logic_vector(33 downto 0);
  signal mux1_y_net_x3: std_logic_vector(33 downto 0);
  signal mux1_y_net_x4: std_logic_vector(33 downto 0);
  signal mux_y_net_x0: std_logic_vector(33 downto 0);
  signal slr_q_net_x0: std_logic_vector(33 downto 0);
  signal slr_q_net_x2: std_logic_vector(33 downto 0);
  signal top_bit_y_net: std_logic;

begin
  mux1_y_net_x2 <= aloahi;
  mux1_y_net_x3 <= blobhi;
  ce_1_sg_x359 <= ce_1;
  clk_1_sg_x359 <= clk_1;
  delay_q_net_x1 <= sync_in;
  ahibhi <= mux1_y_net_x4;
  aloblo <= slr_q_net_x2;
  sync_out <= delay_q_net_x2;

  counter: entity work.counter_9b03e3d644
    port map (
      ce => ce_1_sg_x359,
      clk => clk_1_sg_x359,
      clr => '0',
      rst(0) => delay_q_net_x1,
      op(0) => counter_op_net
    );

  delay: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x359,
      clk => clk_1_sg_x359,
      d(0) => delay_q_net_x1,
      en => '1',
      q(0) => delay_q_net_x2
    );

  delay_b_ff8f0a7ac7: entity work.delay_b_entity_333926c402
    port map (
      ce_1 => ce_1_sg_x359,
      clk_1 => clk_1_sg_x359,
      in_x0 => mux1_y_net_x3,
      out_x0 => slr_q_net_x0
    );

  delay_lo_9987c068de: entity work.delay_b_entity_333926c402
    port map (
      ce_1 => ce_1_sg_x359,
      clk_1 => clk_1_sg_x359,
      in_x0 => mux_y_net_x0,
      out_x0 => slr_q_net_x2
    );

  mux: entity work.mux_22ce705a06
    port map (
      ce => ce_1_sg_x359,
      clk => clk_1_sg_x359,
      clr => '0',
      d0 => mux1_y_net_x2,
      d1 => slr_q_net_x0,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x0
    );

  mux1: entity work.mux_22ce705a06
    port map (
      ce => ce_1_sg_x359,
      clk => clk_1_sg_x359,
      clr => '0',
      d0 => slr_q_net_x0,
      d1 => mux1_y_net_x2,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x4
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 1,
      y_width => 1
    )
    port map (
      x(0) => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/quadplex_commutator/biplex_commutator_ac/delay_b"

entity delay_b_entity_38482719d8 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(33 downto 0); 
    out_x0: out std_logic_vector(33 downto 0)
  );
end delay_b_entity_38482719d8;

architecture structural of delay_b_entity_38482719d8 is
  signal ce_1_sg_x360: std_logic;
  signal clk_1_sg_x360: std_logic;
  signal concat_y_net_x29: std_logic_vector(33 downto 0);
  signal slr_q_net_x0: std_logic_vector(33 downto 0);

begin
  ce_1_sg_x360 <= ce_1;
  clk_1_sg_x360 <= clk_1;
  concat_y_net_x29 <= in_x0;
  out_x0 <= slr_q_net_x0;

  slr: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      width => 34
    )
    port map (
      ce => ce_1_sg_x360,
      clk => clk_1_sg_x360,
      d => concat_y_net_x29,
      en => '1',
      q => slr_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/quadplex_commutator/biplex_commutator_ac"

entity biplex_commutator_ac_entity_378fd9341a is
  port (
    aloahi: in std_logic_vector(33 downto 0); 
    blobhi: in std_logic_vector(33 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    ahibhi: out std_logic_vector(33 downto 0); 
    aloblo: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end biplex_commutator_ac_entity_378fd9341a;

architecture structural of biplex_commutator_ac_entity_378fd9341a is
  signal ce_1_sg_x362: std_logic;
  signal clk_1_sg_x362: std_logic;
  signal concat_y_net_x30: std_logic_vector(33 downto 0);
  signal concat_y_net_x31: std_logic_vector(33 downto 0);
  signal counter_op_net: std_logic_vector(1 downto 0);
  signal delay_q_net_x1: std_logic;
  signal delay_q_net_x23: std_logic;
  signal mux1_y_net_x3: std_logic_vector(33 downto 0);
  signal mux_y_net_x0: std_logic_vector(33 downto 0);
  signal slr_q_net_x0: std_logic_vector(33 downto 0);
  signal slr_q_net_x5: std_logic_vector(33 downto 0);
  signal top_bit_y_net: std_logic;

begin
  concat_y_net_x30 <= aloahi;
  concat_y_net_x31 <= blobhi;
  ce_1_sg_x362 <= ce_1;
  clk_1_sg_x362 <= clk_1;
  delay_q_net_x23 <= sync_in;
  ahibhi <= mux1_y_net_x3;
  aloblo <= slr_q_net_x5;
  sync_out <= delay_q_net_x1;

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_76ea00975735b561",
      op_arith => xlUnsigned,
      op_width => 2
    )
    port map (
      ce => ce_1_sg_x362,
      clk => clk_1_sg_x362,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x23,
      op => counter_op_net
    );

  delay: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x362,
      clk => clk_1_sg_x362,
      d(0) => delay_q_net_x23,
      en => '1',
      q(0) => delay_q_net_x1
    );

  delay_b_38482719d8: entity work.delay_b_entity_38482719d8
    port map (
      ce_1 => ce_1_sg_x362,
      clk_1 => clk_1_sg_x362,
      in_x0 => concat_y_net_x31,
      out_x0 => slr_q_net_x0
    );

  delay_lo_7c6666e9e7: entity work.delay_b_entity_38482719d8
    port map (
      ce_1 => ce_1_sg_x362,
      clk_1 => clk_1_sg_x362,
      in_x0 => mux_y_net_x0,
      out_x0 => slr_q_net_x5
    );

  mux: entity work.mux_22ce705a06
    port map (
      ce => ce_1_sg_x362,
      clk => clk_1_sg_x362,
      clr => '0',
      d0 => concat_y_net_x30,
      d1 => slr_q_net_x0,
      sel(0) => top_bit_y_net,
      y => mux_y_net_x0
    );

  mux1: entity work.mux_22ce705a06
    port map (
      ce => ce_1_sg_x362,
      clk => clk_1_sg_x362,
      clr => '0',
      d0 => slr_q_net_x0,
      d1 => concat_y_net_x30,
      sel(0) => top_bit_y_net,
      y => mux1_y_net_x3
    );

  top_bit: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 2,
      y_width => 1
    )
    port map (
      x => counter_op_net,
      y(0) => top_bit_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/quadplex_commutator"

entity quadplex_commutator_entity_d78550bc5d is
  port (
    a: in std_logic_vector(33 downto 0); 
    b: in std_logic_vector(33 downto 0); 
    c: in std_logic_vector(33 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(33 downto 0); 
    sync_in: in std_logic; 
    abcd0: out std_logic_vector(33 downto 0); 
    abcd1: out std_logic_vector(33 downto 0); 
    abcd2: out std_logic_vector(33 downto 0); 
    abcd3: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end quadplex_commutator_entity_d78550bc5d;

architecture structural of quadplex_commutator_entity_d78550bc5d is
  signal ce_1_sg_x366: std_logic;
  signal clk_1_sg_x366: std_logic;
  signal concat_y_net_x34: std_logic_vector(33 downto 0);
  signal concat_y_net_x35: std_logic_vector(33 downto 0);
  signal concat_y_net_x36: std_logic_vector(33 downto 0);
  signal concat_y_net_x37: std_logic_vector(33 downto 0);
  signal delay_q_net_x1: std_logic;
  signal delay_q_net_x25: std_logic;
  signal delay_q_net_x3: std_logic;
  signal delay_q_net_x4: std_logic;
  signal mux1_y_net_x3: std_logic_vector(33 downto 0);
  signal mux1_y_net_x5: std_logic_vector(33 downto 0);
  signal mux1_y_net_x6: std_logic_vector(33 downto 0);
  signal mux1_y_net_x7: std_logic_vector(33 downto 0);
  signal slr_q_net_x6: std_logic_vector(33 downto 0);
  signal slr_q_net_x7: std_logic_vector(33 downto 0);
  signal slr_q_net_x8: std_logic_vector(33 downto 0);
  signal slr_q_net_x9: std_logic_vector(33 downto 0);

begin
  concat_y_net_x34 <= a;
  concat_y_net_x35 <= b;
  concat_y_net_x36 <= c;
  ce_1_sg_x366 <= ce_1;
  clk_1_sg_x366 <= clk_1;
  concat_y_net_x37 <= d;
  delay_q_net_x25 <= sync_in;
  abcd0 <= slr_q_net_x8;
  abcd1 <= mux1_y_net_x6;
  abcd2 <= slr_q_net_x9;
  abcd3 <= mux1_y_net_x7;
  sync_out <= delay_q_net_x4;

  biplex_commutator_01_aa2e066db0: entity work.biplex_commutator_01_entity_aa2e066db0
    port map (
      aloahi => slr_q_net_x6,
      blobhi => slr_q_net_x7,
      ce_1 => ce_1_sg_x366,
      clk_1 => clk_1_sg_x366,
      sync_in => delay_q_net_x1,
      ahibhi => mux1_y_net_x6,
      aloblo => slr_q_net_x8
    );

  biplex_commutator_23_4f62580056: entity work.biplex_commutator_23_entity_4f62580056
    port map (
      aloahi => mux1_y_net_x3,
      blobhi => mux1_y_net_x5,
      ce_1 => ce_1_sg_x366,
      clk_1 => clk_1_sg_x366,
      sync_in => delay_q_net_x3,
      ahibhi => mux1_y_net_x7,
      aloblo => slr_q_net_x9,
      sync_out => delay_q_net_x4
    );

  biplex_commutator_ac_378fd9341a: entity work.biplex_commutator_ac_entity_378fd9341a
    port map (
      aloahi => concat_y_net_x34,
      blobhi => concat_y_net_x36,
      ce_1 => ce_1_sg_x366,
      clk_1 => clk_1_sg_x366,
      sync_in => delay_q_net_x25,
      ahibhi => mux1_y_net_x3,
      aloblo => slr_q_net_x6,
      sync_out => delay_q_net_x1
    );

  biplex_commutator_bd_e182027a9d: entity work.biplex_commutator_ac_entity_378fd9341a
    port map (
      aloahi => concat_y_net_x35,
      blobhi => concat_y_net_x37,
      ce_1 => ce_1_sg_x366,
      clk_1 => clk_1_sg_x366,
      sync_in => delay_q_net_x25,
      ahibhi => mux1_y_net_x5,
      aloblo => slr_q_net_x7,
      sync_out => delay_q_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/r4_butterfly/butterfly0/c_to_ri"

entity c_to_ri_entity_1bbe6e78b8 is
  port (
    c: in std_logic_vector(33 downto 0); 
    im: out std_logic_vector(16 downto 0); 
    re: out std_logic_vector(16 downto 0)
  );
end c_to_ri_entity_1bbe6e78b8;

architecture structural of c_to_ri_entity_1bbe6e78b8 is
  signal delay1_q_net_x0: std_logic_vector(33 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(16 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(16 downto 0);
  signal slice_im_y_net: std_logic_vector(16 downto 0);
  signal slice_re_y_net: std_logic_vector(16 downto 0);

begin
  delay1_q_net_x0 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_ea71bb555c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_ea71bb555c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 16,
      x_width => 34,
      y_width => 17
    )
    port map (
      x => delay1_q_net_x0,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 17,
      new_msb => 33,
      x_width => 34,
      y_width => 17
    )
    port map (
      x => delay1_q_net_x0,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/r4_butterfly/butterfly0/ri_to_c"

entity ri_to_c_entity_cedf3c063c is
  port (
    im: in std_logic_vector(17 downto 0); 
    re: in std_logic_vector(17 downto 0); 
    c: out std_logic_vector(35 downto 0)
  );
end ri_to_c_entity_cedf3c063c;

architecture structural of ri_to_c_entity_cedf3c063c is
  signal concat_y_net_x0: std_logic_vector(35 downto 0);
  signal force_im_output_port_net: std_logic_vector(17 downto 0);
  signal force_re_output_port_net: std_logic_vector(17 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(17 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(17 downto 0);

begin
  requant1_dout_net_x0 <= im;
  requant0_dout_net_x0 <= re;
  c <= concat_y_net_x0;

  concat: entity work.concat_b198bd62b0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x0
    );

  force_im: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant1_dout_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => requant0_dout_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/r4_butterfly/butterfly0"

entity butterfly0_entity_933d7106fd is
  port (
    a: in std_logic_vector(33 downto 0); 
    b: in std_logic_vector(33 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    a_b: out std_logic_vector(35 downto 0); 
    a_b_x0: out std_logic_vector(35 downto 0)
  );
end butterfly0_entity_933d7106fd;

architecture structural of butterfly0_entity_933d7106fd is
  signal add_im_s_net: std_logic_vector(17 downto 0);
  signal add_re_s_net: std_logic_vector(17 downto 0);
  signal ce_1_sg_x367: std_logic;
  signal clk_1_sg_x367: std_logic;
  signal concat_y_net_x3: std_logic_vector(33 downto 0);
  signal concat_y_net_x4: std_logic_vector(35 downto 0);
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal delay1_q_net_x1: std_logic_vector(33 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(16 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(16 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(16 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(16 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(17 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(17 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(17 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(17 downto 0);
  signal shift0_op_net: std_logic_vector(17 downto 0);
  signal shift1_op_net: std_logic_vector(17 downto 0);
  signal shift2_op_net: std_logic_vector(17 downto 0);
  signal shift3_op_net: std_logic_vector(17 downto 0);
  signal sub_im_s_net: std_logic_vector(17 downto 0);
  signal sub_re_s_net: std_logic_vector(17 downto 0);

begin
  delay1_q_net_x1 <= a;
  concat_y_net_x3 <= b;
  ce_1_sg_x367 <= ce_1;
  clk_1_sg_x367 <= clk_1;
  a_b <= concat_y_net_x4;
  a_b_x0 <= concat_y_net_x5;

  add_im: entity work.addsub_ed5d62a19c
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x367,
      clk => clk_1_sg_x367,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_ed5d62a19c
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x367,
      clk => clk_1_sg_x367,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_d78a36069f: entity work.c_to_ri_entity_1bbe6e78b8
    port map (
      c => concat_y_net_x3,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_1bbe6e78b8: entity work.c_to_ri_entity_1bbe6e78b8
    port map (
      c => delay1_q_net_x1,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 18,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 18,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 18,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 18,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 18,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 18,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 18,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 18,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_3dbf498c82: entity work.ri_to_c_entity_cedf3c063c
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x5
    );

  ri_to_c_cedf3c063c: entity work.ri_to_c_entity_cedf3c063c
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x4
    );

  shift0: entity work.scale_1768584a8d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_1768584a8d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_1768584a8d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_1768584a8d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_cc9a7f7bbc
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x367,
      clk => clk_1_sg_x367,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_cc9a7f7bbc
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x367,
      clk => clk_1_sg_x367,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/r4_butterfly/butterfly1"

entity butterfly1_entity_0243493c71 is
  port (
    a: in std_logic_vector(33 downto 0); 
    b: in std_logic_vector(33 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    a_b: out std_logic_vector(35 downto 0); 
    a_b_x0: out std_logic_vector(35 downto 0); 
    sync_out: out std_logic
  );
end butterfly1_entity_0243493c71;

architecture structural of butterfly1_entity_0243493c71 is
  signal add_im_s_net: std_logic_vector(17 downto 0);
  signal add_re_s_net: std_logic_vector(17 downto 0);
  signal ce_1_sg_x368: std_logic;
  signal clk_1_sg_x368: std_logic;
  signal concat_y_net_x4: std_logic_vector(33 downto 0);
  signal concat_y_net_x5: std_logic_vector(33 downto 0);
  signal concat_y_net_x6: std_logic_vector(35 downto 0);
  signal concat_y_net_x7: std_logic_vector(35 downto 0);
  signal delay_q_net_x1: std_logic;
  signal delay_q_net_x2: std_logic;
  signal force_im_output_port_net_x0: std_logic_vector(16 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(16 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(16 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(16 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(17 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(17 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(17 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(17 downto 0);
  signal shift0_op_net: std_logic_vector(17 downto 0);
  signal shift1_op_net: std_logic_vector(17 downto 0);
  signal shift2_op_net: std_logic_vector(17 downto 0);
  signal shift3_op_net: std_logic_vector(17 downto 0);
  signal sub_im_s_net: std_logic_vector(17 downto 0);
  signal sub_re_s_net: std_logic_vector(17 downto 0);

begin
  concat_y_net_x4 <= a;
  concat_y_net_x5 <= b;
  ce_1_sg_x368 <= ce_1;
  clk_1_sg_x368 <= clk_1;
  delay_q_net_x1 <= sync_in;
  a_b <= concat_y_net_x6;
  a_b_x0 <= concat_y_net_x7;
  sync_out <= delay_q_net_x2;

  add_im: entity work.addsub_ed5d62a19c
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x368,
      clk => clk_1_sg_x368,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_ed5d62a19c
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x368,
      clk => clk_1_sg_x368,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_e7f292dae8: entity work.c_to_ri_entity_1bbe6e78b8
    port map (
      c => concat_y_net_x5,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_ccffbf7b86: entity work.c_to_ri_entity_1bbe6e78b8
    port map (
      c => concat_y_net_x4,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x368,
      clk => clk_1_sg_x368,
      d(0) => delay_q_net_x1,
      en => '1',
      q(0) => delay_q_net_x2
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 18,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 18,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 18,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 18,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 18,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 18,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 18,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 18,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_c4fe9966ce: entity work.ri_to_c_entity_cedf3c063c
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x7
    );

  ri_to_c_989f7eec0e: entity work.ri_to_c_entity_cedf3c063c
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x6
    );

  shift0: entity work.scale_1768584a8d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_1768584a8d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_1768584a8d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_1768584a8d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_cc9a7f7bbc
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x368,
      clk => clk_1_sg_x368,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_cc9a7f7bbc
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x368,
      clk => clk_1_sg_x368,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/r4_butterfly/butterfly2/c_to_ri"

entity c_to_ri_entity_c19f9d131d is
  port (
    c: in std_logic_vector(35 downto 0); 
    im: out std_logic_vector(17 downto 0); 
    re: out std_logic_vector(17 downto 0)
  );
end c_to_ri_entity_c19f9d131d;

architecture structural of c_to_ri_entity_c19f9d131d is
  signal concat_y_net_x5: std_logic_vector(35 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(17 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(17 downto 0);
  signal slice_im_y_net: std_logic_vector(17 downto 0);
  signal slice_re_y_net: std_logic_vector(17 downto 0);

begin
  concat_y_net_x5 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 36,
      y_width => 18
    )
    port map (
      x => concat_y_net_x5,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 18,
      new_msb => 35,
      x_width => 36,
      y_width => 18
    )
    port map (
      x => concat_y_net_x5,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/r4_butterfly/butterfly2"

entity butterfly2_entity_0ba5dcbedc is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    a_b: out std_logic_vector(37 downto 0); 
    a_b_x0: out std_logic_vector(37 downto 0)
  );
end butterfly2_entity_0ba5dcbedc;

architecture structural of butterfly2_entity_0ba5dcbedc is
  signal add_im_s_net: std_logic_vector(18 downto 0);
  signal add_re_s_net: std_logic_vector(18 downto 0);
  signal ce_1_sg_x369: std_logic;
  signal clk_1_sg_x369: std_logic;
  signal concat_y_net_x11: std_logic_vector(35 downto 0);
  signal concat_y_net_x12: std_logic_vector(37 downto 0);
  signal concat_y_net_x16: std_logic_vector(37 downto 0);
  signal concat_y_net_x6: std_logic_vector(35 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(17 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(17 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(17 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(17 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(18 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(18 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(18 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(18 downto 0);
  signal shift0_op_net: std_logic_vector(18 downto 0);
  signal shift1_op_net: std_logic_vector(18 downto 0);
  signal shift2_op_net: std_logic_vector(18 downto 0);
  signal shift3_op_net: std_logic_vector(18 downto 0);
  signal sub_im_s_net: std_logic_vector(18 downto 0);
  signal sub_re_s_net: std_logic_vector(18 downto 0);

begin
  concat_y_net_x6 <= a;
  concat_y_net_x11 <= b;
  ce_1_sg_x369 <= ce_1;
  clk_1_sg_x369 <= clk_1;
  a_b <= concat_y_net_x12;
  a_b_x0 <= concat_y_net_x16;

  add_im: entity work.addsub_f10bd79bfe
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x369,
      clk => clk_1_sg_x369,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_f10bd79bfe
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x369,
      clk => clk_1_sg_x369,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_a5818fc9cb: entity work.c_to_ri_entity_c19f9d131d
    port map (
      c => concat_y_net_x11,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_c19f9d131d: entity work.c_to_ri_entity_c19f9d131d
    port map (
      c => concat_y_net_x6,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 19,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 19,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 19,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 19,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 19,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 19,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 19,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 19,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_9866e25a0b: entity work.ri_to_c_entity_b3a6a3c041
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x16
    );

  ri_to_c_cfd2a6ed55: entity work.ri_to_c_entity_b3a6a3c041
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x12
    );

  shift0: entity work.scale_9f61027ba4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_9f61027ba4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_9f61027ba4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_9f61027ba4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_f5776ffb7e
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x369,
      clk => clk_1_sg_x369,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_f5776ffb7e
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x369,
      clk => clk_1_sg_x369,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/r4_butterfly/butterfly3j"

entity butterfly3j_entity_2af76feb3d is
  port (
    a: in std_logic_vector(35 downto 0); 
    b: in std_logic_vector(35 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    a_b: out std_logic_vector(37 downto 0); 
    a_b_x0: out std_logic_vector(37 downto 0); 
    sync_out: out std_logic
  );
end butterfly3j_entity_2af76feb3d;

architecture structural of butterfly3j_entity_2af76feb3d is
  signal add_im_s_net: std_logic_vector(18 downto 0);
  signal add_re_s_net: std_logic_vector(18 downto 0);
  signal ce_1_sg_x370: std_logic;
  signal clk_1_sg_x370: std_logic;
  signal concat_y_net_x13: std_logic_vector(35 downto 0);
  signal concat_y_net_x14: std_logic_vector(37 downto 0);
  signal concat_y_net_x15: std_logic_vector(37 downto 0);
  signal concat_y_net_x7: std_logic_vector(35 downto 0);
  signal delay_q_net_x3: std_logic;
  signal delay_q_net_x7: std_logic;
  signal force_im_output_port_net_x0: std_logic_vector(17 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(17 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(17 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(17 downto 0);
  signal requant0_dout_net_x0: std_logic_vector(18 downto 0);
  signal requant1_dout_net_x0: std_logic_vector(18 downto 0);
  signal requant2_dout_net_x0: std_logic_vector(18 downto 0);
  signal requant3_dout_net_x0: std_logic_vector(18 downto 0);
  signal shift0_op_net: std_logic_vector(18 downto 0);
  signal shift1_op_net: std_logic_vector(18 downto 0);
  signal shift2_op_net: std_logic_vector(18 downto 0);
  signal shift3_op_net: std_logic_vector(18 downto 0);
  signal sub_im_s_net: std_logic_vector(18 downto 0);
  signal sub_re_s_net: std_logic_vector(18 downto 0);

begin
  concat_y_net_x7 <= a;
  concat_y_net_x13 <= b;
  ce_1_sg_x370 <= ce_1;
  clk_1_sg_x370 <= clk_1;
  delay_q_net_x3 <= sync_in;
  a_b <= concat_y_net_x14;
  a_b_x0 <= concat_y_net_x15;
  sync_out <= delay_q_net_x7;

  add_im: entity work.addsub_f5776ffb7e
    port map (
      a => force_im_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x370,
      clk => clk_1_sg_x370,
      clr => '0',
      s => add_im_s_net
    );

  add_re: entity work.addsub_f10bd79bfe
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x370,
      clk => clk_1_sg_x370,
      clr => '0',
      s => add_re_s_net
    );

  c_to_ri1_0b5a2d4f21: entity work.c_to_ri_entity_c19f9d131d
    port map (
      c => concat_y_net_x13,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_4d75e6fc64: entity work.c_to_ri_entity_c19f9d131d
    port map (
      c => concat_y_net_x7,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x370,
      clk => clk_1_sg_x370,
      d(0) => delay_q_net_x3,
      en => '1',
      q(0) => delay_q_net_x7
    );

  requant0: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 19,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 19,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift0_op_net,
      dout => requant0_dout_net_x0
    );

  requant1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 19,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 19,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift1_op_net,
      dout => requant1_dout_net_x0
    );

  requant2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 19,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 19,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift2_op_net,
      dout => requant2_dout_net_x0
    );

  requant3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 19,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 19,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => shift3_op_net,
      dout => requant3_dout_net_x0
    );

  ri_to_c1_9294dd1b38: entity work.ri_to_c_entity_b3a6a3c041
    port map (
      im => requant3_dout_net_x0,
      re => requant2_dout_net_x0,
      c => concat_y_net_x15
    );

  ri_to_c_b69f8abefb: entity work.ri_to_c_entity_b3a6a3c041
    port map (
      im => requant1_dout_net_x0,
      re => requant0_dout_net_x0,
      c => concat_y_net_x14
    );

  shift0: entity work.scale_9f61027ba4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_re_s_net,
      op => shift0_op_net
    );

  shift1: entity work.scale_9f61027ba4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => add_im_s_net,
      op => shift1_op_net
    );

  shift2: entity work.scale_9f61027ba4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_re_s_net,
      op => shift2_op_net
    );

  shift3: entity work.scale_9f61027ba4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      ip => sub_im_s_net,
      op => shift3_op_net
    );

  sub_im: entity work.addsub_f10bd79bfe
    port map (
      a => force_im_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x370,
      clk => clk_1_sg_x370,
      clr => '0',
      s => sub_im_s_net
    );

  sub_re: entity work.addsub_f5776ffb7e
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x370,
      clk => clk_1_sg_x370,
      clr => '0',
      s => sub_re_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/r4_butterfly"

entity r4_butterfly_entity_26888c8657 is
  port (
    a_in: in std_logic_vector(33 downto 0); 
    b_in: in std_logic_vector(33 downto 0); 
    c_in: in std_logic_vector(33 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d_in: in std_logic_vector(33 downto 0); 
    sync_in: in std_logic; 
    a_out: out std_logic_vector(37 downto 0); 
    b_out: out std_logic_vector(37 downto 0); 
    c_out: out std_logic_vector(37 downto 0); 
    d_out: out std_logic_vector(37 downto 0); 
    sync_out: out std_logic
  );
end r4_butterfly_entity_26888c8657;

architecture structural of r4_butterfly_entity_26888c8657 is
  signal ce_1_sg_x371: std_logic;
  signal clk_1_sg_x371: std_logic;
  signal concat_y_net_x11: std_logic_vector(35 downto 0);
  signal concat_y_net_x13: std_logic_vector(35 downto 0);
  signal concat_y_net_x17: std_logic_vector(33 downto 0);
  signal concat_y_net_x18: std_logic_vector(33 downto 0);
  signal concat_y_net_x19: std_logic_vector(37 downto 0);
  signal concat_y_net_x20: std_logic_vector(37 downto 0);
  signal concat_y_net_x21: std_logic_vector(37 downto 0);
  signal concat_y_net_x22: std_logic_vector(37 downto 0);
  signal concat_y_net_x6: std_logic_vector(35 downto 0);
  signal concat_y_net_x7: std_logic_vector(35 downto 0);
  signal concat_y_net_x8: std_logic_vector(33 downto 0);
  signal delay1_q_net_x2: std_logic_vector(33 downto 0);
  signal delay_q_net_x2: std_logic;
  signal delay_q_net_x3: std_logic;
  signal delay_q_net_x8: std_logic;

begin
  delay1_q_net_x2 <= a_in;
  concat_y_net_x17 <= b_in;
  concat_y_net_x8 <= c_in;
  ce_1_sg_x371 <= ce_1;
  clk_1_sg_x371 <= clk_1;
  concat_y_net_x18 <= d_in;
  delay_q_net_x2 <= sync_in;
  a_out <= concat_y_net_x19;
  b_out <= concat_y_net_x20;
  c_out <= concat_y_net_x21;
  d_out <= concat_y_net_x22;
  sync_out <= delay_q_net_x8;

  butterfly0_933d7106fd: entity work.butterfly0_entity_933d7106fd
    port map (
      a => delay1_q_net_x2,
      b => concat_y_net_x8,
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      a_b => concat_y_net_x6,
      a_b_x0 => concat_y_net_x7
    );

  butterfly1_0243493c71: entity work.butterfly1_entity_0243493c71
    port map (
      a => concat_y_net_x17,
      b => concat_y_net_x18,
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      sync_in => delay_q_net_x2,
      a_b => concat_y_net_x11,
      a_b_x0 => concat_y_net_x13,
      sync_out => delay_q_net_x3
    );

  butterfly2_0ba5dcbedc: entity work.butterfly2_entity_0ba5dcbedc
    port map (
      a => concat_y_net_x6,
      b => concat_y_net_x11,
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      a_b => concat_y_net_x19,
      a_b_x0 => concat_y_net_x20
    );

  butterfly3j_2af76feb3d: entity work.butterfly3j_entity_2af76feb3d
    port map (
      a => concat_y_net_x7,
      b => concat_y_net_x13,
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      sync_in => delay_q_net_x3,
      a_b => concat_y_net_x21,
      a_b_x0 => concat_y_net_x22,
      sync_out => delay_q_net_x8
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/r4_twiddle/cmpy1/c_to_ri"

entity c_to_ri_entity_d18766a8ff is
  port (
    c: in std_logic_vector(33 downto 0); 
    im: out std_logic_vector(16 downto 0); 
    re: out std_logic_vector(16 downto 0)
  );
end c_to_ri_entity_d18766a8ff;

architecture structural of c_to_ri_entity_d18766a8ff is
  signal delay1_q_net_x0: std_logic_vector(33 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(16 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(16 downto 0);
  signal slice_im_y_net: std_logic_vector(16 downto 0);
  signal slice_re_y_net: std_logic_vector(16 downto 0);

begin
  delay1_q_net_x0 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_ea71bb555c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_ea71bb555c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 16,
      x_width => 34,
      y_width => 17
    )
    port map (
      x => delay1_q_net_x0,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 17,
      new_msb => 33,
      x_width => 34,
      y_width => 17
    )
    port map (
      x => delay1_q_net_x0,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/r4_twiddle/cmpy1/ri_to_c"

entity ri_to_c_entity_8c65311040 is
  port (
    im: in std_logic_vector(16 downto 0); 
    re: in std_logic_vector(16 downto 0); 
    c: out std_logic_vector(33 downto 0)
  );
end ri_to_c_entity_8c65311040;

architecture structural of ri_to_c_entity_8c65311040 is
  signal concat_y_net_x18: std_logic_vector(33 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(16 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(16 downto 0);
  signal force_im_output_port_net: std_logic_vector(16 downto 0);
  signal force_re_output_port_net: std_logic_vector(16 downto 0);

begin
  convert_im_dout_net_x0 <= im;
  convert_re_dout_net_x0 <= re;
  c <= concat_y_net_x18;

  concat: entity work.concat_25b7e1d1f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x18
    );

  force_im: entity work.reinterpret_573890e1c0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert_im_dout_net_x0,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_573890e1c0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert_re_dout_net_x0,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/r4_twiddle/cmpy1"

entity cmpy1_entity_26dbc807fe is
  port (
    a_in: in std_logic_vector(33 downto 0); 
    b: in std_logic_vector(33 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    w: in std_logic_vector(17 downto 0); 
    a_out: out std_logic_vector(33 downto 0); 
    bw: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end cmpy1_entity_26dbc807fe;

architecture structural of cmpy1_entity_26dbc807fe is
  signal br_add_bi_s_net: std_logic_vector(17 downto 0);
  signal ce_1_sg_x372: std_logic;
  signal clk_1_sg_x372: std_logic;
  signal concat_y_net_x19: std_logic_vector(33 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(16 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(16 downto 0);
  signal delay1_q_net_x1: std_logic_vector(33 downto 0);
  signal delay1_q_net_x3: std_logic_vector(33 downto 0);
  signal delay2_q_net_x0: std_logic_vector(33 downto 0);
  signal delay3_q_net_x0: std_logic;
  signal delay_q_net_x3: std_logic;
  signal force_im_output_port_net_x0: std_logic_vector(16 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(8 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(16 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(8 downto 0);
  signal imim_p_net: std_logic_vector(23 downto 0);
  signal mem_c_data_net_x1: std_logic_vector(17 downto 0);
  signal rere_p_net: std_logic_vector(23 downto 0);
  signal rr_add_ii_s_net: std_logic_vector(23 downto 0);
  signal rr_sub_ii_s_net: std_logic_vector(23 downto 0);
  signal ss_sub_rrii_s_net: std_logic_vector(23 downto 0);
  signal sumsum_p_net: std_logic_vector(23 downto 0);
  signal wr_add_wi_s_net: std_logic_vector(9 downto 0);

begin
  delay2_q_net_x0 <= a_in;
  delay1_q_net_x1 <= b;
  ce_1_sg_x372 <= ce_1;
  clk_1_sg_x372 <= clk_1;
  delay3_q_net_x0 <= sync_in;
  mem_c_data_net_x1 <= w;
  a_out <= delay1_q_net_x3;
  bw <= concat_y_net_x19;
  sync_out <= delay_q_net_x3;

  br_add_bi: entity work.addsub_555b5d0c45
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x0,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      s => br_add_bi_s_net
    );

  c_to_ri1_a54cb4e736: entity work.c_to_ri1_entity_7fe674c156
    port map (
      c => mem_c_data_net_x1,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_d18766a8ff: entity work.c_to_ri_entity_d18766a8ff
    port map (
      c => delay1_q_net_x1,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  convert_im: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 23,
      din_width => 24,
      dout_arith => 2,
      dout_bin_pt => 16,
      dout_width => 17,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      din => ss_sub_rrii_s_net,
      dout => convert_im_dout_net_x0
    );

  convert_re: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 23,
      din_width => 24,
      dout_arith => 2,
      dout_bin_pt => 16,
      dout_width => 17,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      din => rr_sub_ii_s_net,
      dout => convert_re_dout_net_x0
    );

  delay: entity work.xldelay
    generic map (
      latency => 8,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      d(0) => delay3_q_net_x0,
      en => '1',
      q(0) => delay_q_net_x3
    );

  delay1: entity work.xldelay
    generic map (
      latency => 8,
      reg_retiming => 0,
      width => 34
    )
    port map (
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      d => delay2_q_net_x0,
      en => '1',
      q => delay1_q_net_x3
    );

  imim: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 16,
      a_width => 17,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 17,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 17,
      c_output_width => 26,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_db7246963acedc92",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 23,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      core_ce => ce_1_sg_x372,
      core_clk => clk_1_sg_x372,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => imim_p_net
    );

  rere: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 16,
      a_width => 17,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 17,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 17,
      c_output_width => 26,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_db7246963acedc92",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 23,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      core_ce => ce_1_sg_x372,
      core_clk => clk_1_sg_x372,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => rere_p_net
    );

  ri_to_c_8c65311040: entity work.ri_to_c_entity_8c65311040
    port map (
      im => convert_im_dout_net_x0,
      re => convert_re_dout_net_x0,
      c => concat_y_net_x19
    );

  rr_add_ii: entity work.addsub_a90e22f5f3
    port map (
      a => imim_p_net,
      b => rere_p_net,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      s => rr_add_ii_s_net
    );

  rr_sub_ii: entity work.addsub_0b3c6c31ef
    port map (
      a => rere_p_net,
      b => imim_p_net,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      s => rr_sub_ii_s_net
    );

  ss_sub_rrii: entity work.addsub_50f49c147d
    port map (
      a => sumsum_p_net,
      b => rr_add_ii_s_net,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      s => ss_sub_rrii_s_net
    );

  sumsum: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 16,
      a_width => 18,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 10,
      c_a_type => 0,
      c_a_width => 18,
      c_b_type => 0,
      c_b_width => 10,
      c_baat => 18,
      c_output_width => 28,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_34b4d3fe22ca9845",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 23,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => br_add_bi_s_net,
      b => wr_add_wi_s_net,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      core_ce => ce_1_sg_x372,
      core_clk => clk_1_sg_x372,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => sumsum_p_net
    );

  wr_add_wi: entity work.addsub_bd2bd198b1
    port map (
      a => force_re_output_port_net_x1,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      s => wr_add_wi_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/r4_twiddle/cmpy2"

entity cmpy2_entity_723418a7ae is
  port (
    b: in std_logic_vector(33 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    w: in std_logic_vector(17 downto 0); 
    bw: out std_logic_vector(33 downto 0)
  );
end cmpy2_entity_723418a7ae;

architecture structural of cmpy2_entity_723418a7ae is
  signal br_add_bi_s_net: std_logic_vector(17 downto 0);
  signal ce_1_sg_x373: std_logic;
  signal clk_1_sg_x373: std_logic;
  signal concat_y_net_x10: std_logic_vector(33 downto 0);
  signal convert_im_dout_net_x0: std_logic_vector(16 downto 0);
  signal convert_re_dout_net_x0: std_logic_vector(16 downto 0);
  signal delay4_q_net_x1: std_logic_vector(33 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(16 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(8 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(16 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(8 downto 0);
  signal imim_p_net: std_logic_vector(23 downto 0);
  signal mem_c_data_net_x1: std_logic_vector(17 downto 0);
  signal rere_p_net: std_logic_vector(23 downto 0);
  signal rr_add_ii_s_net: std_logic_vector(23 downto 0);
  signal rr_sub_ii_s_net: std_logic_vector(23 downto 0);
  signal ss_sub_rrii_s_net: std_logic_vector(23 downto 0);
  signal sumsum_p_net: std_logic_vector(23 downto 0);
  signal wr_add_wi_s_net: std_logic_vector(9 downto 0);

begin
  delay4_q_net_x1 <= b;
  ce_1_sg_x373 <= ce_1;
  clk_1_sg_x373 <= clk_1;
  mem_c_data_net_x1 <= w;
  bw <= concat_y_net_x10;

  br_add_bi: entity work.addsub_555b5d0c45
    port map (
      a => force_re_output_port_net_x0,
      b => force_im_output_port_net_x0,
      ce => ce_1_sg_x373,
      clk => clk_1_sg_x373,
      clr => '0',
      s => br_add_bi_s_net
    );

  c_to_ri1_cfda1952bd: entity work.c_to_ri1_entity_7fe674c156
    port map (
      c => mem_c_data_net_x1,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  c_to_ri_30ee1941cb: entity work.c_to_ri_entity_d18766a8ff
    port map (
      c => delay4_q_net_x1,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  convert_im: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 23,
      din_width => 24,
      dout_arith => 2,
      dout_bin_pt => 16,
      dout_width => 17,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x373,
      clk => clk_1_sg_x373,
      clr => '0',
      din => ss_sub_rrii_s_net,
      dout => convert_im_dout_net_x0
    );

  convert_re: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 23,
      din_width => 24,
      dout_arith => 2,
      dout_bin_pt => 16,
      dout_width => 17,
      latency => 3,
      overflow => xlWrap,
      quantization => xlRoundBanker
    )
    port map (
      ce => ce_1_sg_x373,
      clk => clk_1_sg_x373,
      clr => '0',
      din => rr_sub_ii_s_net,
      dout => convert_re_dout_net_x0
    );

  imim: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 16,
      a_width => 17,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 17,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 17,
      c_output_width => 26,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_db7246963acedc92",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 23,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x373,
      clk => clk_1_sg_x373,
      clr => '0',
      core_ce => ce_1_sg_x373,
      core_clk => clk_1_sg_x373,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => imim_p_net
    );

  rere: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 16,
      a_width => 17,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 9,
      c_a_type => 0,
      c_a_width => 17,
      c_b_type => 0,
      c_b_width => 9,
      c_baat => 17,
      c_output_width => 26,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_db7246963acedc92",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 23,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x373,
      clk => clk_1_sg_x373,
      clr => '0',
      core_ce => ce_1_sg_x373,
      core_clk => clk_1_sg_x373,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => rere_p_net
    );

  ri_to_c_bfe54de313: entity work.ri_to_c_entity_8c65311040
    port map (
      im => convert_im_dout_net_x0,
      re => convert_re_dout_net_x0,
      c => concat_y_net_x10
    );

  rr_add_ii: entity work.addsub_a90e22f5f3
    port map (
      a => imim_p_net,
      b => rere_p_net,
      ce => ce_1_sg_x373,
      clk => clk_1_sg_x373,
      clr => '0',
      s => rr_add_ii_s_net
    );

  rr_sub_ii: entity work.addsub_0b3c6c31ef
    port map (
      a => rere_p_net,
      b => imim_p_net,
      ce => ce_1_sg_x373,
      clk => clk_1_sg_x373,
      clr => '0',
      s => rr_sub_ii_s_net
    );

  ss_sub_rrii: entity work.addsub_50f49c147d
    port map (
      a => sumsum_p_net,
      b => rr_add_ii_s_net,
      ce => ce_1_sg_x373,
      clk => clk_1_sg_x373,
      clr => '0',
      s => ss_sub_rrii_s_net
    );

  sumsum: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 16,
      a_width => 18,
      b_arith => xlSigned,
      b_bin_pt => 7,
      b_width => 10,
      c_a_type => 0,
      c_a_width => 18,
      c_b_type => 0,
      c_b_width => 10,
      c_baat => 18,
      c_output_width => 28,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_34b4d3fe22ca9845",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 23,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => br_add_bi_s_net,
      b => wr_add_wi_s_net,
      ce => ce_1_sg_x373,
      clk => clk_1_sg_x373,
      clr => '0',
      core_ce => ce_1_sg_x373,
      core_clk => clk_1_sg_x373,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => sumsum_p_net
    );

  wr_add_wi: entity work.addsub_bd2bd198b1
    port map (
      a => force_re_output_port_net_x1,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x373,
      clk => clk_1_sg_x373,
      clr => '0',
      s => wr_add_wi_s_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/r4_twiddle/twiddle_gen1"

entity twiddle_gen1_entity_2f4e4017fc is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    w: out std_logic_vector(17 downto 0)
  );
end twiddle_gen1_entity_2f4e4017fc;

architecture structural of twiddle_gen1_entity_2f4e4017fc is
  signal addr_sel_y_net: std_logic_vector(7 downto 0);
  signal ce_1_sg_x375: std_logic;
  signal clk_1_sg_x375: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay_q_net_x5: std_logic;
  signal mem_c_data_net_x2: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x375 <= ce_1;
  clk_1_sg_x375 <= clk_1;
  delay_q_net_x5 <= sync_in;
  w <= mem_c_data_net_x2;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 8,
      y_width => 8
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_01e34ae12479a5e1",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x375,
      clk => clk_1_sg_x375,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x5,
      op => counter_op_net
    );

  mem_c: entity work.xlsprom
    generic map (
      c_address_width => 8,
      c_width => 18,
      core_name0 => "bmg_24_vx5_462f2ec6a7a3f012",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x375,
      clk => clk_1_sg_x375,
      en => "1",
      rst => "0",
      data => mem_c_data_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/r4_twiddle/twiddle_gen2"

entity twiddle_gen2_entity_bd86017793 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    w: out std_logic_vector(17 downto 0)
  );
end twiddle_gen2_entity_bd86017793;

architecture structural of twiddle_gen2_entity_bd86017793 is
  signal addr_sel_y_net: std_logic_vector(7 downto 0);
  signal ce_1_sg_x376: std_logic;
  signal clk_1_sg_x376: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay_q_net_x6: std_logic;
  signal mem_c_data_net_x2: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x376 <= ce_1;
  clk_1_sg_x376 <= clk_1;
  delay_q_net_x6 <= sync_in;
  w <= mem_c_data_net_x2;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 8,
      y_width => 8
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_01e34ae12479a5e1",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x376,
      clk => clk_1_sg_x376,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x6,
      op => counter_op_net
    );

  mem_c: entity work.xlsprom
    generic map (
      c_address_width => 8,
      c_width => 18,
      core_name0 => "bmg_24_vx5_cee1e5321fc14302",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x376,
      clk => clk_1_sg_x376,
      en => "1",
      rst => "0",
      data => mem_c_data_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/r4_twiddle/twiddle_gen3"

entity twiddle_gen3_entity_ff724eec4e is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    sync_in: in std_logic; 
    w: out std_logic_vector(17 downto 0)
  );
end twiddle_gen3_entity_ff724eec4e;

architecture structural of twiddle_gen3_entity_ff724eec4e is
  signal addr_sel_y_net: std_logic_vector(7 downto 0);
  signal ce_1_sg_x377: std_logic;
  signal clk_1_sg_x377: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay_q_net_x7: std_logic;
  signal mem_c_data_net_x2: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x377 <= ce_1;
  clk_1_sg_x377 <= clk_1;
  delay_q_net_x7 <= sync_in;
  w <= mem_c_data_net_x2;

  addr_sel: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 8,
      y_width => 8
    )
    port map (
      x => counter_op_net,
      y => addr_sel_y_net
    );

  counter: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_01e34ae12479a5e1",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x377,
      clk => clk_1_sg_x377,
      clr => '0',
      en => "1",
      rst(0) => delay_q_net_x7,
      op => counter_op_net
    );

  mem_c: entity work.xlsprom
    generic map (
      c_address_width => 8,
      c_width => 18,
      core_name0 => "bmg_24_vx5_2c49e6ef11a51d10",
      latency => 1
    )
    port map (
      addr => addr_sel_y_net,
      ce => ce_1_sg_x377,
      clk => clk_1_sg_x377,
      en => "1",
      rst => "0",
      data => mem_c_data_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5/r4_twiddle"

entity r4_twiddle_entity_a297e404cd is
  port (
    a_in: in std_logic_vector(33 downto 0); 
    b: in std_logic_vector(33 downto 0); 
    c: in std_logic_vector(33 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(33 downto 0); 
    sync_in: in std_logic; 
    a_out: out std_logic_vector(33 downto 0); 
    bw: out std_logic_vector(33 downto 0); 
    cw: out std_logic_vector(33 downto 0); 
    dw: out std_logic_vector(33 downto 0); 
    sync_out: out std_logic
  );
end r4_twiddle_entity_a297e404cd;

architecture structural of r4_twiddle_entity_a297e404cd is
  signal ce_1_sg_x378: std_logic;
  signal clk_1_sg_x378: std_logic;
  signal concat_y_net_x11: std_logic_vector(33 downto 0);
  signal concat_y_net_x21: std_logic_vector(33 downto 0);
  signal concat_y_net_x22: std_logic_vector(33 downto 0);
  signal delay1_q_net_x1: std_logic_vector(33 downto 0);
  signal delay1_q_net_x4: std_logic_vector(33 downto 0);
  signal delay2_q_net_x0: std_logic_vector(33 downto 0);
  signal delay3_q_net_x0: std_logic;
  signal delay4_q_net_x1: std_logic_vector(33 downto 0);
  signal delay5_q_net_x1: std_logic_vector(33 downto 0);
  signal delay_q_net_x4: std_logic;
  signal delay_q_net_x8: std_logic;
  signal mem_c_data_net_x2: std_logic_vector(17 downto 0);
  signal mem_c_data_net_x3: std_logic_vector(17 downto 0);
  signal mem_c_data_net_x4: std_logic_vector(17 downto 0);
  signal mux1_y_net_x8: std_logic_vector(33 downto 0);
  signal mux1_y_net_x9: std_logic_vector(33 downto 0);
  signal slr_q_net_x10: std_logic_vector(33 downto 0);
  signal slr_q_net_x11: std_logic_vector(33 downto 0);

begin
  slr_q_net_x10 <= a_in;
  mux1_y_net_x8 <= b;
  slr_q_net_x11 <= c;
  ce_1_sg_x378 <= ce_1;
  clk_1_sg_x378 <= clk_1;
  mux1_y_net_x9 <= d;
  delay_q_net_x8 <= sync_in;
  a_out <= delay1_q_net_x4;
  bw <= concat_y_net_x21;
  cw <= concat_y_net_x11;
  dw <= concat_y_net_x22;
  sync_out <= delay_q_net_x4;

  cmpy1_26dbc807fe: entity work.cmpy1_entity_26dbc807fe
    port map (
      a_in => delay2_q_net_x0,
      b => delay1_q_net_x1,
      ce_1 => ce_1_sg_x378,
      clk_1 => clk_1_sg_x378,
      sync_in => delay3_q_net_x0,
      w => mem_c_data_net_x2,
      a_out => delay1_q_net_x4,
      bw => concat_y_net_x21,
      sync_out => delay_q_net_x4
    );

  cmpy2_723418a7ae: entity work.cmpy2_entity_723418a7ae
    port map (
      b => delay4_q_net_x1,
      ce_1 => ce_1_sg_x378,
      clk_1 => clk_1_sg_x378,
      w => mem_c_data_net_x3,
      bw => concat_y_net_x11
    );

  cmpy3_050c2401b1: entity work.cmpy2_entity_723418a7ae
    port map (
      b => delay5_q_net_x1,
      ce_1 => ce_1_sg_x378,
      clk_1 => clk_1_sg_x378,
      w => mem_c_data_net_x4,
      bw => concat_y_net_x22
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 34
    )
    port map (
      ce => ce_1_sg_x378,
      clk => clk_1_sg_x378,
      d => mux1_y_net_x8,
      en => '1',
      q => delay1_q_net_x1
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 34
    )
    port map (
      ce => ce_1_sg_x378,
      clk => clk_1_sg_x378,
      d => slr_q_net_x10,
      en => '1',
      q => delay2_q_net_x0
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x378,
      clk => clk_1_sg_x378,
      d(0) => delay_q_net_x8,
      en => '1',
      q(0) => delay3_q_net_x0
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 34
    )
    port map (
      ce => ce_1_sg_x378,
      clk => clk_1_sg_x378,
      d => slr_q_net_x11,
      en => '1',
      q => delay4_q_net_x1
    );

  delay5: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      width => 34
    )
    port map (
      ce => ce_1_sg_x378,
      clk => clk_1_sg_x378,
      d => mux1_y_net_x9,
      en => '1',
      q => delay5_q_net_x1
    );

  twiddle_gen1_2f4e4017fc: entity work.twiddle_gen1_entity_2f4e4017fc
    port map (
      ce_1 => ce_1_sg_x378,
      clk_1 => clk_1_sg_x378,
      sync_in => delay_q_net_x8,
      w => mem_c_data_net_x2
    );

  twiddle_gen2_bd86017793: entity work.twiddle_gen2_entity_bd86017793
    port map (
      ce_1 => ce_1_sg_x378,
      clk_1 => clk_1_sg_x378,
      sync_in => delay_q_net_x8,
      w => mem_c_data_net_x3
    );

  twiddle_gen3_ff724eec4e: entity work.twiddle_gen3_entity_ff724eec4e
    port map (
      ce_1 => ce_1_sg_x378,
      clk_1 => clk_1_sg_x378,
      sync_in => delay_q_net_x8,
      w => mem_c_data_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft/r4_dit_stage_5"

entity r4_dit_stage_5_entity_cf41b9127c is
  port (
    a_in: in std_logic_vector(33 downto 0); 
    b_in: in std_logic_vector(33 downto 0); 
    c_in: in std_logic_vector(33 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d_in: in std_logic_vector(33 downto 0); 
    sync_in: in std_logic; 
    a_out: out std_logic_vector(37 downto 0); 
    b_out: out std_logic_vector(37 downto 0); 
    c_out: out std_logic_vector(37 downto 0); 
    d_out: out std_logic_vector(37 downto 0); 
    sync_out: out std_logic
  );
end r4_dit_stage_5_entity_cf41b9127c;

architecture structural of r4_dit_stage_5_entity_cf41b9127c is
  signal ce_1_sg_x379: std_logic;
  signal clk_1_sg_x379: std_logic;
  signal concat_y_net_x11: std_logic_vector(33 downto 0);
  signal concat_y_net_x38: std_logic_vector(33 downto 0);
  signal concat_y_net_x39: std_logic_vector(33 downto 0);
  signal concat_y_net_x40: std_logic_vector(33 downto 0);
  signal concat_y_net_x41: std_logic_vector(33 downto 0);
  signal concat_y_net_x42: std_logic_vector(33 downto 0);
  signal concat_y_net_x43: std_logic_vector(33 downto 0);
  signal concat_y_net_x44: std_logic_vector(37 downto 0);
  signal concat_y_net_x45: std_logic_vector(37 downto 0);
  signal concat_y_net_x46: std_logic_vector(37 downto 0);
  signal concat_y_net_x47: std_logic_vector(37 downto 0);
  signal delay1_q_net_x4: std_logic_vector(33 downto 0);
  signal delay_q_net_x10: std_logic;
  signal delay_q_net_x26: std_logic;
  signal delay_q_net_x4: std_logic;
  signal delay_q_net_x8: std_logic;
  signal mux1_y_net_x8: std_logic_vector(33 downto 0);
  signal mux1_y_net_x9: std_logic_vector(33 downto 0);
  signal slr_q_net_x10: std_logic_vector(33 downto 0);
  signal slr_q_net_x11: std_logic_vector(33 downto 0);

begin
  concat_y_net_x40 <= a_in;
  concat_y_net_x41 <= b_in;
  concat_y_net_x42 <= c_in;
  ce_1_sg_x379 <= ce_1;
  clk_1_sg_x379 <= clk_1;
  concat_y_net_x43 <= d_in;
  delay_q_net_x26 <= sync_in;
  a_out <= concat_y_net_x44;
  b_out <= concat_y_net_x45;
  c_out <= concat_y_net_x46;
  d_out <= concat_y_net_x47;
  sync_out <= delay_q_net_x10;

  quadplex_commutator_d78550bc5d: entity work.quadplex_commutator_entity_d78550bc5d
    port map (
      a => concat_y_net_x40,
      b => concat_y_net_x41,
      c => concat_y_net_x42,
      ce_1 => ce_1_sg_x379,
      clk_1 => clk_1_sg_x379,
      d => concat_y_net_x43,
      sync_in => delay_q_net_x26,
      abcd0 => slr_q_net_x10,
      abcd1 => mux1_y_net_x8,
      abcd2 => slr_q_net_x11,
      abcd3 => mux1_y_net_x9,
      sync_out => delay_q_net_x8
    );

  r4_butterfly_26888c8657: entity work.r4_butterfly_entity_26888c8657
    port map (
      a_in => delay1_q_net_x4,
      b_in => concat_y_net_x38,
      c_in => concat_y_net_x11,
      ce_1 => ce_1_sg_x379,
      clk_1 => clk_1_sg_x379,
      d_in => concat_y_net_x39,
      sync_in => delay_q_net_x4,
      a_out => concat_y_net_x44,
      b_out => concat_y_net_x45,
      c_out => concat_y_net_x46,
      d_out => concat_y_net_x47,
      sync_out => delay_q_net_x10
    );

  r4_twiddle_a297e404cd: entity work.r4_twiddle_entity_a297e404cd
    port map (
      a_in => slr_q_net_x10,
      b => mux1_y_net_x8,
      c => slr_q_net_x11,
      ce_1 => ce_1_sg_x379,
      clk_1 => clk_1_sg_x379,
      d => mux1_y_net_x9,
      sync_in => delay_q_net_x8,
      a_out => delay1_q_net_x4,
      bw => concat_y_net_x38,
      cw => concat_y_net_x11,
      dw => concat_y_net_x39,
      sync_out => delay_q_net_x4
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_dit_fft"

entity r4_dit_fft_entity_bb20d3c530 is
  port (
    a_in: in std_logic_vector(17 downto 0); 
    b_in: in std_logic_vector(17 downto 0); 
    c_in: in std_logic_vector(17 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d_in: in std_logic_vector(17 downto 0); 
    sync_in: in std_logic; 
    a_out: out std_logic_vector(37 downto 0); 
    b_out: out std_logic_vector(37 downto 0); 
    c_out: out std_logic_vector(37 downto 0); 
    d_out: out std_logic_vector(37 downto 0)
  );
end r4_dit_fft_entity_bb20d3c530;

architecture structural of r4_dit_fft_entity_bb20d3c530 is
  signal ce_1_sg_x380: std_logic;
  signal clk_1_sg_x380: std_logic;
  signal concat_y_net_x15: std_logic_vector(37 downto 0);
  signal concat_y_net_x16: std_logic_vector(37 downto 0);
  signal concat_y_net_x24: std_logic_vector(21 downto 0);
  signal concat_y_net_x33: std_logic_vector(21 downto 0);
  signal concat_y_net_x34: std_logic_vector(21 downto 0);
  signal concat_y_net_x35: std_logic_vector(21 downto 0);
  signal concat_y_net_x40: std_logic_vector(33 downto 0);
  signal concat_y_net_x41: std_logic_vector(33 downto 0);
  signal concat_y_net_x42: std_logic_vector(33 downto 0);
  signal concat_y_net_x43: std_logic_vector(33 downto 0);
  signal concat_y_net_x44: std_logic_vector(37 downto 0);
  signal concat_y_net_x45: std_logic_vector(37 downto 0);
  signal concat_y_net_x46: std_logic_vector(37 downto 0);
  signal concat_y_net_x47: std_logic_vector(37 downto 0);
  signal concat_y_net_x48: std_logic_vector(25 downto 0);
  signal concat_y_net_x49: std_logic_vector(25 downto 0);
  signal concat_y_net_x50: std_logic_vector(25 downto 0);
  signal concat_y_net_x51: std_logic_vector(25 downto 0);
  signal concat_y_net_x52: std_logic_vector(37 downto 0);
  signal concat_y_net_x53: std_logic_vector(37 downto 0);
  signal concat_y_net_x54: std_logic_vector(37 downto 0);
  signal concat_y_net_x55: std_logic_vector(37 downto 0);
  signal concat_y_net_x64: std_logic_vector(29 downto 0);
  signal concat_y_net_x65: std_logic_vector(29 downto 0);
  signal concat_y_net_x66: std_logic_vector(29 downto 0);
  signal concat_y_net_x67: std_logic_vector(29 downto 0);
  signal delay_q_net_x10: std_logic;
  signal delay_q_net_x13: std_logic;
  signal delay_q_net_x16: std_logic;
  signal delay_q_net_x21: std_logic;
  signal delay_q_net_x26: std_logic;
  signal delay_q_net_x27: std_logic;
  signal delay_q_net_x7: std_logic;
  signal mux1_y_net_x6: std_logic_vector(37 downto 0);
  signal mux1_y_net_x7: std_logic_vector(37 downto 0);
  signal shift1_op_net_x3: std_logic_vector(17 downto 0);
  signal shift4_op_net_x4: std_logic_vector(17 downto 0);
  signal shift5_op_net_x4: std_logic_vector(17 downto 0);
  signal shift_op_net_x3: std_logic_vector(17 downto 0);

begin
  shift_op_net_x3 <= a_in;
  shift1_op_net_x3 <= b_in;
  shift4_op_net_x4 <= c_in;
  ce_1_sg_x380 <= ce_1;
  clk_1_sg_x380 <= clk_1;
  shift5_op_net_x4 <= d_in;
  delay_q_net_x27 <= sync_in;
  a_out <= concat_y_net_x52;
  b_out <= concat_y_net_x53;
  c_out <= concat_y_net_x54;
  d_out <= concat_y_net_x55;

  quadplex_bitrev_660273096d: entity work.quadplex_bitrev_entity_660273096d
    port map (
      a_in => concat_y_net_x15,
      b_in => mux1_y_net_x6,
      c_in => concat_y_net_x16,
      ce_1 => ce_1_sg_x380,
      clk_1 => clk_1_sg_x380,
      d_in => mux1_y_net_x7,
      sync_in => delay_q_net_x7,
      a_out => concat_y_net_x52,
      b_out => concat_y_net_x53,
      c_out => concat_y_net_x54,
      d_out => concat_y_net_x55
    );

  quadplex_commutator_24b23ba26e: entity work.quadplex_commutator_entity_24b23ba26e
    port map (
      a => concat_y_net_x44,
      b => concat_y_net_x46,
      c => concat_y_net_x45,
      ce_1 => ce_1_sg_x380,
      clk_1 => clk_1_sg_x380,
      d => concat_y_net_x47,
      sync_in => delay_q_net_x10,
      abcd0 => concat_y_net_x15,
      abcd1 => mux1_y_net_x6,
      abcd2 => concat_y_net_x16,
      abcd3 => mux1_y_net_x7,
      sync_out => delay_q_net_x7
    );

  r4_dit_stage_1_36070de08f: entity work.r4_dit_stage_1_entity_36070de08f
    port map (
      a_in => shift_op_net_x3,
      b_in => shift1_op_net_x3,
      c_in => shift4_op_net_x4,
      ce_1 => ce_1_sg_x380,
      clk_1 => clk_1_sg_x380,
      d_in => shift5_op_net_x4,
      sync_in => delay_q_net_x27,
      a_out => concat_y_net_x24,
      b_out => concat_y_net_x33,
      c_out => concat_y_net_x34,
      d_out => concat_y_net_x35,
      sync_out => delay_q_net_x16
    );

  r4_dit_stage_2_1a9931e6f1: entity work.r4_dit_stage_2_entity_1a9931e6f1
    port map (
      a_in => concat_y_net_x24,
      b_in => concat_y_net_x33,
      c_in => concat_y_net_x34,
      ce_1 => ce_1_sg_x380,
      clk_1 => clk_1_sg_x380,
      d_in => concat_y_net_x35,
      sync_in => delay_q_net_x16,
      a_out => concat_y_net_x48,
      b_out => concat_y_net_x49,
      c_out => concat_y_net_x50,
      d_out => concat_y_net_x51,
      sync_out => delay_q_net_x13
    );

  r4_dit_stage_3_2e339e97dd: entity work.r4_dit_stage_3_entity_2e339e97dd
    port map (
      a_in => concat_y_net_x48,
      b_in => concat_y_net_x49,
      c_in => concat_y_net_x50,
      ce_1 => ce_1_sg_x380,
      clk_1 => clk_1_sg_x380,
      d_in => concat_y_net_x51,
      sync_in => delay_q_net_x13,
      a_out => concat_y_net_x64,
      b_out => concat_y_net_x65,
      c_out => concat_y_net_x66,
      d_out => concat_y_net_x67,
      sync_out => delay_q_net_x21
    );

  r4_dit_stage_4_fc2110268b: entity work.r4_dit_stage_4_entity_fc2110268b
    port map (
      a_in => concat_y_net_x64,
      b_in => concat_y_net_x65,
      c_in => concat_y_net_x66,
      ce_1 => ce_1_sg_x380,
      clk_1 => clk_1_sg_x380,
      d_in => concat_y_net_x67,
      sync_in => delay_q_net_x21,
      a_out => concat_y_net_x40,
      b_out => concat_y_net_x41,
      c_out => concat_y_net_x42,
      d_out => concat_y_net_x43,
      sync_out => delay_q_net_x26
    );

  r4_dit_stage_5_cf41b9127c: entity work.r4_dit_stage_5_entity_cf41b9127c
    port map (
      a_in => concat_y_net_x40,
      b_in => concat_y_net_x41,
      c_in => concat_y_net_x42,
      ce_1 => ce_1_sg_x380,
      clk_1 => clk_1_sg_x380,
      d_in => concat_y_net_x43,
      sync_in => delay_q_net_x26,
      a_out => concat_y_net_x44,
      b_out => concat_y_net_x45,
      c_out => concat_y_net_x46,
      d_out => concat_y_net_x47,
      sync_out => delay_q_net_x10
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_power19_1/c_to_ri"

entity c_to_ri_entity_e2ce2ec87a is
  port (
    c: in std_logic_vector(37 downto 0); 
    im: out std_logic_vector(18 downto 0); 
    re: out std_logic_vector(18 downto 0)
  );
end c_to_ri_entity_e2ce2ec87a;

architecture structural of c_to_ri_entity_e2ce2ec87a is
  signal delay5_q_net_x0: std_logic_vector(37 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(18 downto 0);
  signal slice_im_y_net: std_logic_vector(18 downto 0);
  signal slice_re_y_net: std_logic_vector(18 downto 0);

begin
  delay5_q_net_x0 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 18,
      x_width => 38,
      y_width => 19
    )
    port map (
      x => delay5_q_net_x0,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 19,
      new_msb => 37,
      x_width => 38,
      y_width => 19
    )
    port map (
      x => delay5_q_net_x0,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/r4_power19_1"

entity r4_power19_1_entity_4d56d1ab0b is
  port (
    c: in std_logic_vector(37 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    power: out std_logic_vector(37 downto 0)
  );
end r4_power19_1_entity_4d56d1ab0b;

architecture structural of r4_power19_1_entity_4d56d1ab0b is
  signal ce_1_sg_x381: std_logic;
  signal clk_1_sg_x381: std_logic;
  signal delay5_q_net_x1: std_logic_vector(37 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(18 downto 0);
  signal imag_square_p_net: std_logic_vector(37 downto 0);
  signal power_adder_s_net_x0: std_logic_vector(37 downto 0);
  signal real_square_p_net: std_logic_vector(37 downto 0);

begin
  delay5_q_net_x1 <= c;
  ce_1_sg_x381 <= ce_1;
  clk_1_sg_x381 <= clk_1;
  power <= power_adder_s_net_x0;

  c_to_ri_e2ce2ec87a: entity work.c_to_ri_entity_e2ce2ec87a
    port map (
      c => delay5_q_net_x1,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  imag_square: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 16,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 16,
      b_width => 19,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 19,
      c_baat => 19,
      c_output_width => 38,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_36b8f4cb731cc5b3",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 38,
      quantization => 1
    )
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x0,
      ce => ce_1_sg_x381,
      clk => clk_1_sg_x381,
      clr => '0',
      core_ce => ce_1_sg_x381,
      core_clk => clk_1_sg_x381,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => imag_square_p_net
    );

  power_adder: entity work.addsub_96d2a7e25e
    port map (
      a => real_square_p_net,
      b => imag_square_p_net,
      ce => ce_1_sg_x381,
      clk => clk_1_sg_x381,
      clr => '0',
      s => power_adder_s_net_x0
    );

  real_square: entity work.xlmult_v9_0
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 16,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 16,
      b_width => 19,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 19,
      c_baat => 19,
      c_output_width => 38,
      c_type => 0,
      core_name0 => "multiplier_virtex5_10_1_36b8f4cb731cc5b3",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 38,
      quantization => 1
    )
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x0,
      ce => ce_1_sg_x381,
      clk => clk_1_sg_x381,
      clr => '0',
      core_ce => ce_1_sg_x381,
      core_clk => clk_1_sg_x381,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => real_square_p_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/snap_adc/addr"

entity addr_entity_1e1f5ffa13 is
  port (
    reg_out: in std_logic_vector(12 downto 0); 
    convert_x0: out std_logic_vector(31 downto 0)
  );
end addr_entity_1e1f5ffa13;

architecture structural of addr_entity_1e1f5ffa13 is
  signal convert_dout_net_x0: std_logic_vector(31 downto 0);
  signal delay8_q_net_x0: std_logic_vector(12 downto 0);

begin
  delay8_q_net_x0 <= reg_out;
  convert_x0 <= convert_dout_net_x0;

  convert: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 13,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => delay8_q_net_x0,
      dout => convert_dout_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/snap_adc/bram_lsb"

entity bram_lsb_entity_fbf1ca35c2 is
  port (
    addr: in std_logic_vector(12 downto 0); 
    data_in: in std_logic_vector(31 downto 0); 
    we: in std_logic; 
    convert_addr_x0: out std_logic_vector(12 downto 0); 
    convert_din_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic
  );
end bram_lsb_entity_fbf1ca35c2;

architecture structural of bram_lsb_entity_fbf1ca35c2 is
  signal convert_addr_dout_net_x0: std_logic_vector(12 downto 0);
  signal convert_din_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal delay5_q_net_x0: std_logic_vector(12 downto 0);
  signal delay6_q_net_x0: std_logic_vector(31 downto 0);
  signal delay7_q_net_x0: std_logic;

begin
  delay5_q_net_x0 <= addr;
  delay6_q_net_x0 <= data_in;
  delay7_q_net_x0 <= we;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din_x0 <= convert_din_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 13,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 13,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => delay5_q_net_x0,
      dout => convert_addr_dout_net_x0
    );

  convert_din: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => delay6_q_net_x0,
      dout => convert_din_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din(0) => delay7_q_net_x0,
      dout(0) => convert_we_dout_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/snap_adc/freeze_cntr"

entity freeze_cntr_entity_c486df284c is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    en: in std_logic; 
    rst: in std_logic; 
    addr: out std_logic_vector(12 downto 0); 
    we: out std_logic
  );
end freeze_cntr_entity_c486df284c;

architecture structural of freeze_cntr_entity_c486df284c is
  signal ce_1_sg_x385: std_logic;
  signal clk_1_sg_x385: std_logic;
  signal counter3_op_net: std_logic_vector(13 downto 0);
  signal enable1_y_net: std_logic;
  signal enable_y_net_x0: std_logic_vector(12 downto 0);
  signal inverter1_op_net: std_logic;
  signal inverter_op_net: std_logic;
  signal logical1_y_net_x0: std_logic;
  signal logical5_y_net: std_logic;
  signal mux1_y_net_x0: std_logic;
  signal register_q_net_x0: std_logic;

begin
  ce_1_sg_x385 <= ce_1;
  clk_1_sg_x385 <= clk_1;
  mux1_y_net_x0 <= en;
  register_q_net_x0 <= rst;
  addr <= enable_y_net_x0;
  we <= logical1_y_net_x0;

  counter3: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_6ddb97ef480a3f10",
      op_arith => xlUnsigned,
      op_width => 14
    )
    port map (
      ce => ce_1_sg_x385,
      clk => clk_1_sg_x385,
      clr => '0',
      en(0) => logical5_y_net,
      rst(0) => register_q_net_x0,
      op => counter3_op_net
    );

  enable: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 12,
      x_width => 14,
      y_width => 13
    )
    port map (
      x => counter3_op_net,
      y => enable_y_net_x0
    );

  enable1: entity work.xlslice
    generic map (
      new_lsb => 13,
      new_msb => 13,
      x_width => 14,
      y_width => 1
    )
    port map (
      x => counter3_op_net,
      y(0) => enable1_y_net
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x385,
      clk => clk_1_sg_x385,
      clr => '0',
      ip(0) => register_q_net_x0,
      op(0) => inverter_op_net
    );

  inverter1: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x385,
      clk => clk_1_sg_x385,
      clr => '0',
      ip(0) => enable1_y_net,
      op(0) => inverter1_op_net
    );

  logical1: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => inverter_op_net,
      d1(0) => logical5_y_net,
      y(0) => logical1_y_net_x0
    );

  logical5: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => mux1_y_net_x0,
      d1(0) => inverter1_op_net,
      y(0) => logical5_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/snap_adc"

entity snap_adc_entity_4bfcd7107d is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(63 downto 0); 
    r4_5g_specv5_snap_adc_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    addr: out std_logic_vector(31 downto 0); 
    bram_lsb: out std_logic_vector(12 downto 0); 
    bram_lsb_x0: out std_logic_vector(31 downto 0); 
    bram_lsb_x1: out std_logic; 
    bram_msb: out std_logic_vector(12 downto 0); 
    bram_msb_x0: out std_logic_vector(31 downto 0); 
    bram_msb_x1: out std_logic
  );
end snap_adc_entity_4bfcd7107d;

architecture structural of snap_adc_entity_4bfcd7107d is
  signal ce_1_sg_x387: std_logic;
  signal clk_1_sg_x387: std_logic;
  signal concat3_y_net_x0: std_logic_vector(63 downto 0);
  signal constant12_op_net_x0: std_logic;
  signal constant1_op_net: std_logic;
  signal constant2_op_net: std_logic;
  signal constant3_op_net_x0: std_logic;
  signal constant_op_net: std_logic;
  signal convert_addr_dout_net_x2: std_logic_vector(12 downto 0);
  signal convert_addr_dout_net_x3: std_logic_vector(12 downto 0);
  signal convert_din_dout_net_x2: std_logic_vector(31 downto 0);
  signal convert_din_dout_net_x3: std_logic_vector(31 downto 0);
  signal convert_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x2: std_logic;
  signal convert_we_dout_net_x3: std_logic;
  signal delay1_q_net: std_logic_vector(31 downto 0);
  signal delay2_q_net_x0: std_logic_vector(31 downto 0);
  signal delay3_q_net_x0: std_logic_vector(12 downto 0);
  signal delay4_q_net_x0: std_logic;
  signal delay5_q_net_x0: std_logic_vector(12 downto 0);
  signal delay6_q_net_x0: std_logic_vector(31 downto 0);
  signal delay7_q_net_x0: std_logic;
  signal delay8_q_net_x0: std_logic_vector(12 downto 0);
  signal en1_y_net: std_logic_vector(31 downto 0);
  signal en2_y_net: std_logic_vector(31 downto 0);
  signal enable_y_net_x0: std_logic;
  signal enable_y_net_x1: std_logic_vector(12 downto 0);
  signal inverter_op_net: std_logic;
  signal logical1_y_net: std_logic;
  signal logical1_y_net_x0: std_logic;
  signal logical_y_net_x0: std_logic;
  signal mux1_y_net_x0: std_logic;
  signal mux2_y_net: std_logic;
  signal r4_5g_specv5_snap_adc_ctrl_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal register1_q_net: std_logic_vector(12 downto 0);
  signal register_q_net_x0: std_logic;
  signal reinterpret3_output_port_net: std_logic_vector(63 downto 0);
  signal trig1_y_net: std_logic;
  signal valid_y_net: std_logic;

begin
  ce_1_sg_x387 <= ce_1;
  clk_1_sg_x387 <= clk_1;
  concat3_y_net_x0 <= din;
  r4_5g_specv5_snap_adc_ctrl_user_data_out_net_x0 <= r4_5g_specv5_snap_adc_ctrl_user_data_out;
  constant3_op_net_x0 <= trig;
  constant12_op_net_x0 <= we;
  addr <= convert_dout_net_x1;
  bram_lsb <= convert_addr_dout_net_x2;
  bram_lsb_x0 <= convert_din_dout_net_x2;
  bram_lsb_x1 <= convert_we_dout_net_x2;
  bram_msb <= convert_addr_dout_net_x3;
  bram_msb_x0 <= convert_din_dout_net_x3;
  bram_msb_x1 <= convert_we_dout_net_x3;

  addr_1e1f5ffa13: entity work.addr_entity_1e1f5ffa13
    port map (
      reg_out => delay8_q_net_x0,
      convert_x0 => convert_dout_net_x1
    );

  bram_lsb_fbf1ca35c2: entity work.bram_lsb_entity_fbf1ca35c2
    port map (
      addr => delay5_q_net_x0,
      data_in => delay6_q_net_x0,
      we => delay7_q_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x2,
      convert_din_x0 => convert_din_dout_net_x2,
      convert_we_x0 => convert_we_dout_net_x2
    );

  bram_msb_31d3def2d8: entity work.bram_lsb_entity_fbf1ca35c2
    port map (
      addr => delay3_q_net_x0,
      data_in => delay2_q_net_x0,
      we => delay4_q_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x3,
      convert_din_x0 => convert_din_dout_net_x3,
      convert_we_x0 => convert_we_dout_net_x3
    );

  constant1: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant1_op_net
    );

  constant2: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  delay1: entity work.delay_d6fa0633b9
    port map (
      ce => ce_1_sg_x387,
      clk => clk_1_sg_x387,
      clr => '0',
      d => r4_5g_specv5_snap_adc_ctrl_user_data_out_net_x0,
      q => delay1_q_net
    );

  delay2: entity work.delay_d6fa0633b9
    port map (
      ce => ce_1_sg_x387,
      clk => clk_1_sg_x387,
      clr => '0',
      d => en1_y_net,
      q => delay2_q_net_x0
    );

  delay3: entity work.delay_bab6621619
    port map (
      ce => ce_1_sg_x387,
      clk => clk_1_sg_x387,
      clr => '0',
      d => enable_y_net_x1,
      q => delay3_q_net_x0
    );

  delay4: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x387,
      clk => clk_1_sg_x387,
      clr => '0',
      d(0) => logical1_y_net_x0,
      q(0) => delay4_q_net_x0
    );

  delay5: entity work.delay_bab6621619
    port map (
      ce => ce_1_sg_x387,
      clk => clk_1_sg_x387,
      clr => '0',
      d => enable_y_net_x1,
      q => delay5_q_net_x0
    );

  delay6: entity work.delay_d6fa0633b9
    port map (
      ce => ce_1_sg_x387,
      clk => clk_1_sg_x387,
      clr => '0',
      d => en2_y_net,
      q => delay6_q_net_x0
    );

  delay7: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x387,
      clk => clk_1_sg_x387,
      clr => '0',
      d(0) => logical1_y_net_x0,
      q(0) => delay7_q_net_x0
    );

  delay8: entity work.delay_bab6621619
    port map (
      ce => ce_1_sg_x387,
      clk => clk_1_sg_x387,
      clr => '0',
      d => register1_q_net,
      q => delay8_q_net_x0
    );

  en1: entity work.xlslice
    generic map (
      new_lsb => 32,
      new_msb => 63,
      x_width => 64,
      y_width => 32
    )
    port map (
      x => reinterpret3_output_port_net,
      y => en1_y_net
    );

  en2: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 64,
      y_width => 32
    )
    port map (
      x => reinterpret3_output_port_net,
      y => en2_y_net
    );

  enable: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => delay1_q_net,
      y(0) => enable_y_net_x0
    );

  freeze_cntr_c486df284c: entity work.freeze_cntr_entity_c486df284c
    port map (
      ce_1 => ce_1_sg_x387,
      clk_1 => clk_1_sg_x387,
      en => mux1_y_net_x0,
      rst => register_q_net_x0,
      addr => enable_y_net_x1,
      we => logical1_y_net_x0
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x387,
      clk => clk_1_sg_x387,
      clr => '0',
      ip(0) => logical_y_net_x0,
      op(0) => inverter_op_net
    );

  logical1: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => mux2_y_net,
      d1(0) => inverter_op_net,
      y(0) => logical1_y_net
    );

  mux1: entity work.mux_d99e59b6d4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => constant12_op_net_x0,
      d1(0) => constant2_op_net,
      sel(0) => valid_y_net,
      y(0) => mux1_y_net_x0
    );

  mux2: entity work.mux_d99e59b6d4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => constant3_op_net_x0,
      d1(0) => constant1_op_net,
      sel(0) => trig1_y_net,
      y(0) => mux2_y_net
    );

  posedge_5a898ad524: entity work.posedge1_entity_d70b7fecd6
    port map (
      ce_1 => ce_1_sg_x387,
      clk_1 => clk_1_sg_x387,
      in_x0 => enable_y_net_x0,
      out_x0 => logical_y_net_x0
    );

  register1: entity work.xlregister
    generic map (
      d_width => 13,
      init_value => b"0000000000000"
    )
    port map (
      ce => ce_1_sg_x387,
      clk => clk_1_sg_x387,
      d => enable_y_net_x1,
      en(0) => logical1_y_net_x0,
      rst(0) => logical_y_net_x0,
      q => register1_q_net
    );

  register_x0: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x387,
      clk => clk_1_sg_x387,
      d(0) => constant_op_net,
      en(0) => logical_y_net_x0,
      rst(0) => logical1_y_net,
      q(0) => register_q_net_x0
    );

  reinterpret3: entity work.reinterpret_9a13f6a2a0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concat3_y_net_x0,
      output_port => reinterpret3_output_port_net
    );

  trig1: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => delay1_q_net,
      y(0) => trig1_y_net
    );

  valid: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => delay1_q_net,
      y(0) => valid_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/snap_vacc0/addr"

entity addr_entity_32c83c5028 is
  port (
    reg_out: in std_logic_vector(9 downto 0); 
    convert_x0: out std_logic_vector(31 downto 0)
  );
end addr_entity_32c83c5028;

architecture structural of addr_entity_32c83c5028 is
  signal convert_dout_net_x0: std_logic_vector(31 downto 0);
  signal register1_q_net_x0: std_logic_vector(9 downto 0);

begin
  register1_q_net_x0 <= reg_out;
  convert_x0 <= convert_dout_net_x0;

  convert: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => register1_q_net_x0,
      dout => convert_dout_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/snap_vacc0/bram"

entity bram_entity_ef33986178 is
  port (
    addr: in std_logic_vector(9 downto 0); 
    data_in: in std_logic_vector(31 downto 0); 
    we: in std_logic; 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic
  );
end bram_entity_ef33986178;

architecture structural of bram_entity_ef33986178 is
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal enable_y_net_x0: std_logic_vector(9 downto 0);
  signal logical1_y_net_x0: std_logic;
  signal reinterpret_output_port_net_x0: std_logic_vector(31 downto 0);

begin
  enable_y_net_x0 <= addr;
  reinterpret_output_port_net_x0 <= data_in;
  logical1_y_net_x0 <= we;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din_x0 <= convert_din_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => enable_y_net_x0,
      dout => convert_addr_dout_net_x0
    );

  convert_din: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din => reinterpret_output_port_net_x0,
      dout => convert_din_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      din(0) => logical1_y_net_x0,
      dout(0) => convert_we_dout_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/snap_vacc0/freeze_cntr"

entity freeze_cntr_entity_b4db19b16d is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    en: in std_logic; 
    rst: in std_logic; 
    addr: out std_logic_vector(9 downto 0); 
    we: out std_logic
  );
end freeze_cntr_entity_b4db19b16d;

architecture structural of freeze_cntr_entity_b4db19b16d is
  signal ce_1_sg_x388: std_logic;
  signal clk_1_sg_x388: std_logic;
  signal counter3_op_net: std_logic_vector(10 downto 0);
  signal enable1_y_net: std_logic;
  signal enable_y_net_x1: std_logic_vector(9 downto 0);
  signal inverter1_op_net: std_logic;
  signal inverter_op_net: std_logic;
  signal logical1_y_net_x1: std_logic;
  signal logical5_y_net: std_logic;
  signal mux1_y_net_x0: std_logic;
  signal register_q_net_x0: std_logic;

begin
  ce_1_sg_x388 <= ce_1;
  clk_1_sg_x388 <= clk_1;
  mux1_y_net_x0 <= en;
  register_q_net_x0 <= rst;
  addr <= enable_y_net_x1;
  we <= logical1_y_net_x1;

  counter3: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_ed17144209261f47",
      op_arith => xlUnsigned,
      op_width => 11
    )
    port map (
      ce => ce_1_sg_x388,
      clk => clk_1_sg_x388,
      clr => '0',
      en(0) => logical5_y_net,
      rst(0) => register_q_net_x0,
      op => counter3_op_net
    );

  enable: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 9,
      x_width => 11,
      y_width => 10
    )
    port map (
      x => counter3_op_net,
      y => enable_y_net_x1
    );

  enable1: entity work.xlslice
    generic map (
      new_lsb => 10,
      new_msb => 10,
      x_width => 11,
      y_width => 1
    )
    port map (
      x => counter3_op_net,
      y(0) => enable1_y_net
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x388,
      clk => clk_1_sg_x388,
      clr => '0',
      ip(0) => register_q_net_x0,
      op(0) => inverter_op_net
    );

  inverter1: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x388,
      clk => clk_1_sg_x388,
      clr => '0',
      ip(0) => enable1_y_net,
      op(0) => inverter1_op_net
    );

  logical1: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => inverter_op_net,
      d1(0) => logical5_y_net,
      y(0) => logical1_y_net_x1
    );

  logical5: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => mux1_y_net_x0,
      d1(0) => inverter1_op_net,
      y(0) => logical5_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/snap_vacc0"

entity snap_vacc0_entity_f1b6ff57cb is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc0_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    addr: out std_logic_vector(31 downto 0); 
    bram: out std_logic_vector(9 downto 0); 
    bram_x0: out std_logic_vector(31 downto 0); 
    bram_x1: out std_logic
  );
end snap_vacc0_entity_f1b6ff57cb;

architecture structural of snap_vacc0_entity_f1b6ff57cb is
  signal ce_1_sg_x390: std_logic;
  signal clk_1_sg_x390: std_logic;
  signal constant1_op_net: std_logic;
  signal constant2_op_net: std_logic;
  signal constant_op_net: std_logic;
  signal convert_addr_dout_net_x1: std_logic_vector(9 downto 0);
  signal convert_din_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal delay11_q_net_x0: std_logic_vector(31 downto 0);
  signal delay12_q_net_x0: std_logic;
  signal delay29_q_net_x0: std_logic;
  signal enable_y_net_x0: std_logic;
  signal enable_y_net_x1: std_logic_vector(9 downto 0);
  signal inverter_op_net: std_logic;
  signal logical1_y_net: std_logic;
  signal logical1_y_net_x1: std_logic;
  signal logical_y_net_x0: std_logic;
  signal mux1_y_net_x0: std_logic;
  signal mux2_y_net: std_logic;
  signal r4_5g_specv5_snap_vacc0_ctrl_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal register1_q_net_x0: std_logic_vector(9 downto 0);
  signal register_q_net_x0: std_logic;
  signal reinterpret_output_port_net_x0: std_logic_vector(31 downto 0);
  signal trig1_y_net: std_logic;
  signal valid_y_net: std_logic;

begin
  ce_1_sg_x390 <= ce_1;
  clk_1_sg_x390 <= clk_1;
  delay11_q_net_x0 <= din;
  r4_5g_specv5_snap_vacc0_ctrl_user_data_out_net_x0 <= r4_5g_specv5_snap_vacc0_ctrl_user_data_out;
  delay29_q_net_x0 <= trig;
  delay12_q_net_x0 <= we;
  addr <= convert_dout_net_x1;
  bram <= convert_addr_dout_net_x1;
  bram_x0 <= convert_din_dout_net_x1;
  bram_x1 <= convert_we_dout_net_x1;

  addr_32c83c5028: entity work.addr_entity_32c83c5028
    port map (
      reg_out => register1_q_net_x0,
      convert_x0 => convert_dout_net_x1
    );

  bram_ef33986178: entity work.bram_entity_ef33986178
    port map (
      addr => enable_y_net_x1,
      data_in => reinterpret_output_port_net_x0,
      we => logical1_y_net_x1,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din_x0 => convert_din_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1
    );

  constant1: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant1_op_net
    );

  constant2: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  enable: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => r4_5g_specv5_snap_vacc0_ctrl_user_data_out_net_x0,
      y(0) => enable_y_net_x0
    );

  freeze_cntr_b4db19b16d: entity work.freeze_cntr_entity_b4db19b16d
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      en => mux1_y_net_x0,
      rst => register_q_net_x0,
      addr => enable_y_net_x1,
      we => logical1_y_net_x1
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      ip(0) => logical_y_net_x0,
      op(0) => inverter_op_net
    );

  logical1: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => mux2_y_net,
      d1(0) => inverter_op_net,
      y(0) => logical1_y_net
    );

  mux1: entity work.mux_d99e59b6d4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => delay12_q_net_x0,
      d1(0) => constant2_op_net,
      sel(0) => valid_y_net,
      y(0) => mux1_y_net_x0
    );

  mux2: entity work.mux_d99e59b6d4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => delay29_q_net_x0,
      d1(0) => constant1_op_net,
      sel(0) => trig1_y_net,
      y(0) => mux2_y_net
    );

  posedge_6278cb7e49: entity work.posedge1_entity_d70b7fecd6
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      in_x0 => enable_y_net_x0,
      out_x0 => logical_y_net_x0
    );

  register1: entity work.xlregister
    generic map (
      d_width => 10,
      init_value => b"0000000000"
    )
    port map (
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      d => enable_y_net_x1,
      en(0) => logical1_y_net_x1,
      rst(0) => logical_y_net_x0,
      q => register1_q_net_x0
    );

  register_x0: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      d(0) => constant_op_net,
      en(0) => logical_y_net_x0,
      rst(0) => logical1_y_net,
      q(0) => register_q_net_x0
    );

  reinterpret: entity work.reinterpret_3f7e3674f6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay11_q_net_x0,
      output_port => reinterpret_output_port_net_x0
    );

  trig1: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => r4_5g_specv5_snap_vacc0_ctrl_user_data_out_net_x0,
      y(0) => trig1_y_net
    );

  valid: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => r4_5g_specv5_snap_vacc0_ctrl_user_data_out_net_x0,
      y(0) => valid_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/snap_vacc1"

entity snap_vacc1_entity_a816baf518 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc1_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    addr: out std_logic_vector(31 downto 0); 
    bram: out std_logic_vector(9 downto 0); 
    bram_x0: out std_logic_vector(31 downto 0); 
    bram_x1: out std_logic
  );
end snap_vacc1_entity_a816baf518;

architecture structural of snap_vacc1_entity_a816baf518 is
  signal ce_1_sg_x393: std_logic;
  signal clk_1_sg_x393: std_logic;
  signal constant1_op_net: std_logic;
  signal constant2_op_net: std_logic;
  signal constant_op_net: std_logic;
  signal convert_addr_dout_net_x1: std_logic_vector(9 downto 0);
  signal convert_din_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal delay13_q_net_x0: std_logic_vector(31 downto 0);
  signal delay29_q_net_x1: std_logic;
  signal delay8_q_net_x0: std_logic;
  signal enable_y_net_x0: std_logic;
  signal enable_y_net_x1: std_logic_vector(9 downto 0);
  signal inverter_op_net: std_logic;
  signal logical1_y_net: std_logic;
  signal logical1_y_net_x1: std_logic;
  signal logical_y_net_x0: std_logic;
  signal mux1_y_net_x0: std_logic;
  signal mux2_y_net: std_logic;
  signal r4_5g_specv5_snap_vacc1_ctrl_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal register1_q_net_x0: std_logic_vector(9 downto 0);
  signal register_q_net_x0: std_logic;
  signal reinterpret_output_port_net_x0: std_logic_vector(31 downto 0);
  signal trig1_y_net: std_logic;
  signal valid_y_net: std_logic;

begin
  ce_1_sg_x393 <= ce_1;
  clk_1_sg_x393 <= clk_1;
  delay13_q_net_x0 <= din;
  r4_5g_specv5_snap_vacc1_ctrl_user_data_out_net_x0 <= r4_5g_specv5_snap_vacc1_ctrl_user_data_out;
  delay29_q_net_x1 <= trig;
  delay8_q_net_x0 <= we;
  addr <= convert_dout_net_x1;
  bram <= convert_addr_dout_net_x1;
  bram_x0 <= convert_din_dout_net_x1;
  bram_x1 <= convert_we_dout_net_x1;

  addr_e8866bc21f: entity work.addr_entity_32c83c5028
    port map (
      reg_out => register1_q_net_x0,
      convert_x0 => convert_dout_net_x1
    );

  bram_3aff363242: entity work.bram_entity_ef33986178
    port map (
      addr => enable_y_net_x1,
      data_in => reinterpret_output_port_net_x0,
      we => logical1_y_net_x1,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din_x0 => convert_din_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1
    );

  constant1: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant1_op_net
    );

  constant2: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  enable: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => r4_5g_specv5_snap_vacc1_ctrl_user_data_out_net_x0,
      y(0) => enable_y_net_x0
    );

  freeze_cntr_898a6de690: entity work.freeze_cntr_entity_b4db19b16d
    port map (
      ce_1 => ce_1_sg_x393,
      clk_1 => clk_1_sg_x393,
      en => mux1_y_net_x0,
      rst => register_q_net_x0,
      addr => enable_y_net_x1,
      we => logical1_y_net_x1
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x393,
      clk => clk_1_sg_x393,
      clr => '0',
      ip(0) => logical_y_net_x0,
      op(0) => inverter_op_net
    );

  logical1: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => mux2_y_net,
      d1(0) => inverter_op_net,
      y(0) => logical1_y_net
    );

  mux1: entity work.mux_d99e59b6d4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => delay8_q_net_x0,
      d1(0) => constant2_op_net,
      sel(0) => valid_y_net,
      y(0) => mux1_y_net_x0
    );

  mux2: entity work.mux_d99e59b6d4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => delay29_q_net_x1,
      d1(0) => constant1_op_net,
      sel(0) => trig1_y_net,
      y(0) => mux2_y_net
    );

  posedge_e03025439e: entity work.posedge1_entity_d70b7fecd6
    port map (
      ce_1 => ce_1_sg_x393,
      clk_1 => clk_1_sg_x393,
      in_x0 => enable_y_net_x0,
      out_x0 => logical_y_net_x0
    );

  register1: entity work.xlregister
    generic map (
      d_width => 10,
      init_value => b"0000000000"
    )
    port map (
      ce => ce_1_sg_x393,
      clk => clk_1_sg_x393,
      d => enable_y_net_x1,
      en(0) => logical1_y_net_x1,
      rst(0) => logical_y_net_x0,
      q => register1_q_net_x0
    );

  register_x0: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x393,
      clk => clk_1_sg_x393,
      d(0) => constant_op_net,
      en(0) => logical_y_net_x0,
      rst(0) => logical1_y_net,
      q(0) => register_q_net_x0
    );

  reinterpret: entity work.reinterpret_3f7e3674f6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay13_q_net_x0,
      output_port => reinterpret_output_port_net_x0
    );

  trig1: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => r4_5g_specv5_snap_vacc1_ctrl_user_data_out_net_x0,
      y(0) => trig1_y_net
    );

  valid: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => r4_5g_specv5_snap_vacc1_ctrl_user_data_out_net_x0,
      y(0) => valid_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/snap_vacc2"

entity snap_vacc2_entity_c2f47281df is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc2_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    addr: out std_logic_vector(31 downto 0); 
    bram: out std_logic_vector(9 downto 0); 
    bram_x0: out std_logic_vector(31 downto 0); 
    bram_x1: out std_logic
  );
end snap_vacc2_entity_c2f47281df;

architecture structural of snap_vacc2_entity_c2f47281df is
  signal ce_1_sg_x396: std_logic;
  signal clk_1_sg_x396: std_logic;
  signal constant1_op_net: std_logic;
  signal constant2_op_net: std_logic;
  signal constant_op_net: std_logic;
  signal convert_addr_dout_net_x1: std_logic_vector(9 downto 0);
  signal convert_din_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal delay35_q_net_x0: std_logic_vector(31 downto 0);
  signal delay36_q_net_x0: std_logic;
  signal delay45_q_net_x0: std_logic;
  signal enable_y_net_x0: std_logic;
  signal enable_y_net_x1: std_logic_vector(9 downto 0);
  signal inverter_op_net: std_logic;
  signal logical1_y_net: std_logic;
  signal logical1_y_net_x1: std_logic;
  signal logical_y_net_x0: std_logic;
  signal mux1_y_net_x0: std_logic;
  signal mux2_y_net: std_logic;
  signal r4_5g_specv5_snap_vacc2_ctrl_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal register1_q_net_x0: std_logic_vector(9 downto 0);
  signal register_q_net_x0: std_logic;
  signal reinterpret_output_port_net_x0: std_logic_vector(31 downto 0);
  signal trig1_y_net: std_logic;
  signal valid_y_net: std_logic;

begin
  ce_1_sg_x396 <= ce_1;
  clk_1_sg_x396 <= clk_1;
  delay35_q_net_x0 <= din;
  r4_5g_specv5_snap_vacc2_ctrl_user_data_out_net_x0 <= r4_5g_specv5_snap_vacc2_ctrl_user_data_out;
  delay45_q_net_x0 <= trig;
  delay36_q_net_x0 <= we;
  addr <= convert_dout_net_x1;
  bram <= convert_addr_dout_net_x1;
  bram_x0 <= convert_din_dout_net_x1;
  bram_x1 <= convert_we_dout_net_x1;

  addr_85723a3996: entity work.addr_entity_32c83c5028
    port map (
      reg_out => register1_q_net_x0,
      convert_x0 => convert_dout_net_x1
    );

  bram_a9b4102a30: entity work.bram_entity_ef33986178
    port map (
      addr => enable_y_net_x1,
      data_in => reinterpret_output_port_net_x0,
      we => logical1_y_net_x1,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din_x0 => convert_din_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1
    );

  constant1: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant1_op_net
    );

  constant2: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  enable: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => r4_5g_specv5_snap_vacc2_ctrl_user_data_out_net_x0,
      y(0) => enable_y_net_x0
    );

  freeze_cntr_9d0d7ae667: entity work.freeze_cntr_entity_b4db19b16d
    port map (
      ce_1 => ce_1_sg_x396,
      clk_1 => clk_1_sg_x396,
      en => mux1_y_net_x0,
      rst => register_q_net_x0,
      addr => enable_y_net_x1,
      we => logical1_y_net_x1
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x396,
      clk => clk_1_sg_x396,
      clr => '0',
      ip(0) => logical_y_net_x0,
      op(0) => inverter_op_net
    );

  logical1: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => mux2_y_net,
      d1(0) => inverter_op_net,
      y(0) => logical1_y_net
    );

  mux1: entity work.mux_d99e59b6d4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => delay36_q_net_x0,
      d1(0) => constant2_op_net,
      sel(0) => valid_y_net,
      y(0) => mux1_y_net_x0
    );

  mux2: entity work.mux_d99e59b6d4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => delay45_q_net_x0,
      d1(0) => constant1_op_net,
      sel(0) => trig1_y_net,
      y(0) => mux2_y_net
    );

  posedge_96dfb6bd44: entity work.posedge1_entity_d70b7fecd6
    port map (
      ce_1 => ce_1_sg_x396,
      clk_1 => clk_1_sg_x396,
      in_x0 => enable_y_net_x0,
      out_x0 => logical_y_net_x0
    );

  register1: entity work.xlregister
    generic map (
      d_width => 10,
      init_value => b"0000000000"
    )
    port map (
      ce => ce_1_sg_x396,
      clk => clk_1_sg_x396,
      d => enable_y_net_x1,
      en(0) => logical1_y_net_x1,
      rst(0) => logical_y_net_x0,
      q => register1_q_net_x0
    );

  register_x0: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x396,
      clk => clk_1_sg_x396,
      d(0) => constant_op_net,
      en(0) => logical_y_net_x0,
      rst(0) => logical1_y_net,
      q(0) => register_q_net_x0
    );

  reinterpret: entity work.reinterpret_3f7e3674f6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay35_q_net_x0,
      output_port => reinterpret_output_port_net_x0
    );

  trig1: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => r4_5g_specv5_snap_vacc2_ctrl_user_data_out_net_x0,
      y(0) => trig1_y_net
    );

  valid: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => r4_5g_specv5_snap_vacc2_ctrl_user_data_out_net_x0,
      y(0) => valid_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/snap_vacc3"

entity snap_vacc3_entity_74596c5e24 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc3_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    addr: out std_logic_vector(31 downto 0); 
    bram: out std_logic_vector(9 downto 0); 
    bram_x0: out std_logic_vector(31 downto 0); 
    bram_x1: out std_logic
  );
end snap_vacc3_entity_74596c5e24;

architecture structural of snap_vacc3_entity_74596c5e24 is
  signal ce_1_sg_x399: std_logic;
  signal clk_1_sg_x399: std_logic;
  signal constant1_op_net: std_logic;
  signal constant2_op_net: std_logic;
  signal constant_op_net: std_logic;
  signal convert_addr_dout_net_x1: std_logic_vector(9 downto 0);
  signal convert_din_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal delay37_q_net_x0: std_logic_vector(31 downto 0);
  signal delay45_q_net_x1: std_logic;
  signal delay47_q_net_x0: std_logic;
  signal enable_y_net_x0: std_logic;
  signal enable_y_net_x1: std_logic_vector(9 downto 0);
  signal inverter_op_net: std_logic;
  signal logical1_y_net: std_logic;
  signal logical1_y_net_x1: std_logic;
  signal logical_y_net_x0: std_logic;
  signal mux1_y_net_x0: std_logic;
  signal mux2_y_net: std_logic;
  signal r4_5g_specv5_snap_vacc3_ctrl_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal register1_q_net_x0: std_logic_vector(9 downto 0);
  signal register_q_net_x0: std_logic;
  signal reinterpret_output_port_net_x0: std_logic_vector(31 downto 0);
  signal trig1_y_net: std_logic;
  signal valid_y_net: std_logic;

begin
  ce_1_sg_x399 <= ce_1;
  clk_1_sg_x399 <= clk_1;
  delay37_q_net_x0 <= din;
  r4_5g_specv5_snap_vacc3_ctrl_user_data_out_net_x0 <= r4_5g_specv5_snap_vacc3_ctrl_user_data_out;
  delay45_q_net_x1 <= trig;
  delay47_q_net_x0 <= we;
  addr <= convert_dout_net_x1;
  bram <= convert_addr_dout_net_x1;
  bram_x0 <= convert_din_dout_net_x1;
  bram_x1 <= convert_we_dout_net_x1;

  addr_4982c0a208: entity work.addr_entity_32c83c5028
    port map (
      reg_out => register1_q_net_x0,
      convert_x0 => convert_dout_net_x1
    );

  bram_47dd84318e: entity work.bram_entity_ef33986178
    port map (
      addr => enable_y_net_x1,
      data_in => reinterpret_output_port_net_x0,
      we => logical1_y_net_x1,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din_x0 => convert_din_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1
    );

  constant1: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant1_op_net
    );

  constant2: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  enable: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => r4_5g_specv5_snap_vacc3_ctrl_user_data_out_net_x0,
      y(0) => enable_y_net_x0
    );

  freeze_cntr_9669e27cf6: entity work.freeze_cntr_entity_b4db19b16d
    port map (
      ce_1 => ce_1_sg_x399,
      clk_1 => clk_1_sg_x399,
      en => mux1_y_net_x0,
      rst => register_q_net_x0,
      addr => enable_y_net_x1,
      we => logical1_y_net_x1
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x399,
      clk => clk_1_sg_x399,
      clr => '0',
      ip(0) => logical_y_net_x0,
      op(0) => inverter_op_net
    );

  logical1: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => mux2_y_net,
      d1(0) => inverter_op_net,
      y(0) => logical1_y_net
    );

  mux1: entity work.mux_d99e59b6d4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => delay47_q_net_x0,
      d1(0) => constant2_op_net,
      sel(0) => valid_y_net,
      y(0) => mux1_y_net_x0
    );

  mux2: entity work.mux_d99e59b6d4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => delay45_q_net_x1,
      d1(0) => constant1_op_net,
      sel(0) => trig1_y_net,
      y(0) => mux2_y_net
    );

  posedge_7c65ed018f: entity work.posedge1_entity_d70b7fecd6
    port map (
      ce_1 => ce_1_sg_x399,
      clk_1 => clk_1_sg_x399,
      in_x0 => enable_y_net_x0,
      out_x0 => logical_y_net_x0
    );

  register1: entity work.xlregister
    generic map (
      d_width => 10,
      init_value => b"0000000000"
    )
    port map (
      ce => ce_1_sg_x399,
      clk => clk_1_sg_x399,
      d => enable_y_net_x1,
      en(0) => logical1_y_net_x1,
      rst(0) => logical_y_net_x0,
      q => register1_q_net_x0
    );

  register_x0: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x399,
      clk => clk_1_sg_x399,
      d(0) => constant_op_net,
      en(0) => logical_y_net_x0,
      rst(0) => logical1_y_net,
      q(0) => register_q_net_x0
    );

  reinterpret: entity work.reinterpret_3f7e3674f6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay37_q_net_x0,
      output_port => reinterpret_output_port_net_x0
    );

  trig1: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => r4_5g_specv5_snap_vacc3_ctrl_user_data_out_net_x0,
      y(0) => trig1_y_net
    );

  valid: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => r4_5g_specv5_snap_vacc3_ctrl_user_data_out_net_x0,
      y(0) => valid_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/vacc0/delay_bram"

entity delay_bram_entity_a2954a84b5 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in1: in std_logic_vector(31 downto 0); 
    out1: out std_logic_vector(31 downto 0)
  );
end delay_bram_entity_a2954a84b5;

architecture structural of delay_bram_entity_a2954a84b5 is
  signal adder0_s_net_x0: std_logic_vector(31 downto 0);
  signal ce_1_sg_x400: std_logic;
  signal clk_1_sg_x400: std_logic;
  signal constant2_op_net: std_logic;
  signal counter_op_net: std_logic_vector(9 downto 0);
  signal single_port_ram_data_out_net_x0: std_logic_vector(31 downto 0);

begin
  ce_1_sg_x400 <= ce_1;
  clk_1_sg_x400 <= clk_1;
  adder0_s_net_x0 <= in1;
  out1 <= single_port_ram_data_out_net_x0;

  constant2: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net
    );

  counter: entity work.xlcounter_limit
    generic map (
      cnt_15_0 => 1019,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "binary_counter_virtex5_10_0_1ee993c8ed57b9ce",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 10
    )
    port map (
      ce => ce_1_sg_x400,
      clk => clk_1_sg_x400,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

  single_port_ram: entity work.xlspram
    generic map (
      c_address_width => 10,
      c_width => 32,
      core_name0 => "bmg_24_vx5_6f3d016421754f60",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x400,
      clk => clk_1_sg_x400,
      data_in => adder0_s_net_x0,
      en => "1",
      rst => "0",
      we(0) => constant2_op_net,
      data_out => single_port_ram_data_out_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/vacc0/pulse_ext"

entity pulse_ext_entity_0ff64cdd38 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end pulse_ext_entity_0ff64cdd38;

architecture structural of pulse_ext_entity_0ff64cdd38 is
  signal ce_1_sg_x402: std_logic;
  signal clk_1_sg_x402: std_logic;
  signal constant5_op_net: std_logic_vector(10 downto 0);
  signal counter3_op_net: std_logic_vector(10 downto 0);
  signal delay24_q_net_x1: std_logic;
  signal logical_y_net_x0: std_logic;
  signal relational5_op_net_x0: std_logic;

begin
  ce_1_sg_x402 <= ce_1;
  clk_1_sg_x402 <= clk_1;
  delay24_q_net_x1 <= in_x0;
  out_x0 <= relational5_op_net_x0;

  constant5: entity work.constant_0604807f72
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant5_op_net
    );

  counter3: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_ed17144209261f47",
      op_arith => xlUnsigned,
      op_width => 11
    )
    port map (
      ce => ce_1_sg_x402,
      clk => clk_1_sg_x402,
      clr => '0',
      en(0) => relational5_op_net_x0,
      rst(0) => logical_y_net_x0,
      op => counter3_op_net
    );

  posedge_6aceed40b5: entity work.posedge1_entity_d70b7fecd6
    port map (
      ce_1 => ce_1_sg_x402,
      clk_1 => clk_1_sg_x402,
      in_x0 => delay24_q_net_x1,
      out_x0 => logical_y_net_x0
    );

  relational5: entity work.relational_b4b277ae0f
    port map (
      a => counter3_op_net,
      b => constant5_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational5_op_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5/vacc0"

entity vacc0_entity_ff1ce515bb is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(37 downto 0); 
    new_acc: in std_logic; 
    dout: out std_logic_vector(31 downto 0); 
    valid: out std_logic
  );
end vacc0_entity_ff1ce515bb;

architecture structural of vacc0_entity_ff1ce515bb is
  signal adder0_s_net_x0: std_logic_vector(31 downto 0);
  signal ce_1_sg_x403: std_logic;
  signal clk_1_sg_x403: std_logic;
  signal delay24_q_net_x2: std_logic;
  signal delay25_q_net_x0: std_logic_vector(37 downto 0);
  signal mux0_y_net: std_logic_vector(40 downto 0);
  signal relational5_op_net_x1: std_logic;
  signal single_port_ram_data_out_net_x1: std_logic_vector(31 downto 0);
  signal zero_op_net: std_logic_vector(31 downto 0);

begin
  ce_1_sg_x403 <= ce_1;
  clk_1_sg_x403 <= clk_1;
  delay25_q_net_x0 <= din;
  delay24_q_net_x2 <= new_acc;
  dout <= single_port_ram_data_out_net_x1;
  valid <= relational5_op_net_x1;

  adder0: entity work.addsub_4238e1a78a
    port map (
      a => delay25_q_net_x0,
      b => mux0_y_net,
      ce => ce_1_sg_x403,
      clk => clk_1_sg_x403,
      clr => '0',
      s => adder0_s_net_x0
    );

  delay_bram_a2954a84b5: entity work.delay_bram_entity_a2954a84b5
    port map (
      ce_1 => ce_1_sg_x403,
      clk_1 => clk_1_sg_x403,
      in1 => adder0_s_net_x0,
      out1 => single_port_ram_data_out_net_x1
    );

  mux0: entity work.mux_10eb3a1f2d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => single_port_ram_data_out_net_x1,
      d1 => zero_op_net,
      sel(0) => relational5_op_net_x1,
      y => mux0_y_net
    );

  pulse_ext_0ff64cdd38: entity work.pulse_ext_entity_0ff64cdd38
    port map (
      ce_1 => ce_1_sg_x403,
      clk_1 => clk_1_sg_x403,
      in_x0 => delay24_q_net_x2,
      out_x0 => relational5_op_net_x1
    );

  zero: entity work.constant_37567836aa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => zero_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "r4_5g_specV5"

entity r4_5g_specv5 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    r4_5g_specv5_acc_len_user_data_out: in std_logic_vector(31 downto 0); 
    r4_5g_specv5_adc_5g_user_data_valid: in std_logic; 
    r4_5g_specv5_adc_5g_user_datai0: in std_logic_vector(7 downto 0); 
    r4_5g_specv5_adc_5g_user_datai1: in std_logic_vector(7 downto 0); 
    r4_5g_specv5_adc_5g_user_datai2: in std_logic_vector(7 downto 0); 
    r4_5g_specv5_adc_5g_user_datai3: in std_logic_vector(7 downto 0); 
    r4_5g_specv5_adc_5g_user_dataq0: in std_logic_vector(7 downto 0); 
    r4_5g_specv5_adc_5g_user_dataq1: in std_logic_vector(7 downto 0); 
    r4_5g_specv5_adc_5g_user_dataq2: in std_logic_vector(7 downto 0); 
    r4_5g_specv5_adc_5g_user_dataq3: in std_logic_vector(7 downto 0); 
    r4_5g_specv5_adc_5g_user_outofrange0: in std_logic; 
    r4_5g_specv5_adc_5g_user_outofrange1: in std_logic; 
    r4_5g_specv5_adc_5g_user_sync0: in std_logic; 
    r4_5g_specv5_adc_5g_user_sync1: in std_logic; 
    r4_5g_specv5_adc_5g_user_sync2: in std_logic; 
    r4_5g_specv5_adc_5g_user_sync3: in std_logic; 
    r4_5g_specv5_cnt_rst_user_data_out: in std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_adc_bram_lsb_data_out: in std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_adc_bram_msb_data_out: in std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_adc_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc0_bram_data_out: in std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc0_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc1_bram_data_out: in std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc1_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc2_bram_data_out: in std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc2_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc3_bram_data_out: in std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc3_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    r4_5g_specv5_acc_cnt_user_data_in: out std_logic_vector(31 downto 0); 
    r4_5g_specv5_led0_sync_gateway: out std_logic; 
    r4_5g_specv5_led1_new_acc_gateway: out std_logic; 
    r4_5g_specv5_snap_adc_addr_user_data_in: out std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_adc_bram_lsb_addr: out std_logic_vector(12 downto 0); 
    r4_5g_specv5_snap_adc_bram_lsb_data_in: out std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_adc_bram_lsb_we: out std_logic; 
    r4_5g_specv5_snap_adc_bram_msb_addr: out std_logic_vector(12 downto 0); 
    r4_5g_specv5_snap_adc_bram_msb_data_in: out std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_adc_bram_msb_we: out std_logic; 
    r4_5g_specv5_snap_vacc0_addr_user_data_in: out std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc0_bram_addr: out std_logic_vector(9 downto 0); 
    r4_5g_specv5_snap_vacc0_bram_data_in: out std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc0_bram_we: out std_logic; 
    r4_5g_specv5_snap_vacc1_addr_user_data_in: out std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc1_bram_addr: out std_logic_vector(9 downto 0); 
    r4_5g_specv5_snap_vacc1_bram_data_in: out std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc1_bram_we: out std_logic; 
    r4_5g_specv5_snap_vacc2_addr_user_data_in: out std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc2_bram_addr: out std_logic_vector(9 downto 0); 
    r4_5g_specv5_snap_vacc2_bram_data_in: out std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc2_bram_we: out std_logic; 
    r4_5g_specv5_snap_vacc3_addr_user_data_in: out std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc3_bram_addr: out std_logic_vector(9 downto 0); 
    r4_5g_specv5_snap_vacc3_bram_data_in: out std_logic_vector(31 downto 0); 
    r4_5g_specv5_snap_vacc3_bram_we: out std_logic; 
    r4_5g_specv5_sync_cnt_user_data_in: out std_logic_vector(31 downto 0)
  );
end r4_5g_specv5;

architecture structural of r4_5g_specv5 is
  attribute core_generation_info: string;
  attribute core_generation_info of structural : architecture is "r4_5g_specV5,sysgen_core_10_1_3_1386,{total_blocks=10968,xilinx_adder_subtractor_block=384,xilinx_arithmetic_relational_operator_block=11,xilinx_binary_shift_operator_block=9,xilinx_bit_slice_extractor_block=749,xilinx_bus_concatenator_block=213,xilinx_bus_multiplexer_block=114,xilinx_constant_block_block=195,xilinx_counter_block=267,xilinx_delay_block=659,xilinx_disregard_subsystem_for_generation_block=6,xilinx_gateway_in_block=46,xilinx_gateway_out_block=33,xilinx_input_scaler_block=160,xilinx_inverter_block=37,xilinx_logical_block_block=30,xilinx_multiplier_block=176,xilinx_register_block=11,xilinx_single_port_random_access_memory_block=146,xilinx_single_port_read_only_memory_block=72,xilinx_system_generator_block=1,xilinx_type_converter_block=347,xilinx_type_reinterpreter_block=977,}";

  signal acc_cntr_op_net: std_logic_vector(31 downto 0);
  signal ce_1_sg_x416: std_logic;
  signal clk_1_sg_x416: std_logic;
  signal concat3_y_net_x0: std_logic_vector(63 downto 0);
  signal concat_y_net_x10: std_logic_vector(17 downto 0);
  signal concat_y_net_x11: std_logic_vector(17 downto 0);
  signal concat_y_net_x12: std_logic_vector(17 downto 0);
  signal concat_y_net_x13: std_logic_vector(17 downto 0);
  signal concat_y_net_x52: std_logic_vector(37 downto 0);
  signal concat_y_net_x53: std_logic_vector(37 downto 0);
  signal concat_y_net_x54: std_logic_vector(37 downto 0);
  signal concat_y_net_x55: std_logic_vector(37 downto 0);
  signal constant12_op_net_x0: std_logic;
  signal constant3_op_net_x0: std_logic;
  signal delay10_q_net_x0: std_logic;
  signal delay11_q_net_x0: std_logic_vector(31 downto 0);
  signal delay12_q_net_x0: std_logic;
  signal delay13_q_net_x0: std_logic_vector(31 downto 0);
  signal delay14_q_net: std_logic;
  signal delay15_q_net: std_logic_vector(37 downto 0);
  signal delay16_q_net: std_logic_vector(37 downto 0);
  signal delay17_q_net_x1: std_logic_vector(37 downto 0);
  signal delay18_q_net: std_logic_vector(37 downto 0);
  signal delay19_q_net: std_logic_vector(37 downto 0);
  signal delay1_q_net_x0: std_logic_vector(31 downto 0);
  signal delay20_q_net: std_logic_vector(31 downto 0);
  signal delay21_q_net_x0: std_logic_vector(31 downto 0);
  signal delay22_q_net_x2: std_logic_vector(7 downto 0);
  signal delay23_q_net_x0: std_logic_vector(31 downto 0);
  signal delay24_q_net_x2: std_logic;
  signal delay25_q_net_x0: std_logic_vector(37 downto 0);
  signal delay26_q_net_x2: std_logic;
  signal delay27_q_net_x0: std_logic_vector(37 downto 0);
  signal delay28_q_net: std_logic;
  signal delay29_q_net_x1: std_logic;
  signal delay2_q_net_x2: std_logic_vector(7 downto 0);
  signal delay30_q_net_x2: std_logic_vector(7 downto 0);
  signal delay31_q_net_x1: std_logic;
  signal delay32_q_net: std_logic_vector(7 downto 0);
  signal delay33_q_net: std_logic_vector(7 downto 0);
  signal delay34_q_net: std_logic_vector(37 downto 0);
  signal delay35_q_net_x0: std_logic_vector(31 downto 0);
  signal delay36_q_net_x0: std_logic;
  signal delay37_q_net_x0: std_logic_vector(31 downto 0);
  signal delay38_q_net_x1: std_logic_vector(37 downto 0);
  signal delay39_q_net: std_logic_vector(37 downto 0);
  signal delay3_q_net: std_logic_vector(7 downto 0);
  signal delay40_q_net: std_logic_vector(37 downto 0);
  signal delay41_q_net_x2: std_logic;
  signal delay42_q_net_x0: std_logic_vector(37 downto 0);
  signal delay43_q_net_x2: std_logic;
  signal delay44_q_net_x0: std_logic_vector(37 downto 0);
  signal delay45_q_net_x1: std_logic;
  signal delay46_q_net_x1: std_logic_vector(37 downto 0);
  signal delay47_q_net_x0: std_logic;
  signal delay48_q_net: std_logic_vector(37 downto 0);
  signal delay4_q_net: std_logic_vector(7 downto 0);
  signal delay5_q_net_x1: std_logic_vector(37 downto 0);
  signal delay7_q_net_x18: std_logic;
  signal delay8_q_net_x0: std_logic;
  signal delay9_q_net_x0: std_logic;
  signal delay_q_net_x2: std_logic_vector(7 downto 0);
  signal delay_q_net_x27: std_logic;
  signal logical_y_net_x2: std_logic;
  signal logical_y_net_x3: std_logic;
  signal power_adder_s_net_x0: std_logic_vector(37 downto 0);
  signal power_adder_s_net_x1: std_logic_vector(37 downto 0);
  signal power_adder_s_net_x2: std_logic_vector(37 downto 0);
  signal power_adder_s_net_x3: std_logic_vector(37 downto 0);
  signal r4_5g_specv5_acc_cnt_user_data_in_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_acc_len_user_data_out_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_adc_5g_user_data_valid_net: std_logic;
  signal r4_5g_specv5_adc_5g_user_datai0_net: std_logic_vector(7 downto 0);
  signal r4_5g_specv5_adc_5g_user_datai1_net: std_logic_vector(7 downto 0);
  signal r4_5g_specv5_adc_5g_user_datai2_net: std_logic_vector(7 downto 0);
  signal r4_5g_specv5_adc_5g_user_datai3_net: std_logic_vector(7 downto 0);
  signal r4_5g_specv5_adc_5g_user_dataq0_net: std_logic_vector(7 downto 0);
  signal r4_5g_specv5_adc_5g_user_dataq1_net: std_logic_vector(7 downto 0);
  signal r4_5g_specv5_adc_5g_user_dataq2_net: std_logic_vector(7 downto 0);
  signal r4_5g_specv5_adc_5g_user_dataq3_net: std_logic_vector(7 downto 0);
  signal r4_5g_specv5_adc_5g_user_outofrange0_net: std_logic;
  signal r4_5g_specv5_adc_5g_user_outofrange1_net: std_logic;
  signal r4_5g_specv5_adc_5g_user_sync0_net: std_logic;
  signal r4_5g_specv5_adc_5g_user_sync1_net: std_logic;
  signal r4_5g_specv5_adc_5g_user_sync2_net: std_logic;
  signal r4_5g_specv5_adc_5g_user_sync3_net: std_logic;
  signal r4_5g_specv5_cnt_rst_user_data_out_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_led0_sync_gateway_net: std_logic;
  signal r4_5g_specv5_led1_new_acc_gateway_net: std_logic;
  signal r4_5g_specv5_snap_adc_addr_user_data_in_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_adc_bram_lsb_addr_net: std_logic_vector(12 downto 0);
  signal r4_5g_specv5_snap_adc_bram_lsb_data_in_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_adc_bram_lsb_data_out_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_adc_bram_lsb_we_net: std_logic;
  signal r4_5g_specv5_snap_adc_bram_msb_addr_net: std_logic_vector(12 downto 0);
  signal r4_5g_specv5_snap_adc_bram_msb_data_in_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_adc_bram_msb_data_out_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_adc_bram_msb_we_net: std_logic;
  signal r4_5g_specv5_snap_adc_ctrl_user_data_out_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_vacc0_addr_user_data_in_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_vacc0_bram_addr_net: std_logic_vector(9 downto 0);
  signal r4_5g_specv5_snap_vacc0_bram_data_in_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_vacc0_bram_data_out_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_vacc0_bram_we_net: std_logic;
  signal r4_5g_specv5_snap_vacc0_ctrl_user_data_out_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_vacc1_addr_user_data_in_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_vacc1_bram_addr_net: std_logic_vector(9 downto 0);
  signal r4_5g_specv5_snap_vacc1_bram_data_in_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_vacc1_bram_data_out_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_vacc1_bram_we_net: std_logic;
  signal r4_5g_specv5_snap_vacc1_ctrl_user_data_out_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_vacc2_addr_user_data_in_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_vacc2_bram_addr_net: std_logic_vector(9 downto 0);
  signal r4_5g_specv5_snap_vacc2_bram_data_in_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_vacc2_bram_data_out_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_vacc2_bram_we_net: std_logic;
  signal r4_5g_specv5_snap_vacc2_ctrl_user_data_out_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_vacc3_addr_user_data_in_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_vacc3_bram_addr_net: std_logic_vector(9 downto 0);
  signal r4_5g_specv5_snap_vacc3_bram_data_in_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_vacc3_bram_data_out_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_snap_vacc3_bram_we_net: std_logic;
  signal r4_5g_specv5_snap_vacc3_ctrl_user_data_out_net: std_logic_vector(31 downto 0);
  signal r4_5g_specv5_sync_cnt_user_data_in_net: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(7 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(7 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(7 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(7 downto 0);
  signal reinterpret5_output_port_net: std_logic_vector(7 downto 0);
  signal reinterpret6_output_port_net: std_logic_vector(7 downto 0);
  signal reinterpret7_output_port_net: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x10: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x11: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x12: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x13: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x14: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x15: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x8: std_logic_vector(7 downto 0);
  signal reinterpret_output_port_net_x9: std_logic_vector(7 downto 0);
  signal relational5_op_net_x0: std_logic;
  signal relational5_op_net_x1: std_logic;
  signal relational5_op_net_x2: std_logic;
  signal relational5_op_net_x3: std_logic;
  signal relational5_op_net_x4: std_logic;
  signal relational5_op_net_x5: std_logic;
  signal shift1_op_net_x3: std_logic_vector(17 downto 0);
  signal shift4_op_net_x4: std_logic_vector(17 downto 0);
  signal shift5_op_net_x4: std_logic_vector(17 downto 0);
  signal shift_op_net_x3: std_logic_vector(17 downto 0);
  signal single_port_ram_data_out_net_x1: std_logic_vector(31 downto 0);
  signal single_port_ram_data_out_net_x2: std_logic_vector(31 downto 0);
  signal single_port_ram_data_out_net_x3: std_logic_vector(31 downto 0);
  signal single_port_ram_data_out_net_x4: std_logic_vector(31 downto 0);
  signal slice2_y_net: std_logic;
  signal slice_y_net_x0: std_logic;
  signal sync_cntr_op_net: std_logic_vector(31 downto 0);
  signal sync_gen_op_net: std_logic_vector(26 downto 0);

begin
  ce_1_sg_x416 <= ce_1;
  clk_1_sg_x416 <= clk_1;
  r4_5g_specv5_acc_len_user_data_out_net <= r4_5g_specv5_acc_len_user_data_out;
  r4_5g_specv5_adc_5g_user_data_valid_net <= r4_5g_specv5_adc_5g_user_data_valid;
  r4_5g_specv5_adc_5g_user_datai0_net <= r4_5g_specv5_adc_5g_user_datai0;
  r4_5g_specv5_adc_5g_user_datai1_net <= r4_5g_specv5_adc_5g_user_datai1;
  r4_5g_specv5_adc_5g_user_datai2_net <= r4_5g_specv5_adc_5g_user_datai2;
  r4_5g_specv5_adc_5g_user_datai3_net <= r4_5g_specv5_adc_5g_user_datai3;
  r4_5g_specv5_adc_5g_user_dataq0_net <= r4_5g_specv5_adc_5g_user_dataq0;
  r4_5g_specv5_adc_5g_user_dataq1_net <= r4_5g_specv5_adc_5g_user_dataq1;
  r4_5g_specv5_adc_5g_user_dataq2_net <= r4_5g_specv5_adc_5g_user_dataq2;
  r4_5g_specv5_adc_5g_user_dataq3_net <= r4_5g_specv5_adc_5g_user_dataq3;
  r4_5g_specv5_adc_5g_user_outofrange0_net <= r4_5g_specv5_adc_5g_user_outofrange0;
  r4_5g_specv5_adc_5g_user_outofrange1_net <= r4_5g_specv5_adc_5g_user_outofrange1;
  r4_5g_specv5_adc_5g_user_sync0_net <= r4_5g_specv5_adc_5g_user_sync0;
  r4_5g_specv5_adc_5g_user_sync1_net <= r4_5g_specv5_adc_5g_user_sync1;
  r4_5g_specv5_adc_5g_user_sync2_net <= r4_5g_specv5_adc_5g_user_sync2;
  r4_5g_specv5_adc_5g_user_sync3_net <= r4_5g_specv5_adc_5g_user_sync3;
  r4_5g_specv5_cnt_rst_user_data_out_net <= r4_5g_specv5_cnt_rst_user_data_out;
  r4_5g_specv5_snap_adc_bram_lsb_data_out_net <= r4_5g_specv5_snap_adc_bram_lsb_data_out;
  r4_5g_specv5_snap_adc_bram_msb_data_out_net <= r4_5g_specv5_snap_adc_bram_msb_data_out;
  r4_5g_specv5_snap_adc_ctrl_user_data_out_net <= r4_5g_specv5_snap_adc_ctrl_user_data_out;
  r4_5g_specv5_snap_vacc0_bram_data_out_net <= r4_5g_specv5_snap_vacc0_bram_data_out;
  r4_5g_specv5_snap_vacc0_ctrl_user_data_out_net <= r4_5g_specv5_snap_vacc0_ctrl_user_data_out;
  r4_5g_specv5_snap_vacc1_bram_data_out_net <= r4_5g_specv5_snap_vacc1_bram_data_out;
  r4_5g_specv5_snap_vacc1_ctrl_user_data_out_net <= r4_5g_specv5_snap_vacc1_ctrl_user_data_out;
  r4_5g_specv5_snap_vacc2_bram_data_out_net <= r4_5g_specv5_snap_vacc2_bram_data_out;
  r4_5g_specv5_snap_vacc2_ctrl_user_data_out_net <= r4_5g_specv5_snap_vacc2_ctrl_user_data_out;
  r4_5g_specv5_snap_vacc3_bram_data_out_net <= r4_5g_specv5_snap_vacc3_bram_data_out;
  r4_5g_specv5_snap_vacc3_ctrl_user_data_out_net <= r4_5g_specv5_snap_vacc3_ctrl_user_data_out;
  r4_5g_specv5_acc_cnt_user_data_in <= r4_5g_specv5_acc_cnt_user_data_in_net;
  r4_5g_specv5_led0_sync_gateway <= r4_5g_specv5_led0_sync_gateway_net;
  r4_5g_specv5_led1_new_acc_gateway <= r4_5g_specv5_led1_new_acc_gateway_net;
  r4_5g_specv5_snap_adc_addr_user_data_in <= r4_5g_specv5_snap_adc_addr_user_data_in_net;
  r4_5g_specv5_snap_adc_bram_lsb_addr <= r4_5g_specv5_snap_adc_bram_lsb_addr_net;
  r4_5g_specv5_snap_adc_bram_lsb_data_in <= r4_5g_specv5_snap_adc_bram_lsb_data_in_net;
  r4_5g_specv5_snap_adc_bram_lsb_we <= r4_5g_specv5_snap_adc_bram_lsb_we_net;
  r4_5g_specv5_snap_adc_bram_msb_addr <= r4_5g_specv5_snap_adc_bram_msb_addr_net;
  r4_5g_specv5_snap_adc_bram_msb_data_in <= r4_5g_specv5_snap_adc_bram_msb_data_in_net;
  r4_5g_specv5_snap_adc_bram_msb_we <= r4_5g_specv5_snap_adc_bram_msb_we_net;
  r4_5g_specv5_snap_vacc0_addr_user_data_in <= r4_5g_specv5_snap_vacc0_addr_user_data_in_net;
  r4_5g_specv5_snap_vacc0_bram_addr <= r4_5g_specv5_snap_vacc0_bram_addr_net;
  r4_5g_specv5_snap_vacc0_bram_data_in <= r4_5g_specv5_snap_vacc0_bram_data_in_net;
  r4_5g_specv5_snap_vacc0_bram_we <= r4_5g_specv5_snap_vacc0_bram_we_net;
  r4_5g_specv5_snap_vacc1_addr_user_data_in <= r4_5g_specv5_snap_vacc1_addr_user_data_in_net;
  r4_5g_specv5_snap_vacc1_bram_addr <= r4_5g_specv5_snap_vacc1_bram_addr_net;
  r4_5g_specv5_snap_vacc1_bram_data_in <= r4_5g_specv5_snap_vacc1_bram_data_in_net;
  r4_5g_specv5_snap_vacc1_bram_we <= r4_5g_specv5_snap_vacc1_bram_we_net;
  r4_5g_specv5_snap_vacc2_addr_user_data_in <= r4_5g_specv5_snap_vacc2_addr_user_data_in_net;
  r4_5g_specv5_snap_vacc2_bram_addr <= r4_5g_specv5_snap_vacc2_bram_addr_net;
  r4_5g_specv5_snap_vacc2_bram_data_in <= r4_5g_specv5_snap_vacc2_bram_data_in_net;
  r4_5g_specv5_snap_vacc2_bram_we <= r4_5g_specv5_snap_vacc2_bram_we_net;
  r4_5g_specv5_snap_vacc3_addr_user_data_in <= r4_5g_specv5_snap_vacc3_addr_user_data_in_net;
  r4_5g_specv5_snap_vacc3_bram_addr <= r4_5g_specv5_snap_vacc3_bram_addr_net;
  r4_5g_specv5_snap_vacc3_bram_data_in <= r4_5g_specv5_snap_vacc3_bram_data_in_net;
  r4_5g_specv5_snap_vacc3_bram_we <= r4_5g_specv5_snap_vacc3_bram_we_net;
  r4_5g_specv5_sync_cnt_user_data_in <= r4_5g_specv5_sync_cnt_user_data_in_net;

  acc_cnt_b52af162d4: entity work.acc_cnt_entity_b52af162d4
    port map (
      reg_out => delay1_q_net_x0,
      convert_x0 => r4_5g_specv5_acc_cnt_user_data_in_net
    );

  acc_cntr: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_487c95d8131ef26d",
      op_arith => xlUnsigned,
      op_width => 32
    )
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      en(0) => delay28_q_net,
      rst(0) => slice2_y_net,
      op => acc_cntr_op_net
    );

  acc_cntrl_1d98c79a3b: entity work.acc_cntrl_entity_1d98c79a3b
    port map (
      acc_len => delay23_q_net_x0,
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      sync => delay10_q_net_x0,
      new_acc => logical_y_net_x2
    );

  adc_5g_8d8c5a29fa: entity work.adc_5g_entity_8d8c5a29fa
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      r4_5g_specv5_adc_5g_user_datai0 => r4_5g_specv5_adc_5g_user_datai0_net,
      r4_5g_specv5_adc_5g_user_datai1 => r4_5g_specv5_adc_5g_user_datai1_net,
      r4_5g_specv5_adc_5g_user_datai2 => r4_5g_specv5_adc_5g_user_datai2_net,
      r4_5g_specv5_adc_5g_user_datai3 => r4_5g_specv5_adc_5g_user_datai3_net,
      r4_5g_specv5_adc_5g_user_dataq0 => r4_5g_specv5_adc_5g_user_dataq0_net,
      r4_5g_specv5_adc_5g_user_dataq1 => r4_5g_specv5_adc_5g_user_dataq1_net,
      r4_5g_specv5_adc_5g_user_dataq2 => r4_5g_specv5_adc_5g_user_dataq2_net,
      r4_5g_specv5_adc_5g_user_dataq3 => r4_5g_specv5_adc_5g_user_dataq3_net,
      i0 => reinterpret_output_port_net_x8,
      i1 => reinterpret_output_port_net_x9,
      i2 => reinterpret_output_port_net_x10,
      i3 => reinterpret_output_port_net_x11,
      q0 => reinterpret_output_port_net_x12,
      q1 => reinterpret_output_port_net_x13,
      q2 => reinterpret_output_port_net_x14,
      q3 => reinterpret_output_port_net_x15
    );

  concat3: entity work.concat_15d98836ad
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret_output_port_net,
      in1 => reinterpret1_output_port_net,
      in2 => reinterpret2_output_port_net,
      in3 => reinterpret3_output_port_net,
      in4 => reinterpret4_output_port_net,
      in5 => reinterpret5_output_port_net,
      in6 => reinterpret6_output_port_net,
      in7 => reinterpret7_output_port_net,
      y => concat3_y_net_x0
    );

  constant12: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant12_op_net_x0
    );

  constant3: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant3_op_net_x0
    );

  delay: entity work.delay_23f848c85b
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => reinterpret_output_port_net_x8,
      q => delay_q_net_x2
    );

  delay1: entity work.delay_3f5b23b538
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => acc_cntr_op_net,
      q => delay1_q_net_x0
    );

  delay10: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d(0) => delay14_q_net,
      q(0) => delay10_q_net_x0
    );

  delay11: entity work.delay_3f5b23b538
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => single_port_ram_data_out_net_x1,
      q => delay11_q_net_x0
    );

  delay12: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d(0) => relational5_op_net_x2,
      q(0) => delay12_q_net_x0
    );

  delay13: entity work.delay_3f5b23b538
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => single_port_ram_data_out_net_x2,
      q => delay13_q_net_x0
    );

  delay14: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d(0) => logical_y_net_x3,
      q(0) => delay14_q_net
    );

  delay15: entity work.delay_b40a532a7c
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => concat_y_net_x52,
      q => delay15_q_net
    );

  delay16: entity work.delay_b40a532a7c
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => concat_y_net_x53,
      q => delay16_q_net
    );

  delay17: entity work.delay_d64b27fc5c
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => delay16_q_net,
      q => delay17_q_net_x1
    );

  delay18: entity work.delay_d64b27fc5c
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => power_adder_s_net_x0,
      q => delay18_q_net
    );

  delay19: entity work.delay_d64b27fc5c
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => power_adder_s_net_x1,
      q => delay19_q_net
    );

  delay2: entity work.delay_23f848c85b
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => reinterpret_output_port_net_x9,
      q => delay2_q_net_x2
    );

  delay20: entity work.delay_3f5b23b538
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => r4_5g_specv5_cnt_rst_user_data_out_net,
      q => delay20_q_net
    );

  delay21: entity work.delay_3f5b23b538
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => sync_cntr_op_net,
      q => delay21_q_net_x0
    );

  delay22: entity work.delay_23f848c85b
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => reinterpret_output_port_net_x12,
      q => delay22_q_net_x2
    );

  delay23: entity work.delay_3f5b23b538
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => r4_5g_specv5_acc_len_user_data_out_net,
      q => delay23_q_net_x0
    );

  delay24: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d(0) => logical_y_net_x2,
      q(0) => delay24_q_net_x2
    );

  delay25: entity work.delay_b40a532a7c
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => delay18_q_net,
      q => delay25_q_net_x0
    );

  delay26: entity work.delay_23d71a76f2
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d(0) => logical_y_net_x2,
      q(0) => delay26_q_net_x2
    );

  delay27: entity work.delay_29899636e8
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => delay19_q_net,
      q => delay27_q_net_x0
    );

  delay28: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d(0) => logical_y_net_x2,
      q(0) => delay28_q_net
    );

  delay29: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d(0) => logical_y_net_x2,
      q(0) => delay29_q_net_x1
    );

  delay3: entity work.delay_23f848c85b
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => reinterpret_output_port_net_x10,
      q => delay3_q_net
    );

  delay30: entity work.delay_23f848c85b
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => reinterpret_output_port_net_x13,
      q => delay30_q_net_x2
    );

  delay31: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d(0) => logical_y_net_x2,
      q(0) => delay31_q_net_x1
    );

  delay32: entity work.delay_23f848c85b
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => reinterpret_output_port_net_x14,
      q => delay32_q_net
    );

  delay33: entity work.delay_23f848c85b
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => reinterpret_output_port_net_x15,
      q => delay33_q_net
    );

  delay34: entity work.delay_b40a532a7c
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => concat_y_net_x54,
      q => delay34_q_net
    );

  delay35: entity work.delay_3f5b23b538
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => single_port_ram_data_out_net_x3,
      q => delay35_q_net_x0
    );

  delay36: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d(0) => relational5_op_net_x4,
      q(0) => delay36_q_net_x0
    );

  delay37: entity work.delay_3f5b23b538
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => single_port_ram_data_out_net_x4,
      q => delay37_q_net_x0
    );

  delay38: entity work.delay_d64b27fc5c
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => delay48_q_net,
      q => delay38_q_net_x1
    );

  delay39: entity work.delay_d64b27fc5c
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => power_adder_s_net_x2,
      q => delay39_q_net
    );

  delay4: entity work.delay_23f848c85b
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => reinterpret_output_port_net_x11,
      q => delay4_q_net
    );

  delay40: entity work.delay_d64b27fc5c
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => power_adder_s_net_x3,
      q => delay40_q_net
    );

  delay41: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d(0) => logical_y_net_x2,
      q(0) => delay41_q_net_x2
    );

  delay42: entity work.delay_b40a532a7c
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => delay39_q_net,
      q => delay42_q_net_x0
    );

  delay43: entity work.delay_23d71a76f2
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d(0) => logical_y_net_x2,
      q(0) => delay43_q_net_x2
    );

  delay44: entity work.delay_29899636e8
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => delay40_q_net,
      q => delay44_q_net_x0
    );

  delay45: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d(0) => logical_y_net_x2,
      q(0) => delay45_q_net_x1
    );

  delay46: entity work.delay_d64b27fc5c
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => delay34_q_net,
      q => delay46_q_net_x1
    );

  delay47: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d(0) => relational5_op_net_x5,
      q(0) => delay47_q_net_x0
    );

  delay48: entity work.delay_b40a532a7c
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => concat_y_net_x55,
      q => delay48_q_net
    );

  delay5: entity work.delay_d64b27fc5c
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d => delay15_q_net,
      q => delay5_q_net_x1
    );

  delay7: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d(0) => logical_y_net_x3,
      q(0) => delay7_q_net_x18
    );

  delay8: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d(0) => relational5_op_net_x3,
      q(0) => delay8_q_net_x0
    );

  delay9: entity work.delay_e18fb31a3d
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      d(0) => relational5_op_net_x0,
      q(0) => delay9_q_net_x0
    );

  fir_1_d77345f031: entity work.fir_1_entity_d77345f031
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      in_x0 => delay_q_net_x2,
      sync_in => delay7_q_net_x18,
      out_x0 => concat_y_net_x10
    );

  fir_2_505f1fa065: entity work.fir_1_entity_d77345f031
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      in_x0 => delay2_q_net_x2,
      sync_in => delay7_q_net_x18,
      out_x0 => concat_y_net_x11
    );

  fir_4_9067c135e4: entity work.fir_4_entity_9067c135e4
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      sync_in => delay7_q_net_x18,
      sync_out => delay_q_net_x27
    );

  fir_5_319448d4dd: entity work.fir_1_entity_d77345f031
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      in_x0 => delay22_q_net_x2,
      sync_in => delay7_q_net_x18,
      out_x0 => concat_y_net_x12
    );

  fir_6_e2e7505615: entity work.fir_1_entity_d77345f031
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      in_x0 => delay30_q_net_x2,
      sync_in => delay7_q_net_x18,
      out_x0 => concat_y_net_x13
    );

  led0_sync_f85f7d5b7c: entity work.led0_sync_entity_f85f7d5b7c
    port map (
      gpio_out => relational5_op_net_x1,
      convert_x0 => r4_5g_specv5_led0_sync_gateway_net
    );

  led1_new_acc_3d073be33e: entity work.led0_sync_entity_f85f7d5b7c
    port map (
      gpio_out => delay9_q_net_x0,
      convert_x0 => r4_5g_specv5_led1_new_acc_gateway_net
    );

  posedge_8be8a69257: entity work.posedge1_entity_d70b7fecd6
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      in_x0 => slice_y_net_x0,
      out_x0 => logical_y_net_x3
    );

  pulse_ext1_4051a15797: entity work.pulse_ext1_entity_4051a15797
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      in_x0 => logical_y_net_x3,
      out_x0 => relational5_op_net_x1
    );

  pulse_ext2_dbf0e456b3: entity work.pulse_ext1_entity_4051a15797
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      in_x0 => delay31_q_net_x1,
      out_x0 => relational5_op_net_x0
    );

  r4_dit_fft_bb20d3c530: entity work.r4_dit_fft_entity_bb20d3c530
    port map (
      a_in => shift_op_net_x3,
      b_in => shift1_op_net_x3,
      c_in => shift4_op_net_x4,
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      d_in => shift5_op_net_x4,
      sync_in => delay_q_net_x27,
      a_out => concat_y_net_x52,
      b_out => concat_y_net_x53,
      c_out => concat_y_net_x54,
      d_out => concat_y_net_x55
    );

  r4_power19_1_4d56d1ab0b: entity work.r4_power19_1_entity_4d56d1ab0b
    port map (
      c => delay5_q_net_x1,
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      power => power_adder_s_net_x0
    );

  r4_power19_2_8cd3f03928: entity work.r4_power19_1_entity_4d56d1ab0b
    port map (
      c => delay17_q_net_x1,
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      power => power_adder_s_net_x1
    );

  r4_power19_3_abbddd9be9: entity work.r4_power19_1_entity_4d56d1ab0b
    port map (
      c => delay46_q_net_x1,
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      power => power_adder_s_net_x2
    );

  r4_power19_4_0bb314159a: entity work.r4_power19_1_entity_4d56d1ab0b
    port map (
      c => delay38_q_net_x1,
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      power => power_adder_s_net_x3
    );

  reinterpret: entity work.reinterpret_d51df7ac30
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay_q_net_x2,
      output_port => reinterpret_output_port_net
    );

  reinterpret1: entity work.reinterpret_d51df7ac30
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay2_q_net_x2,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_d51df7ac30
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay3_q_net,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_d51df7ac30
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay4_q_net,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_d51df7ac30
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay22_q_net_x2,
      output_port => reinterpret4_output_port_net
    );

  reinterpret5: entity work.reinterpret_d51df7ac30
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay30_q_net_x2,
      output_port => reinterpret5_output_port_net
    );

  reinterpret6: entity work.reinterpret_d51df7ac30
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay32_q_net,
      output_port => reinterpret6_output_port_net
    );

  reinterpret7: entity work.reinterpret_d51df7ac30
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay33_q_net,
      output_port => reinterpret7_output_port_net
    );

  shift: entity work.shift_407d711ee5
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      ip => concat_y_net_x10,
      op => shift_op_net_x3
    );

  shift1: entity work.shift_407d711ee5
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      ip => concat_y_net_x11,
      op => shift1_op_net_x3
    );

  shift4: entity work.shift_407d711ee5
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      ip => concat_y_net_x12,
      op => shift4_op_net_x4
    );

  shift5: entity work.shift_407d711ee5
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      ip => concat_y_net_x13,
      op => shift5_op_net_x4
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 25,
      new_msb => 25,
      x_width => 27,
      y_width => 1
    )
    port map (
      x => sync_gen_op_net,
      y(0) => slice_y_net_x0
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => delay20_q_net,
      y(0) => slice2_y_net
    );

  snap_adc_4bfcd7107d: entity work.snap_adc_entity_4bfcd7107d
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      din => concat3_y_net_x0,
      r4_5g_specv5_snap_adc_ctrl_user_data_out => r4_5g_specv5_snap_adc_ctrl_user_data_out_net,
      trig => constant3_op_net_x0,
      we => constant12_op_net_x0,
      addr => r4_5g_specv5_snap_adc_addr_user_data_in_net,
      bram_lsb => r4_5g_specv5_snap_adc_bram_lsb_addr_net,
      bram_lsb_x0 => r4_5g_specv5_snap_adc_bram_lsb_data_in_net,
      bram_lsb_x1 => r4_5g_specv5_snap_adc_bram_lsb_we_net,
      bram_msb => r4_5g_specv5_snap_adc_bram_msb_addr_net,
      bram_msb_x0 => r4_5g_specv5_snap_adc_bram_msb_data_in_net,
      bram_msb_x1 => r4_5g_specv5_snap_adc_bram_msb_we_net
    );

  snap_vacc0_f1b6ff57cb: entity work.snap_vacc0_entity_f1b6ff57cb
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      din => delay11_q_net_x0,
      r4_5g_specv5_snap_vacc0_ctrl_user_data_out => r4_5g_specv5_snap_vacc0_ctrl_user_data_out_net,
      trig => delay29_q_net_x1,
      we => delay12_q_net_x0,
      addr => r4_5g_specv5_snap_vacc0_addr_user_data_in_net,
      bram => r4_5g_specv5_snap_vacc0_bram_addr_net,
      bram_x0 => r4_5g_specv5_snap_vacc0_bram_data_in_net,
      bram_x1 => r4_5g_specv5_snap_vacc0_bram_we_net
    );

  snap_vacc1_a816baf518: entity work.snap_vacc1_entity_a816baf518
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      din => delay13_q_net_x0,
      r4_5g_specv5_snap_vacc1_ctrl_user_data_out => r4_5g_specv5_snap_vacc1_ctrl_user_data_out_net,
      trig => delay29_q_net_x1,
      we => delay8_q_net_x0,
      addr => r4_5g_specv5_snap_vacc1_addr_user_data_in_net,
      bram => r4_5g_specv5_snap_vacc1_bram_addr_net,
      bram_x0 => r4_5g_specv5_snap_vacc1_bram_data_in_net,
      bram_x1 => r4_5g_specv5_snap_vacc1_bram_we_net
    );

  snap_vacc2_c2f47281df: entity work.snap_vacc2_entity_c2f47281df
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      din => delay35_q_net_x0,
      r4_5g_specv5_snap_vacc2_ctrl_user_data_out => r4_5g_specv5_snap_vacc2_ctrl_user_data_out_net,
      trig => delay45_q_net_x1,
      we => delay36_q_net_x0,
      addr => r4_5g_specv5_snap_vacc2_addr_user_data_in_net,
      bram => r4_5g_specv5_snap_vacc2_bram_addr_net,
      bram_x0 => r4_5g_specv5_snap_vacc2_bram_data_in_net,
      bram_x1 => r4_5g_specv5_snap_vacc2_bram_we_net
    );

  snap_vacc3_74596c5e24: entity work.snap_vacc3_entity_74596c5e24
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      din => delay37_q_net_x0,
      r4_5g_specv5_snap_vacc3_ctrl_user_data_out => r4_5g_specv5_snap_vacc3_ctrl_user_data_out_net,
      trig => delay45_q_net_x1,
      we => delay47_q_net_x0,
      addr => r4_5g_specv5_snap_vacc3_addr_user_data_in_net,
      bram => r4_5g_specv5_snap_vacc3_bram_addr_net,
      bram_x0 => r4_5g_specv5_snap_vacc3_bram_data_in_net,
      bram_x1 => r4_5g_specv5_snap_vacc3_bram_we_net
    );

  sync_cnt_1a96c3e534: entity work.acc_cnt_entity_b52af162d4
    port map (
      reg_out => delay21_q_net_x0,
      convert_x0 => r4_5g_specv5_sync_cnt_user_data_in_net
    );

  sync_cntr: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_487c95d8131ef26d",
      op_arith => xlUnsigned,
      op_width => 32
    )
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      en(0) => logical_y_net_x3,
      rst(0) => slice2_y_net,
      op => sync_cntr_op_net
    );

  sync_gen: entity work.xlcounter_free
    generic map (
      core_name0 => "binary_counter_virtex5_10_0_f8c7b661c01eeb1d",
      op_arith => xlUnsigned,
      op_width => 27
    )
    port map (
      ce => ce_1_sg_x416,
      clk => clk_1_sg_x416,
      clr => '0',
      en => "1",
      rst => "0",
      op => sync_gen_op_net
    );

  vacc0_ff1ce515bb: entity work.vacc0_entity_ff1ce515bb
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      din => delay25_q_net_x0,
      new_acc => delay24_q_net_x2,
      dout => single_port_ram_data_out_net_x1,
      valid => relational5_op_net_x2
    );

  vacc1_cb7b32fb54: entity work.vacc0_entity_ff1ce515bb
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      din => delay27_q_net_x0,
      new_acc => delay26_q_net_x2,
      dout => single_port_ram_data_out_net_x2,
      valid => relational5_op_net_x3
    );

  vacc2_e508517ffc: entity work.vacc0_entity_ff1ce515bb
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      din => delay42_q_net_x0,
      new_acc => delay41_q_net_x2,
      dout => single_port_ram_data_out_net_x3,
      valid => relational5_op_net_x4
    );

  vacc3_acfd8cbee2: entity work.vacc0_entity_ff1ce515bb
    port map (
      ce_1 => ce_1_sg_x416,
      clk_1 => clk_1_sg_x416,
      din => delay44_q_net_x0,
      new_acc => delay43_q_net_x2,
      dout => single_port_ram_data_out_net_x4,
      valid => relational5_op_net_x5
    );

end structural;
